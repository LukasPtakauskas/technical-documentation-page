<!DOCTYPE html>
<html lang="en">

<head>
  <title> technical documentation PHP </title>
  <meta charset="UTF-8">
  <meta name="author" content="Lukas Ptakauskas">
  <meta name="author_mail" content="lukas.ptakauskas@gmail.com">
  <meta http-equiv="refresh" content="100">

  <link rel="stylesheet" href="style.css">
</head>

<body>
  <nav id="navbar">
    <header>PHP Documentation</header>
    <a class="nav-link" rel="bookmark" href="#Basic_syntax"> Basic syntax </a>
    <a class="nav-link" rel="bookmark" href="#PHP_tags"> PHP tags </a>
    <a class="nav-link" rel="bookmark" href="#Escaping_from_HTML"> Escaping from HTML </a>
    <a class="nav-link" rel="bookmark" href="#Instruction_separation"> Instruction separation </a>
    <a class="nav-link" rel="bookmark" href="#Comments"> Comments </a>
    <a class="nav-link" rel="bookmark" href="#Types"> Types </a>
    <a class="nav-link" rel="bookmark" href="#Types_Introduction"> Types Introduction </a>
    <a class="nav-link" rel="bookmark" href="#Booleans"> Booleans </a>
    <a class="nav-link" rel="bookmark" href="#Integers"> Integers </a>
    <a class="nav-link" rel="bookmark" href="#Floating_point_numbers"> Floating point numbers </a>
    <a class="nav-link" rel="bookmark" href="#Strings"> Strings </a>
    <a class="nav-link" rel="bookmark" href="#Arrays"> Arrays </a>
    <a class="nav-link" rel="bookmark" href="#Iterables"> Iterables </a>
    <a class="nav-link" rel="bookmark" href="#Objects"> Objects </a>
    <a class="nav-link" rel="bookmark" href="#Resources"> Resources </a>
    <a class="nav-link" rel="bookmark" href="#NULL"> NULL </a>
    <a class="nav-link" rel="bookmark" href="#Callbacks_/_Callables"> Callbacks / Callables </a>
    <a class="nav-link" rel="bookmark" href="#Pseudo-types_and_variables_used_in_this_documentation"> Pseudo-types and variables used in this documentation </a>
    <a class="nav-link" rel="bookmark" href="#Type_Juggling"> Type Juggling </a>
    <a class="nav-link" rel="bookmark" href="#Variables"> Variables </a>
    <a class="nav-link" rel="bookmark" href="#Variable_Basics"> Variable Basics </a>
    <a class="nav-link" rel="bookmark" href="#Predefined_Variable"> Predefined Variable </a>
    <a class="nav-link" rel="bookmark" href="#Variable_scope"> Variable scope </a>
    <a class="nav-link" rel="bookmark" href="#Variable_variables"> Variable variables </a>
    <a class="nav-link" rel="bookmark" href="#Variables_From_External_Sources"> Variables From External Sources </a>
    <a class="nav-link" rel="bookmark" href="#Constants"> Constants </a>
    <a class="nav-link" rel="bookmark" href="#Syntax"> Syntax </a>
    <a class="nav-link" rel="bookmark" href="#Magic_constants"> Magic constants </a>
    <a class="nav-link" rel="bookmark" href="#Expressions"> Expressions </a>
    <a class="nav-link" rel="bookmark" href="#Expression"> Expression </a>
    <a class="nav-link" rel="bookmark" href="#Operators"> Operators </a>
    <a class="nav-link" rel="bookmark" href="#Operator_Precedence"> Operator Precedence </a>
    <a class="nav-link" rel="bookmark" href="#Arithmetic_Operators"> Arithmetic Operators </a>
    <a class="nav-link" rel="bookmark" href="#Assignment_Operators"> Assignment Operators </a>
    <a class="nav-link" rel="bookmark" href="#Bitwise_Operators"> Bitwise Operators </a>
    <a class="nav-link" rel="bookmark" href="#Comparison_Operators"> Comparison Operators </a>
    <a class="nav-link" rel="bookmark" href="#Error_Control_Operators"> Error Control Operators </a>
    <a class="nav-link" rel="bookmark" href="#Execution_Operators"> Execution Operators </a>
    <a class="nav-link" rel="bookmark" href="#Incrementing/Decrementing_Operators"> Incrementing/Decrementing Operators </a>
    <a class="nav-link" rel="bookmark" href="#Logical_Operators"> Logical Operators </a>
    <a class="nav-link" rel="bookmark" href="#String_Operators"> String Operators </a>
    <a class="nav-link" rel="bookmark" href="#Array_Operators"> Array Operators </a>
    <a class="nav-link" rel="bookmark" href="#Type_Operators"> Type Operators </a>
    <a class="nav-link" rel="bookmark" href="#Control_Structures"> Control Structures </a>
    <a class="nav-link" rel="bookmark" href="#Control_Structures_Introduction"> Control Structures Introduction </a>
    <a class="nav-link" rel="bookmark" href="#if"> if </a>
    <a class="nav-link" rel="bookmark" href="#else"> else </a>
    <a class="nav-link" rel="bookmark" href="#elseif/else_if"> elseif/else if </a>
    <a class="nav-link" rel="bookmark" href="#Alternative_syntax_for_control_structures"> Alternative syntax for control structures </a>
    <a class="nav-link" rel="bookmark" href="#while"> while </a>
    <a class="nav-link" rel="bookmark" href="#do-while"> do-while </a>
    <a class="nav-link" rel="bookmark" href="#for"> for </a>
    <a class="nav-link" rel="bookmark" href="#foreach"> foreach </a>
    <a class="nav-link" rel="bookmark" href="#break"> break </a>
    <a class="nav-link" rel="bookmark" href="#continue"> continue </a>
    <a class="nav-link" rel="bookmark" href="#switch"> switch </a>
    <a class="nav-link" rel="bookmark" href="#declare"> declare </a>
    <a class="nav-link" rel="bookmark" href="#return"> return </a>
    <a class="nav-link" rel="bookmark" href="#require"> require </a>
    <a class="nav-link" rel="bookmark" href="#include"> include </a>
    <a class="nav-link" rel="bookmark" href="#require_once"> require_once </a>
    <a class="nav-link" rel="bookmark" href="#include_once"> include_once </a>
    <a class="nav-link" rel="bookmark" href="#goto"> goto </a>
    <a class="nav-link" rel="bookmark" href="#Functions"> Functions </a>
    <a class="nav-link" rel="bookmark" href="#User-defined_functions"> User-defined functions </a>
    <a class="nav-link" rel="bookmark" href="#Function_arguments"> Function arguments </a>
    <a class="nav-link" rel="bookmark" href="#Returning_values"> Returning values </a>
    <a class="nav-link" rel="bookmark" href="#Variable_functions"> Variable functions </a>
    <a class="nav-link" rel="bookmark" href="#bookmark_(built-in)_functions"> bookmark (built-in) functions </a>
    <a class="nav-link" rel="bookmark" href="#Anonymous_functions"> Anonymous functions </a>
    <a class="nav-link" rel="bookmark" href="#Classes_And_Objects"> Classes and Objects </a>
    <a class="nav-link" rel="bookmark" href="#Control_Structures_Introduction"> Control Structures Introduction </a>
    <a class="nav-link" rel="bookmark" href="#The_Basics"> The Basics </a>
    <a class="nav-link" rel="bookmark" href="#Properties"> Properties </a>
    <a class="nav-link" rel="bookmark" href="#Class_Constants"> Class Constants </a>
    <a class="nav-link" rel="bookmark" href="#Autoloading_Classes"> Autoloading Classes </a>
    <a class="nav-link" rel="bookmark" href="#Constructors_and_Destructors"> Constructors and Destructors </a>
    <a class="nav-link" rel="bookmark" href="#Visibility"> Visibility </a>
    <a class="nav-link" rel="bookmark" href="#Object_Inheritance"> Object Inheritance </a>
    <a class="nav-link" rel="bookmark" href="#Scope_Resolution_Operator_(::)"> Scope Resolution Operator (::) </a>
    <a class="nav-link" rel="bookmark" href="#Static_Keyword"> Static Keyword </a>
    <a class="nav-link" rel="bookmark" href="#Class_Abstraction"> Class Abstraction </a>
    <a class="nav-link" rel="bookmark" href="#Object_Interfaces"> Object Interfaces </a>
    <a class="nav-link" rel="bookmark" href="#Traits"> Traits </a>
    <a class="nav-link" rel="bookmark" href="#Anonymous_classes"> Anonymous classes </a>
    <a class="nav-link" rel="bookmark" href="#Overloading"> Overloading </a>
    <a class="nav-link" rel="bookmark" href="#Object_Iteration"> Object Iteration </a>
    <a class="nav-link" rel="bookmark" href="#Magic_Methods"> Magic Methods </a>
    <a class="nav-link" rel="bookmark" href="#Final_Keyword"> Final Keyword </a>
    <a class="nav-link" rel="bookmark" href="#Object_Cloning"> Object Cloning </a>
    <a class="nav-link" rel="bookmark" href="#Comparing_Objects"> Comparing Objects </a>
    <a class="nav-link" rel="bookmark" href="#Type_Hinting"> Type Hinting </a>
    <a class="nav-link" rel="bookmark" href="#Late_Static_Bindings"> Late Static Bindings </a>
    <a class="nav-link" rel="bookmark" href="#Objects_and_references"> Objects and references </a>
    <a class="nav-link" rel="bookmark" href="#Object_Serialization"> Object Serialization </a>
    <a class="nav-link" rel="bookmark" href="#OOP_Changelog"> OOP Changelog </a>
    <a class="nav-link" rel="bookmark" href="#Namespaces"> Namespaces </a>
    <a class="nav-link" rel="bookmark" href="#Namespaces_overview"> Namespaces overview </a>
    <a class="nav-link" rel="bookmark" href="#Defining_namespaces"> Defining namespaces </a>
    <a class="nav-link" rel="bookmark" href="#Declaring_sub-namespaces"> Declaring sub-namespaces </a>
    <a class="nav-link" rel="bookmark" href="#Defining_multiple_namespaces_in_the_same_file"> Defining multiple namespaces in the same file </a>
    <a class="nav-link" rel="bookmark" href="#Using_namespaces:_Basics"> Using namespaces: Basics </a>
    <a class="nav-link" rel="bookmark" href="#Namespaces_and_dynamic_language_features"> Namespaces and dynamic language features </a>
    <a class="nav-link" rel="bookmark" href="#namespace_keyword_and___NAMESPACE___constant"> namespace keyword and __NAMESPACE__ constant </a>
    <a class="nav-link" rel="bookmark" href="#Using_namespaces:_Aliasing/Importing"> Using namespaces: Aliasing/Importing </a>
    <a class="nav-link" rel="bookmark" href="#Global_space"> Global space </a>
    <a class="nav-link" rel="bookmark" href="#Using_namespaces:_fallback_to_global_function/constant"> Using namespaces: fallback to global function/constant </a>
    <a class="nav-link" rel="bookmark" href="#Name_resolution_rules"> Name resolution rules </a>
    <a class="nav-link" rel="bookmark" href="#FAQ:_things_you_need_to_know_about_namespaces"> FAQ: things you need to know about namespaces </a>
    <a class="nav-link" rel="bookmark" href="#Errors"> Errors </a>
    <a class="nav-link" rel="bookmark" href="#Errors_Basics"> Errors Basics </a>
    <a class="nav-link" rel="bookmark" href="#Errors_in_PHP_7"> Errors in PHP 7 </a>
    <a class="nav-link" rel="bookmark" href="#Exceptions"> Exceptions </a>
    <a class="nav-link" rel="bookmark" href="#Extending_Exceptions"> Extending Exceptions </a>
    <a class="nav-link" rel="bookmark" href="#Generators"> Generators </a>
    <a class="nav-link" rel="bookmark" href="#Generators_overview"> Generators overview </a>
    <a class="nav-link" rel="bookmark" href="#Generator_syntax"> Generator syntax </a>
    <a class="nav-link" rel="bookmark" href="#Comparing_generators_with_Iterator_objects"> Comparing generators with Iterator objects </a>
    <a class="nav-link" rel="bookmark" href="#References_Explained"> References Explained </a>
    <a class="nav-link" rel="bookmark" href="#What_References_Are"> What References Are </a>
    <a class="nav-link" rel="bookmark" href="#What_References_Do"> What References Do </a>
    <a class="nav-link" rel="bookmark" href="#What_References_Are_Not"> What References Are Not </a>
    <a class="nav-link" rel="bookmark" href="#Passing_by_Reference"> Passing by Reference </a>
    <a class="nav-link" rel="bookmark" href="#Returning_References"> Returning References </a>
    <a class="nav-link" rel="bookmark" href="#Unsetting_References"> Unsetting References </a>
    <a class="nav-link" rel="bookmark" href="#Spotting_References"> Spotting References </a>
    <a class="nav-link" rel="bookmark" href="#Predefined_Variables"> Predefined Variables </a>
    <a class="nav-link" rel="bookmark" href="#Superglobals_—_Superglobals_are_built-in_variables_that_are_always_available_in_all_scopes"> Superglobals — Superglobals are built-in variables that are always available in all scopes </a>
    <a class="nav-link" rel="bookmark" href="#$GLOBALS_—_References_all_variables_available_in_global_scope"> $GLOBALS — References all variables available in global scope </a>
    <a class="nav-link" rel="bookmark" href="#$_SERVER_—_Server_and_execution_environment_information"> $_SERVER — Server and execution environment information </a>
    <a class="nav-link" rel="bookmark" href="#$_GET_—_HTTP_GET_variables"> $_GET — HTTP GET variables </a>
    <a class="nav-link" rel="bookmark" href="#$_POST_—_HTTP_POST_variables"> $_POST — HTTP POST variables </a>
    <a class="nav-link" rel="bookmark" href="#$_FILES_—_HTTP_File_Upload_variables"> $_FILES — HTTP File Upload variables </a>
    <a class="nav-link" rel="bookmark" href="#$_REQUEST_—_HTTP_Request_variables"> $_REQUEST — HTTP Request variables </a>
    <a class="nav-link" rel="bookmark" href="#$_SESSION_—_Session_variables"> $_SESSION — Session variables </a>
    <a class="nav-link" rel="bookmark" href="#$_ENV_—_Environment_variables"> $_ENV — Environment variables </a>
    <a class="nav-link" rel="bookmark" href="#$_COOKIE_—_HTTP_Cookies"> $_COOKIE — HTTP Cookies </a>
    <a class="nav-link" rel="bookmark" href="#$php_errormsg_—_The_previous_error_message"> $php_errormsg — The previous error message </a>
    <a class="nav-link" rel="bookmark" href="#$HTTP_RAW_POST_DATA_—_Raw_POST_data"> $HTTP_RAW_POST_DATA — Raw POST data </a>
    <a class="nav-link" rel="bookmark" href="#$http_response_header_—_HTTP_response_headers"> $http_response_header — HTTP response headers </a>
    <a class="nav-link" rel="bookmark" href="#$argc_—_The_number_of_arguments_passed_to_script"> $argc — The number of arguments passed to script </a>
    <a class="nav-link" rel="bookmark" href="#$argv_—_Array_of_arguments_passed_to_script"> $argv — Array of arguments passed to script </a>
    <a class="nav-link" rel="bookmark" href="#Predefined_Exceptions"> Predefined Exceptions </a>
    <a class="nav-link" rel="bookmark" href="#Exception"> Exception </a>
    <a class="nav-link" rel="bookmark" href="#ErrorException"> ErrorException </a>
    <a class="nav-link" rel="bookmark" href="#Error"> Error </a>
    <a class="nav-link" rel="bookmark" href="#ArgumentCountError"> ArgumentCountError </a>
    <a class="nav-link" rel="bookmark" href="#ArithmeticError"> ArithmeticError </a>
    <a class="nav-link" rel="bookmark" href="#AssertionError"> AssertionError </a>
    <a class="nav-link" rel="bookmark" href="#DivisionByZeroError"> DivisionByZeroError </a>
    <a class="nav-link" rel="bookmark" href="#CompileError"> CompileError </a>
    <a class="nav-link" rel="bookmark" href="#ParseError"> ParseError </a>
    <a class="nav-link" rel="bookmark" href="#TypeError"> TypeError </a>
    <a class="nav-link" rel="bookmark" href="#Predefined_Interfaces_and_Classes"> Predefined Interfaces and Classes </a>
    <a class="nav-link" rel="bookmark" href="#Traversable_—_The_Traversable_interface"> Traversable — The Traversable interface </a>
    <a class="nav-link" rel="bookmark" href="#Iterator_—_The_Iterator_interface"> Iterator — The Iterator interface </a>
    <a class="nav-link" rel="bookmark" href="#IteratorAggregate_—_The_IteratorAggregate_interface"> IteratorAggregate — The IteratorAggregate interface </a>
    <a class="nav-link" rel="bookmark" href="#Throwable"> Throwable </a>
    <a class="nav-link" rel="bookmark" href="#ArrayAccess_—_The_ArrayAccess_interface"> ArrayAccess — The ArrayAccess interface </a>
    <a class="nav-link" rel="bookmark" href="#Serializable_—_The_Serializable_interface"> Serializable — The Serializable interface </a>
    <a class="nav-link" rel="bookmark" href="#Closure_—_The_Closure_class"> Closure — The Closure class </a>
    <a class="nav-link" rel="bookmark" href="#Generator_—_The_Generator_class"> Generator — The Generator class </a>
    <a class="nav-link" rel="bookmark" href="#Context_options_and_parameters"> Context options and parameters </a>
    <a class="nav-link" rel="bookmark" href="#Socket_context_options_—_Socket_context_option_listing"> Socket context options — Socket context option listing </a>
    <a class="nav-link" rel="bookmark" href="#HTTP_context_options_—_HTTP_context_option_listing"> HTTP context options — HTTP context option listing </a>
    <a class="nav-link" rel="bookmark" href="#FTP_context_options_—_FTP_context_option_listing"> FTP context options — FTP context option listing </a>
    <a class="nav-link" rel="bookmark" href="#SSL_context_options_—_SSL_context_option_listing"> SSL context options — SSL context option listing </a>
    <a class="nav-link" rel="bookmark" href="#CURL_context_options_—_CURL_context_option_listing"> CURL context options — CURL context option listing </a>
    <a class="nav-link" rel="bookmark" href="#Phar_context_options_—_Phar_context_option_listing"> Phar context options — Phar context option listing </a>
    <a class="nav-link" rel="bookmark" href="#MongoDB_context_options_—_MongoDB_context_option_listing"> MongoDB context options — MongoDB context option listing </a>
    <a class="nav-link" rel="bookmark" href="#Context_parameters_—_Context_parameter_listing"> Context parameters — Context parameter listing </a>
    <a class="nav-link" rel="bookmark" href="#Zip_context_options_—_Zip_context_option_listing"> Zip context options — Zip context option listing </a>
    <a class="nav-link" rel="bookmark" href="#Supported_Protocols_and_Wrappers"> Supported Protocols and Wrappers </a>
    <a class="nav-link" rel="bookmark" href="#file://_—_Accessing_local_filesystem"> file:// — Accessing local filesystem </a>
    <a class="nav-link" rel="bookmark" href="#http://_—_Accessing_HTTP(s)_URLs"> http:// — Accessing HTTP(s) URLs </a>
    <a class="nav-link" rel="bookmark" href="#ftp://_—_Accessing_FTP(s)_URLs"> ftp:// — Accessing FTP(s) URLs </a>
    <a class="nav-link" rel="bookmark" href="#php://_—_Accessing_various_I/O_streams"> php:// — Accessing various I/O streams </a>
    <a class="nav-link" rel="bookmark" href="#zlib://_—_Compression_Streams"> zlib:// — Compression Streams </a>
    <a class="nav-link" rel="bookmark" href="#data://_—_Data_(RFC_2397)"> data:// — Data (RFC 2397) </a>
    <a class="nav-link" rel="bookmark" href="#glob://_—_Find_pathnames_matching_pattern"> glob:// — Find pathnames matching pattern </a>
    <a class="nav-link" rel="bookmark" href="#phar://_—_PHP_Archive"> phar:// — PHP Archive </a>
    <a class="nav-link" rel="bookmark" href="#ssh2://_—_Secure_Shell_2"> ssh2:// — Secure Shell 2 </a>
    <a class="nav-link" rel="bookmark" href="#rar://_—_RAR"> rar:// — RAR </a>
    <a class="nav-link" rel="bookmark" href="#ogg://_—_Audio_streams"> ogg:// — Audio streams </a>
    <a class="nav-link" rel="bookmark" href="#expect://_—_Process_Interaction_Streams"> expect:// — Process Interaction Streams </a>
  </nav>





  <main id="main-doc">


    <h1 id="Basic_syntax"> Basic syntax </h1>
    <section class="main-section" id="PHP_tags">
      <header>PHP tags</header>
      <p>When PHP parses a file, it looks for opening and closing tags, which are
        &lt;?php and ?&gt; which tell PHP to start and stop interpreting the code
        between them. Parsing in this manner allows PHP to be embedded in all sorts
        of different documents, as everything outside of a pair of opening and closing
        tags is ignored by the PHP parser.
      </p>
      <p class="note-comment"> I would like to stress out that the opening tag is
        "&lt;?php[whitespace]", not just "&lt;?php".
      </p>
      <p>If a file is pure PHP code, it is preferable to omit the PHP closing tag
        at the end of the file. This prevents accidental whitespace or new lines
        being added after the PHP closing tag, which may cause unwanted effects because
        PHP will start output buffering when there is no intention from the programmer
        to send any output at that point in the script.
      </p>
      <code>

        &lt;?php<br>
        echo "Hello world";<br>

        // ... more code<br>

        echo "Last statement";<br>

        // the script ends here with no PHP closing tag<br>

      </code>
    </section>


    <section class="main-section" id="Escaping_from_HTML">
      <header>Escaping from HTML</header>
      <p>
        Everything outside of a pair of opening and closing tags is ignored by the PHP parser which allows PHP files to have mixed content. This allows PHP to be embedded in HTML documents, for example to create templates.
      </p>
      <code>
        &lt;p&gt;This is going to be ignored by PHP and displayed by the browser.&lt;/p&gt;
        &lt;?php echo 'While this is going to be parsed.'; ?&gt;
        &lt;p&gt;This will also be ignored by PHP and displayed by the browser.&lt;/p&gt;
      </code>
      <p>
        This works as expected, because when the PHP interpreter hits the ?&gt; closing tags, it simply starts outputting whatever it finds (except for an immediately following newline - see instruction separation) until it hits another opening tag
        unless in the middle of a conditional statement in which case the interpreter will determine the outcome of the conditional before making a decision of what to skip over. See the next example.
      </p>


      Using structures with conditions

      <h2>Example #1 Advanced escaping using conditions</h2>
      <code>
        &lt;?php if ($expression == true): ?&gt;<br>
        This will show if the expression is true.<br>
        &lt;?php else: ?&gt;<br>
        Otherwise this will show.<br>
        &lt;?php endif; ?&gt;<br>
      </code>
      <p>
        In this example PHP will skip the blocks where the condition is not met, even though they are outside of the PHP open/close tags; PHP skips them according to the condition since the PHP interpreter will jump over blocks contained within a
        condition that is not met.
      </p>
      <p>
        For outputting large blocks of text, dropping out of PHP parsing mode is generally more efficient than sending all of the text through echo or print.
      </p>
      <p>
        In PHP 5, there are up to five different pairs of opening and closing tags available in PHP, depending on how PHP is configured. Two of these, &lt;?php ?&gt; and &lt;script language="php"&gt; &lt;/script&gt;, are always available. There is also
        the short echo tag &lt;?= ?&gt;, which is always available in PHP 5.4.0 and later.
      </p>
      <p>
        The other two are short tags and ASP style tags. As such, while some people find short tags and ASP style tags convenient, they are less portable, and generally not recommended.
      </p>

      <ul class="note-comment">
        <li>
          Also note that if you are embedding PHP within XML or XHTML you will need to use the &lt;?php ?&gt; tags to remain compliant with standards.
        </li>
      </ul>
      <p>
        PHP 7 removes support for ASP tags and &lt;script language="php"&gt; tags. As such, we recommend only using &lt;?php ?&gt; and &lt;?= ?&gt; when writing PHP code to maximise compatibility.
      </p>
      <h2>Example #2 PHP Opening and Closing Tags</h2>
      <code>
        <ol>
          <li>
            &lt;?php echo 'if you want to serve PHP code in XHTML or XML documents,
            use these tags'; ?&gt;
          </li>
          <li>
            You can use the short echo tag to &lt;?= 'print this string' ?&gt;.
            It's always enabled in PHP 5.4.0 and later, and is equivalent to
            &lt; ?php echo 'print this string' ?&gt;.
          </li>
          <li>

            &lt;? echo 'this code is within short tags, but will only work '.
            'if short_open_tag is enabled'; ?&gt;
          </li>
          <li>

            &lt;script language="php"&gt;
            echo 'some editors (like FrontPage) don\'t
            like processing instructions within these tags';
            &lt;/script&gt;
            This syntax is removed in PHP 7.0.0.
          </li>
          <li>

            &lt;% echo 'You may optionally use ASP-style tags'; %&gt;
            Code within these tags &lt;%= $variable; %&gt; is a shortcut for this code
            &lt;% echo $variable; %&gt;
            Both of these syntaxes are removed in PHP 7.0.0.
          </li>
        </ol>
      </code>
      <p>
        Short tags (example three) are only available when they are enabled via the
        short_open_tag php.ini configuration file directive, or if PHP was configured
        with the --enable-short-tags option.
      </p>
      <p>
        ASP style tags (example five) are only available when they are enabled via
        the asp_tags php.ini configuration file directive, and have been removed in
        PHP 7.0.0.
      </p>
      <ul class="note-comment">
        <li>

          Using short tags should be avoided when developing applications or
          libraries that are meant for redistribution, or deployment on PHP servers
          which are not under your control, because short tags may not be supported
          on the target server. For portable, redistributable code, be sure not to use short tags.

        </li>
        <li>

          In PHP 5.2 and earlier, the parser does not allow the &lt;?php opening tag
          to be the only thing in a file. This is allowed as of PHP 5.3 provided there
          are one or more whitespace characters after the opening tag.
        </li>
        <li>


          Starting with PHP 5.4, short echo tag &lt;?= is always recognized and valid,
          regardless of the short_open_tag setting.
        </li>
      </ul>
    </section>


    <section class="main-section" id="Instruction_separation">
      <header>Instruction separation</header>
      <p>
        As in C or Perl, PHP requires instructions to be terminated with a semicolon
        at the end of each statement. The closing tag of a block of PHP code
        automatically implies a semicolon; you do not need to have a semicolon
        terminating the last line of a PHP block. The closing tag for the block
        will include the immediately trailing newline if one is present.
      </p>
      <code>
        &lt;?php<br>
        echo 'This is a test';<br>
        ?&gt;<br>

        &lt;?php echo 'This is a test' ?&gt;<br>

        &lt;?php echo 'We omitted the last closing tag';<br>
      </code>

      <p class="note-comment">
        The closing tag of a PHP block at the end of a file is optional, and in
        some cases omitting it is helpful when using include or require, so unwanted
        whitespace will not occur at the end of files, and you will still be able
        to add headers to the response later. It is also handy if you use output
        buffering, and would not like to see added unwanted whitespace at the end
        of the parts generated by the included files.
      </p>
    </section>


    <section class="main-section" id="Comments">
      <header>Comments</header>
      <p>PHP supports 'C', 'C++' and Unix shell-style (Perl style) comments. For example:
        <code>
          &lt;?php
          echo 'This is a test'; // This is a one-line c++ style comment
          /* This is a multi line comment
          yet another line of comment */
          echo 'This is yet another test';
          echo 'One Final Test'; # This is a one-line shell-style comment
          ?&gt;
        </code>
        <p>
          The "one-line" comment styles only comment to the end of the line or the current block of PHP code, whichever comes first. This means that HTML code after // ... ?&gt; or # ... ?&gt; WILL be printed: ?&gt; breaks out of PHP mode and returns
          to HTML mode, and // or # cannot influence that. If the asp_tags configuration directive is enabled, it behaves the same with // %&gt; and # %&gt;. However, the &lt;/script&gt; tag doesn't break out of PHP mode in a one-line comment.
        </p>
        <code>
          &lt;h1&gt;This is an &lt;?php # echo 'simple';?&gt; example&lt;/h1&gt;
          &lt;p&gt;The header above will say 'This is an example'.&lt;/p&gt;
        </code>
        <p>
          'C' style comments end at the first */ encountered. Make sure you don't nest 'C' style comments. It is easy to make this mistake if you are trying to comment out a large block of code.
        </p>
        <code>
          &lt;?php
          /*
          echo 'This is a test'; /* This comment will cause a problem */
          */
          ?&gt;
        </code>
    </section>


    <h1 id="Types"> Types </h1>
    <section class="main-section" id="Types_Introduction">
      <header>Types Introduction</header>
      <p>
        PHP supports ten primitive types.
      </p>
      <p>
        Four scalar types:
      </p>
      <ul>
        <li>
          boolean
        </li>
        <li>
          integer
        </li>
        <li>
          float (floating-point number, aka double)
        </li>
        <li>
          string
        </li>
      </ul>

      <p>
        Four compound types:
      </p>
      <ul>
        <li>
          array
        </li>
        <li>
          object
        </li>
        <li>
          callable
        </li>
        <li>
          iterable
        </li>

      </ul>
      <p>
        And finally two special types:
      </p>
      <ul>
        <li>
          resource
        </li>
        <li>
          NULL
        </li>
      </ul>
      <p>
        This manual also introduces some pseudo-types for readability reasons:
      </p>
      <ul>
        <li>
          mixed
        </li>
        <li>
          number
        </li>
        <li>
          callback (aka callable)
        </li>
        <li>
          array|object
        </li>
        <li>
          void
        </li>
      </ul>
      <p>
        And the pseudo-variable $....
      </p>
      <p>
        Some references to the type "double" may remain in the manual.
        Consider double the same as float; the two names exist only for historic reasons.
      </p>

      <p>
        The type of a variable is not usually set by the programmer; rather,
        it is decided at runtime by PHP depending on the context in which that variable is used.
      </p>

      <p class="note-comment">
        To check the type and value of an expression, use the var_dump() function.

        To get a human-readable representation of a type for debugging, use the
        gettype() function. To check for a certain type, do not use gettype(),
        but rather the is_type functions. Some examples:
        <code>
          &lt;?php<br>
          $a_bool = TRUE; // a boolean<br>
          $a_str = "foo"; // a string<br>
          $a_str2 = 'foo'; // a string<br>
          $an_int = 12; // an integer<br>
          <br>
          echo gettype($a_bool); // prints out: boolean<br>
          echo gettype($a_str); // prints out: string<br>
          <br>
          // If this is an integer, increment it by four<br>
          if (is_int($an_int)) {<br>
          $an_int += 4;<br>
          }<br>
          <br>
          // If $a_bool is a string, print it out<br>
          // (does not print out anything)<br>
          if (is_string($a_bool)) {<br>
          echo "String: $a_bool";<br>
          }<br>
          ?&gt;<br>
        </code>

      </p>
      <p>
        To forcibly convert a variable to a certain type, either cast the variable or use the settype() function on it.
      </p>

      <p>

        Note that a variable may be evaluated with different values in certain situations, depending on what type it is at the time. For more information, see the section on Type Juggling. The type comparison tables may also be useful, as they show
        examples of various type-related comparisons.
      </p>
    </section>


    <section class="main-section" id="Booleans">
      <header>Booleans</header>

      <p>
        To specify a boolean literal, use the constants TRUE or FALSE. Both are case-insensitive.
      </p>
      <code>
        &lt;?php
        $foo = True; // assign the value TRUE to $foo
        ?&gt;
      </code>
      <p>
        Typically, the result of an operator which returns a boolean value is passed on to a control structure.
      </p>
      <code>
        &lt;?php<br>
        // == is an operator which tests<br>
        // equality and returns a boolean<br>
        if ($action == "show_version") {<br>
        echo "The version is 1.23";<br>
        }<br>
        <br>
        // this is not necessary...<br>
        if ($show_separators == TRUE) {<br>
        echo "&lt;hr&gt;\n";<br>
        }<br>
        <br>
        // ...because this can be used with exactly the same meaning:<br>
        if ($show_separators) {<br>
        echo "&lt;hr&gt;\n";<br>
        }<br>
        ?&gt;<br>
      </code>

      <h2>
        Converting to boolean
      </h2>
      <p>
        To explicitly convert a value to boolean, use the (bool) or (boolean) casts. However, in most cases the cast is unnecessary, since a value will be automatically converted if an operator, function or control structure requires a boolean
        argument.
      </p>

      <p>
        When converting to boolean, the following values are considered FALSE:
      </p>
      <ul>
        <li>
          the boolean FALSE itself
        </li>
        <li>

          the integer 0 (zero)
        </li>
        <li>
          the float 0.0 (zero)
        </li>
        <li>
          the empty string, and the string "0"
        </li>

        <li>
          an array with zero elements
        </li>
        <li>
          the special type NULL (including unset variables)
        </li>
        <li>
          SimpleXML objects created from empty tags
        </li>
      </ul>

      <p>
        Every other value is considered TRUE (including any resource and NAN).
      </p>
      <div class="note-comment">

        <h3>
          Warning
        </h3>
        -1 is considered TRUE, like any other non-zero (whether negative or positive) number!
      </div>
      <code>
        &lt;?php<br>
        var_dump((bool) ""); // bool(false)<br>
        var_dump((bool) 1); // bool(true)<br>
        var_dump((bool) -2); // bool(true)<br>
        var_dump((bool) "foo"); // bool(true)<br>
        var_dump((bool) 2.3e5); // bool(true)<br>
        var_dump((bool) array(12)); // bool(true)<br>
        var_dump((bool) array()); // bool(false)<br>
        var_dump((bool) "false"); // bool(true)<br>
        ?&gt; <br>
      </code>
    </section>


    <section class="main-section" id="Integers">
      <header>Integers</header>
      <p>
        An integer is a number of the set ℤ = {..., -2, -1, 0, 1, 2, ...}.
      </p>
      <p>
        Integers can be specified in decimal (base 10), hexadecimal (base 16), octal (base 8) or binary (base 2) notation. The negation operator can be used to denote a negative integer.
      </p>
      <p>
        Binary integer literals are available since PHP 5.4.0.
      </p>
      <p>
        To use octal notation, precede the number with a 0 (zero). To use hexadecimal notation precede the number with 0x. To use binary notation precede the number with 0b.
      </p>
      <p>
        Example #1 Integer literals
      </p>
      <code>
        &lt;?php<br>
        $a = 1234; // decimal number<br>
        $a = -123; // a negative number<br>
        $a = 0123; // octal number (equivalent to 83 decimal)<br>
        $a = 0x1A; // hexadecimal number (equivalent to 26 decimal)<br>
        $a = 0b11111111; // binary number (equivalent to 255 decimal)<br>
        ?&gt;<br>
      </code>
      <p>
        Formally, the structure for integer literals is:
      </p>

      decimal : [1-9][0-9]*
      | 0

      hexadecimal : 0[xX][0-9a-fA-F]+

      octal : 0[0-7]+

      binary : 0[bB][01]+

      integer : decimal
      | hexadecimal
      | octal
      | binary
      <p>
        The size of an integer is platform-dependent, although a maximum value of about two billion is the usual value (that's 32 bits signed). 64-bit platforms usually have a maximum value of about 9E18, except on Windows prior to PHP 7, where it
        was always 32 bit. PHP does not support unsigned integers. Integer size can be determined using the constant PHP_INT_SIZE, maximum value using the constant PHP_INT_MAX since PHP 5.0.5, and minimum value using the constant PHP_INT_MIN since
        PHP 7.0.0.
      </p>
      <div>

        <h3>
          Warning
        </h3>

        Prior to PHP 7, if an invalid digit was given in an octal integer (i.e. 8 or 9), the rest of the number was ignored. Since PHP 7, a parse error is emitted.
      </div>
      <h2>
        Integer overflow ¶
      </h2>
      <p>
        If PHP encounters a number beyond the bounds of the integer type, it will be interpreted as a float instead. Also, an operation which results in a number beyond the bounds of the integer type will return a float instead.
      </p>
      <p>
        Example #2 Integer overflow on a 32-bit system
      </p>
      <code>
        &lt;?php<br>
        $large_number = 2147483647;<br>
        var_dump($large_number); // int(2147483647)<br>
        <br>
        $large_number = 2147483648;<br>
        var_dump($large_number); // float(2147483648)<br>
        <br>
        $million = 1000000;<br>
        $large_number = 50000 * $million;<br>
        var_dump($large_number); // float(50000000000)<br>
        ?&gt;<br>
      </code>
      <p>
        Example #3 Integer overflow on a 64-bit system
      </p>
      <code>
        &lt;?php<br>
        $large_number = 9223372036854775807;<br>
        var_dump($large_number); // int(9223372036854775807)<br>
        <br>
        $large_number = 9223372036854775808;<br>
        var_dump($large_number); // float(9.2233720368548E+18)<br>
        <br>
        $million = 1000000;<br>
        $large_number = 50000000000000 * $million;<br>
        var_dump($large_number); // float(5.0E+19)<br>
        ?&gt;<br>
      </code>
      <p>
        There is no integer division operator in PHP. 1/2 yields the float 0.5. The value can be casted to an integer to round it towards zero, or the round() function provides finer control over rounding.
      </p>
      <code>
        &lt;?php<br>
        var_dump(25/7); // float(3.5714285714286)<br>
        var_dump((int) (25/7)); // int(3)<br>
        var_dump(round(25/7)); // float(4)<br>
        ?&gt;<br>
      </code>
      <h2>
        Converting to integer ¶
      </h2>
      <p>
        To explicitly convert a value to integer, use either the (int) or (integer) casts. However, in most cases the cast is not needed, since a value will be automatically converted if an operator, function or control structure requires an integer
        argument. A value can also be converted to integer with the intval() function.
      </p>
      <p>
        If a resource is converted to an integer, then the result will be the unique resource number assigned to the resource by PHP at runtime.
      </p>
      <p>
        FALSE will yield 0 (zero), and TRUE will yield 1 (one).
      </p>
      <p>
        When converting from float to integer, the number will be rounded towards zero.
      </p>
      <p>
        If the float is beyond the boundaries of integer (usually +/- 2.15e+9 = 2^31 on 32-bit platforms and +/- 9.22e+18 = 2^63 on 64-bit platforms other than Windows), the result is undefined, since the float doesn't have enough precision to give
        an exact integer result. No warning, not even a notice will be issued when this happens!
      </p>
      <p>
        Note:As of PHP 7.0.0, instead of being undefined and platform-dependent, NaN and Infinity will always be zero when cast to integer.
      </p>
      <div>
        <h3>
          Warning
        </h3>
        Never cast an unknown fraction to integer, as this can sometimes lead to unexpected results.
      </div>
      <code>
        &lt;?php<br>
        echo (int) ( (0.1+0.7) * 10 ); // echoes 7!<br>
        ?&gt;<br>
      </code>
      <p>
        NULL is always converted to zero (0).
      </p>
    </section>


    <section class="main-section" id="Floating_point_numbers">
      <header>Floating point numbers</header>
      Floating point numbers (also known as "floats", "doubles", or "real numbers") can be specified using any of the following syntaxes:
      <code>
        &lt;?php<br>
        $a = 1.234;<br>
        $b = 1.2e3;<br>
        $c = 7E-10;<br>
        ?&gt;<br>
      </code>
      <p>
        Formally:<br>

        LNUM [0-9]+<br>
        DNUM ([0-9]*[\.]{LNUM}) | ({LNUM}[\.][0-9]*)<br>
        EXPONENT_DNUM [+-]?(({LNUM} | {DNUM}) [eE][+-]? {LNUM})<br>
      </p>
      <p>
        The size of a float is platform-dependent, although a maximum of approximately 1.8e308 with a precision of roughly 14 decimal digits is a common value (the 64 bit IEEE format).
      </p>
      <p>
        Floating point numbers have limited precision. Although it depends on the system, PHP typically uses the IEEE 754 double precision format, which will give a maximum relative error due to rounding in the order of 1.11e-16. Non elementary
        arithmetic operations may give larger errors, and, of course, error propagation must be considered when several operations are compounded.
      </p>
      <p>
        Additionally, rational numbers that are exactly representable as floating point numbers in base 10, like 0.1 or 0.7, do not have an exact representation as floating point numbers in base 2, which is used internally, no matter the size of the
        mantissa. Hence, they cannot be converted into their internal binary counterparts without a small loss of precision. This can lead to confusing results: for example, floor((0.1+0.7)*10) will usually return 7 instead of the expected 8, since
        the internal representation will be something like 7.9999999999999991118....
      </p>
      <p>
        So never trust floating number results to the last digit, and do not compare floating point numbers directly for equality. If higher precision is necessary, the arbitrary precision math functions and gmp functions are available.
      </p>
      <p>
        For a "simple" explanation, see the » floating point guide that's also titled "Why don’t my numbers add up?"
      </p>
      <h2>
        Converting to float ¶
      </h2>
      <p>
        For information on converting strings to float, see String conversion to numbers. For values of other types, the conversion is performed by converting the value to integer first and then to float. See Converting to integer for more
        information. As of PHP 5, a notice is thrown if an object is converted to float.
      </p>
      <h2>
        Comparing floats ¶
      </h2>
      <p>
        As noted in the warning above, testing floating point values for equality is problematic, due to the way that they are represented internally. However, there are ways to make comparisons of floating point values that work around these
        limitations.
      </p>
      <p>
        To test floating point values for equality, an upper bound on the relative error due to rounding is used. This value is known as the machine epsilon, or unit roundoff, and is the smallest acceptable difference in calculations.
      </p>
      <p>
        $a and $b are equal to 5 digits of precision.
      </p>
      <code>
        &lt;?php<br>
        $a = 1.23456789;<br>
        $b = 1.23456780;<br>
        $epsilon = 0.00001;<br>
        <br>
        if(abs($a-$b) < $epsilon) {<br>
          echo "true";<br>
          }<br>
          ?&gt;<br>
      </code>
      <p>
        Some numeric operations can result in a value represented by the constant NAN. This result represents an undefined or unrepresentable value in floating-point calculations. Any loose or strict comparisons of this value against any other
        value, including itself, but except TRUE, will have a result of FALSE.
      </p>
      <p>
        Because NAN represents any number of different values, NAN should not be compared to other values, including itself, and instead should be checked for using is_nan().
      </p>
    </section>


    <section class="main-section" id="Strings">
      <header>Strings</header>
      <p>
        A string is series of characters, where a character is the same as a byte. This means that PHP only supports a 256-character set, and hence does not offer native Unicode support. See details of the string type.
      </p>
      <p>
        Note: As of PHP 7.0.0, there are no particular restrictions regarding the length of a string on 64-bit builds. On 32-bit builds and in earlier versions, a string can be as large as up to 2GB (2147483647 bytes maximum)
      </p>
      <h2>
        Syntax ¶
      </h2>
      <p>
        A string literal can be specified in four different ways:
      </p>
      <h2>
        Single quoted ¶
      </h2>
      <p>
        The simplest way to specify a string is to enclose it in single quotes (the character ').
      </p>
      <p>
        To specify a literal single quote, escape it with a backslash (\). To specify a literal backslash, double it (\\). All other instances of backslash will be treated as a literal backslash: this means that the other escape sequences you might
        be
        used to, such as \r or \n, will be output literally as specified rather than having any special meaning.
      </p>
      <p>
        Note: Unlike the double-quoted and heredoc syntaxes, variables and escape sequences for special characters will not be expanded when they occur in single quoted strings.
      </p>

      <code>
        &lt;?php<br>
        echo 'this is a simple string';<br>

        echo 'You can also have embedded newlines in<br>
        strings this way as it is<br>
        okay to do';<br>

        // Outputs: Arnold once said: "I'll be back"<br>
        echo 'Arnold once said: "I\'ll be back"';<br>

        // Outputs: You deleted C:\*.*?<br>
        echo 'You deleted C:\\*.*?';<br>

        // Outputs: You deleted C:\*.*?<br>
        echo 'You deleted C:\*.*?';<br>

        // Outputs: This will not expand: \n a newline<br>
        echo 'This will not expand: \n a newline';<br>

        // Outputs: Variables do not $expand $either<br>
        echo 'Variables do not $expand $either';<br>
        ?&gt;<br>
      </code>
      <h2>
        Double quoted ¶
      </h2>
      <p>
        If the string is enclosed in double-quotes ("), PHP will interpret the following escape sequences for special characters:
        Escaped characters Sequence Meaning
      </p>
      <code>
        \n linefeed (LF or 0x0A (10) in ASCII)<br>
        \r carriage return (CR or 0x0D (13) in ASCII)<br>
        \t horizontal tab (HT or 0x09 (9) in ASCII)<br>
        \v vertical tab (VT or 0x0B (11) in ASCII) (since PHP 5.2.5)<br>
        \e escape (ESC or 0x1B (27) in ASCII) (since PHP 5.4.4)<br>
        \f form feed (FF or 0x0C (12) in ASCII) (since PHP 5.2.5)<br>
        \\ backslash<br>
        \$ dollar sign<br>
        \" double-quote<br>
        \[0-7]{1,3} the sequence of characters matching the regular expression is a character in octal notation, which silently overflows to fit in a byte (e.g. "\400" === "\000")<br>
        \x[0-9A-Fa-f]{1,2} the sequence of characters matching the regular expression is a character in hexadecimal notation<br>
        \u{[0-9A-Fa-f]+} the sequence of characters matching the regular expression is a Unicode codepoint, which will be output to the string as that codepoint's UTF-8 representation (added in PHP 7.0.0)<br>
      </code>
      <p>
        As in single quoted strings, escaping any other character will result in the backslash being printed too. Before PHP 5.1.1, the backslash in \{$var} had not been printed.
      </p>
      <p>
        The most important feature of double-quoted strings is the fact that variable names will be expanded. See string parsing for details.
      </p>
      <h2>
        Heredoc ¶
      </h2>
      <p>
        A third way to delimit strings is the heredoc syntax: &lt;&lt;&lt;. After this operator, an identifier is provided, then a newline. The string itself follows, and then the same identifier again to close the quotation. The closing identifier
        must
        begin in the first column of the line. Also, the identifier must follow the same naming rules as any other label in PHP: it must contain only alphanumeric characters and underscores, and must start with a non-digit character or underscore.
        Warning It is very important to note that the line with the closing identifier must contain no other characters, except a semicolon (;). That means especially that the identifier may not be indented, and there may not be any spaces or tabs
        before or after the semicolon. It's also important to realize that the first character before the closing identifier must be a newline as defined by the local operating system. This is \n on UNIX systems, including macOS. The closing
        delimiter must also be followed by a newline. If this rule is broken and the closing identifier is not "clean" , it will not be considered a closing identifier, and PHP will continue looking for one. If a proper closing identifier is not
        found before the end of the current file, a parse error will result at the last line. Example #1 Invalid example </p> <code>
        &lt;?<br>
        php<br>
        class foo {<br>
        public $bar = &lt;&lt;&lt;EOT<br>
        bar<br>
        EOT;<br>
        }<br>
        // Identifier must not be indented<br>
        ?&gt;<br>
      </code>

      Example #2 Valid example
      <code>
        &lt;?php<br>
        class foo {<br>
        public $bar = &lt;&lt;&lt;EOT<br>
        bar<br>
        EOT;<br>
        }<br>
        ?&gt;<br>
      </code>
      <p>
        Heredocs can not be used for initializing class properties. Since PHP 5.3, this limitation is valid only for heredocs containing variables.
      </p>
      <p>
        Heredoc text behaves just like a double-quoted string, without the double quotes. This means that quotes in a heredoc do not need to be escaped, but the escape codes listed above can still be used. Variables are expanded, but the same
        care
        must be taken when expressing complex variables inside a heredoc as with strings.
      </p>
      <h2>
        Example #3 Heredoc string quoting example
      </h2>
      <code>
        &lt;?php<br>
        $str = &lt;&lt;&lt;EOD<br>
        Example of string<br>
        spanning multiple lines<br>
        using heredoc syntax.<br>
        EOD;<br>

        /* More complex example, with variables. */<br>
        class foo<br>
        {<br>
        var $foo;<br>
        var $bar;<br>

        function __construct()<br>
        {<br>
        $this->foo = 'Foo';<br>
        $this->bar = array('Bar1', 'Bar2', 'Bar3');<br>
        }<br>
        }<br>

        $foo = new foo();<br>
        $name = 'MyName';<br>

        echo &lt;&lt;&lt;EOT<br>
        My name is "$name". I am printing some $foo->foo.<br>
        Now, I am printing some {$foo->bar[1]}.<br>
        This should print a capital 'A': \x41<br>
        EOT;<br>
        ?&gt;<br>
      </code>
      <p>
        The above example will output:
      </p>
      <code>
        My name is "MyName". I am printing some Foo.<br>
        Now, I am printing some Bar2.<br>
        This should print a capital 'A': A<br>
      </code>
      <p>
        It is also possible to use the Heredoc syntax to pass data to function arguments:
      </p>
      <p>
        Example #4 Heredoc in arguments example
      </p>
      <code>
        &lt;?php<br>
        var_dump(array(&lt;&lt;&lt;EOD<br>
        foobar!<br>
        EOD<br>
        ));<br>
        ?&gt;<br>
      </code>
      <p>
        As of PHP 5.3.0, it's possible to initialize static variables and class properties/constants using the Heredoc syntax:
      </p>

      <p>
        Example #5 Using Heredoc to initialize static values
      </p>
      <code>
        &lt;?php<br>
        // Static variables<br>
        function foo()<br>
        {<br>
        static $bar = &lt;&lt;&lt;LABEL<br>
        Nothing in here...<br>
        LABEL;<br>
        }<br>

        // Class properties/constants<br>
        class foo<br>
        {<br>
        const BAR = &lt;&lt;&lt;FOOBAR<br>
        Constant example<br>
        FOOBAR;<br>

        public $baz = &lt;&lt;&lt;FOOBAR<br>
        Property example<br>
        FOOBAR;<br>
        }<br>
        ?&gt;<br>
      </code>
      <p>
        Starting with PHP 5.3.0, the opening Heredoc identifier may optionally be enclosed in double quotes:
      </p>
      <p>
        Example #6 Using double quotes in Heredoc
      </p>
      <code>
        &lt;?php<br>
        echo &lt;&lt;&lt;"FOOBAR" Hello World! FOOBAR; <br>
        ?&gt;<br>
      </code>
      <h2>
        Nowdoc ¶
      </h2>
      <p>
        Nowdocs are to single-quoted strings what heredocs are to double-quoted strings. A nowdoc is specified similarly to a heredoc, but no parsing is done inside a nowdoc. The
        construct is ideal for embedding PHP code or other large blocks of text without the need for escaping. It shares some features in common with the SGML &lt;![CDATA[ ]]&gt; construct, in that it declares a block of text which is not for
        parsing.
      </p>
      <p>
        A nowdoc is identified with the same &lt;&lt;&lt; sequence used for heredocs, but the identifier which follows is enclosed in single quotes, e.g. &lt;&lt;&lt;'EOT'. All the rules for heredoc identifiers also apply to nowdoc identifiers,
        especially those regarding the appearance of the closing identifier. Example #7 Nowdoc string quoting example
      </p>
      <code>
        &lt;?php<br>
        $str = &lt;&lt;&lt;'EOD' Example of string spanning multiple lines using nowdoc syntax. EOD; /* More complex example, with variables. */ class foo { public $foo; public $bar; function __construct() { $this->foo = 'Foo';<br>
        $this->bar = array('Bar1', 'Bar2', 'Bar3');<br>
        }<br>
        }<br>

        $foo = new foo();<br>
        $name = 'MyName';<br>

        echo &lt;&lt;&lt;'EOT' My name is "$name" . I am printing some $foo->foo.<br>
        Now, I am printing some {$foo->bar[1]}.<br>
        This should not print a capital 'A': \x41<br>
        EOT;<br>
        ?&gt;<br>
      </code>
      <p>
        The above example will output:
      </p>
      <code>
        My name is "$name". I am printing some $foo->foo.
        Now, I am printing some {$foo->bar[1]}.
        This should not print a capital 'A': \x41
      </code>
      <p>
        Example #8 Static data example
      </p>
      <code>
        &lt;?php<br>
        class foo {<br>
        public $bar = &lt;&lt;&lt;'EOT' bar EOT; } <br>
        ?&gt; <br>
      </code>
      <p>
        Note: Nowdoc support was added in PHP 5.3.0. Variable parsing ¶ When a string is specified in double quotes or with heredoc, variables are parsed within it. There are two types of syntax: a
        simple one and a complex one. The simple syntax is the most common and convenient. It provides a way to embed a variable, an array value, or an object property in a string with a minimum of effort. The complex syntax can be recognised by
        the curly braces surrounding the expression. Simple syntax If a dollar sign ($) is encountered, the parser will greedily take as many tokens as possible to form a valid variable name. Enclose the variable name in curly braces to
        explicitly specify the end of the name.
      </p>
      <code>
        &lt;?php<br>
        $juice = "apple";<br>

        echo "He drank some $juice juice.".PHP_EOL;<br>
        // Invalid. "s" is a valid character for a variable name, but the variable is $juice.<br>
        echo "He drank some juice made of $juices.";<br>
        // Valid. Explicitly specify the end of the variable name by enclosing it in braces:<br>
        echo "He drank some juice made of ${juice}s.";<br>
        ?&gt;<br>
      </code>
      <p>
        The above example will output:
      </p>
      <code>
        He drank some apple juice.<br>
        He drank some juice made of .<br>
        He drank some juice made of apples.<br>
      </code>
      <p>
        Similarly, an array index or an object property can be parsed. With array indices, the closing square bracket (]) marks the end of the index. The same rules apply to object properties as to simple variables.
      </p>
      <p>
        Example #9 Simple syntax example
      </p>
      <code>
        &lt;?php<br>
        $juices = array("apple", "orange", "koolaid1" => "purple");<br>
        <br>
        echo "He drank some $juices[0] juice.".PHP_EOL;<br>
        echo "He drank some $juices[1] juice.".PHP_EOL;<br>
        echo "He drank some $juices[koolaid1] juice.".PHP_EOL;<br>
        <br>
        class people {<br>
        public $john = "John Smith";<br>
        public $jane = "Jane Smith";<br>
        public $robert = "Robert Paulsen";<br>
        <br>
        public $smith = "Smith";<br>
        }<br>
        <br>
        $people = new people();<br>
        <br>
        echo "$people->john drank some $juices[0] juice.".PHP_EOL;<br>
        echo "$people->john then said hello to $people->jane.".PHP_EOL;<br>
        echo "$people->john's wife greeted $people->robert.".PHP_EOL;<br>
        echo "$people->robert greeted the two $people->smiths."; // Won't work<br>
        ?&gt;<br>
      </code>
      <p>
        The above example will output:
      </p>
      <code>
        He drank some apple juice.
        He drank some orange juice.
        He drank some purple juice.
        John Smith drank some apple juice.
        John Smith then said hello to Jane Smith.
        John Smith's wife greeted Robert Paulsen.
        Robert Paulsen greeted the two .
      </code>
      <p>
        As of PHP 7.1.0 also negative numeric indices are supported.
      </p>
      <p>
        Example #10 Negative numeric indices
      </p>
      <code>
        &lt;?php<br>
        $string = 'string';<br>
        echo "The character at index -2 is $string[-2].", PHP_EOL;<br>
        $string[-3] = 'o';<br>
        echo "Changing the character at index -3 to o gives $string.", PHP_EOL;<br>
        ?&gt;<br>
      </code>
      <p>
        The above example will output:
      </p>
      <code>
        The character at index -2 is n.<br>
        Changing the character at index -3 to o gives strong.<br>
      </code>
      <p>
        For anything more complex, you should use the complex syntax.
        Complex (curly) syntax
      </p>
      <p>
        This isn't called complex because the syntax is complex, but because it allows for the use of complex expressions.
      </p>
      <p>
        Any scalar variable, array element or object property with a string representation can be included via this syntax. Simply write the expression the same way as it would appear outside the string, and then wrap it in { and }. Since { can
        not
        be escaped, this syntax will only be recognised when the $ immediately follows the {. Use {\$ to get a literal {$. Some examples to make it clear:
      </p>
      <code>
        &lt;?php<br>
        // Show all errors<br>
        error_reporting(E_ALL);<br>

        $great = 'fantastic';<br>

        // Won't work, outputs: This is { fantastic}<br>
        echo "This is { $great}";<br>

        // Works, outputs: This is fantastic<br>
        echo "This is {$great}";<br>

        // Works<br>
        echo "This square is {$square->width}00 centimeters broad.";<br>


        // Works, quoted keys only work using the curly brace syntax<br>
        echo "This works: {$arr['key']}";<br>


        // Works<br>
        echo "This works: {$arr[4][3]}";<br>

        // This is wrong for the same reason as $foo[bar] is wrong outside a string.<br>
        // In other words, it will still work, but only because PHP first looks for a<br>
        // constant named foo; an error of level E_NOTICE (undefined constant) will be<br>
        // thrown.<br>
        echo "This is wrong: {$arr[foo][3]}";<br>

        // Works. When using multi-dimensional arrays, always use braces around arrays<br>
        // when inside of strings<br>
        echo "This works: {$arr['foo'][3]}";<br>

        // Works.<br>
        echo "This works: " . $arr['foo'][3];<br>

        echo "This works too: {$obj->values[3]->name}";<br>

        echo "This is the value of the var named $name: {${$name}}";<br>

        echo "This is the value of the var named by the return value of getName(): {${getName()}}";<br>

        echo "This is the value of the var named by the return value of \$object->getName(): {${$object->getName()}}";<br>

        // Won't work, outputs: This is the return value of getName(): {getName()}<br>
        echo "This is the return value of getName(): {getName()}";<br>
        ?&gt;<br>
      </code>
      <p>
        It is also possible to access class properties using variables within strings using this syntax.
      </p>
      <code>
        &lt;?php<br>
        class foo {<br>
        var $bar = 'I am bar.';<br>
        }<br>

        $foo = new foo();<br>
        $bar = 'bar';<br>
        $baz = array('foo', 'bar', 'baz', 'quux');<br>
        echo "{$foo->$bar}\n";<br>
        echo "{$foo->{$baz[1]}}\n";<br>
        ?&gt;<br>
      </code>
      <p>
        The above example will output:
      </p>
      <code>
        I am bar.<br>
        I am bar.<br>
      </code>
      <p>
        Note:

        Functions, method calls, static class variables, and class constants inside {$} work since PHP 5. However, the value accessed will be interpreted as the name of a variable in the scope in which the string is defined. Using single curly
        braces ({}) will not work for accessing the return values of functions or methods or the values of class constants or static class variables.

      </p>
      <code>
        &lt;?php<br>
        // Show all errors.<br>
        error_reporting(E_ALL);<br>

        class beers {<br>
        const softdrink = 'rootbeer';<br>
        public static $ale = 'ipa';<br>
        }<br>

        $rootbeer = 'A & W';<br>
        $ipa = 'Alexander Keith\'s';<br>

        // This works; outputs: I'd like an A & W<br>
        echo "I'd like an {${beers::softdrink}}\n";<br>

        // This works too; outputs: I'd like an Alexander Keith's<br>
        echo "I'd like an {${beers::$ale}}\n";<br>
        ?&gt;<br>
      </code>
      <h2>
        String access and modification by character ¶
      </h2>
      <p>
        Characters within strings may be accessed and modified by specifying the zero-based offset of the desired character after the string using square array brackets, as in $str[42]. Think of a string as an array of characters for this purpose.
        The functions substr() and substr_replace() can be used when you want to extract or replace more than 1 character.
      </p>
      <p>
        Note: As of PHP 7.1.0, negative string offsets are also supported. These specify the offset from the end of the string. Formerly, negative offsets emitted E_NOTICE for reading (yielding an empty string) and E_WARNING for writing (leaving the
        string untouched).
      </p>
      <p>
        Note: Strings may also be accessed using braces, as in $str{42}, for the same purpose.
      </p>
      <div class="note-comment">
        <h3>
          Warning
        </h3>

        Writing to an out of range offset pads the string with spaces. Non-integer types are converted to integer. Illegal offset type emits E_NOTICE. Only the first character of an assigned string is used. As of PHP 7.1.0, assigning an empty
        string
        throws a fatal error. Formerly, it assigned a NULL byte.
      </div>
      <div class="note-comment">
        <h3>
          Warning
        </h3>

        Internally, PHP strings are byte arrays. As a result, accessing or modifying a string using array brackets is not multi-byte safe, and should only be done with strings that are in a single-byte encoding such as ISO-8859-1.
      </div>
      <p>
        Note: As of PHP 7.1.0, applying the empty index operator on an empty string throws a fatal error. Formerly, the empty string was silently converted to an array.
      </p>

      <p>
        Example #11 Some string examples
      </p>
      <code>
        &lt;?php<br>
        // Get the first character of a string<br>
        $str = 'This is a test.';<br>
        $first = $str[0];<br>

        // Get the third character of a string<br>
        $third = $str[2];<br>

        // Get the last character of a string.<br>
        $str = 'This is still a test.';<br>
        $last = $str[strlen($str)-1];<br>

        // Modify the last character of a string<br>
        $str = 'Look at the sea';<br>
        $str[strlen($str)-1] = 'e';<br>

        ?&gt;<br>
      </code>
      <p>
        As of PHP 5.4 string offsets have to either be integers or integer-like strings, otherwise a warning will be thrown. Previously an offset like "foo" was silently cast to 0.
      </p>
      <p>
        Example #12 Differences between PHP 5.3 and PHP 5.4
      </p>
      <code>
        &lt;?php<br>
        $str = 'abc';<br>

        var_dump($str['1']);<br>
        var_dump(isset($str['1']));<br>

        var_dump($str['1.0']);<br>
        var_dump(isset($str['1.0']));<br>

        var_dump($str['x']);<br>
        var_dump(isset($str['x']));<br>

        var_dump($str['1x']);<br>
        var_dump(isset($str['1x']));<br>
        ?&gt;<br>
      </code>
      <p>
        Output of the above example in PHP 5.3:
      </p>
      <code>
        string(1) "b"<br>
        bool(true)<br>
        string(1) "b"<br>
        bool(true)<br>
        string(1) "a"<br>
        bool(true)<br>
        string(1) "b"<br>
        bool(true)<br>
      </code>
      <p>
        Output of the above example in PHP 5.4:
      </p>

      <code>
        string(1) "b"<br>
        bool(true)<br>
      </code>


      <p>
        Note:

        Accessing variables of other types (not including arrays or objects implementing the appropriate interfaces) using [] or {} silently returns NULL.
      </p>
      <p>
        Note:

        PHP 5.5 added support for accessing characters within string literals using [] or {}.
      </p>
      <h2>
        Useful functions and operators ¶
      </h2>
      <p>
        Strings may be concatenated using the '.' (dot) operator. Note that the '+' (addition) operator will not work for this. See String operators for more information.
      </p>
      <p>
        There are a number of useful functions for string manipulation.
      </p>
      <p>
        There are also functions for URL strings, and functions to encrypt/decrypt strings (Sodium and Hash).
      </p>
      <p>
        Finally, see also the character type functions.
      </p>
      <h2>
        Converting to string ¶
      </h2>
      <p>
        A value can be converted to a string using the (string) cast or the strval() function. String conversion is automatically done in the scope of an expression where a string is needed. This happens when using the echo or print functions, or
        when a variable is compared to a string. The sections on Types and Type Juggling will make the following clearer. See also the settype() function.
      </p>
      <p>
        A boolean TRUE value is converted to the string "1". Boolean FALSE is converted to "" (the empty string). This allows conversion back and forth between boolean and string values.
      </p>
      <p>
        An integer or float is converted to a string representing the number textually (including the exponent part for floats). Floating point numbers can be converted using exponential notation (4.1E+6).
      </p>
      <p>
        Note:

        The decimal point character is defined in the script's locale (category LC_NUMERIC). See the setlocale() function.
      </p>
      <p>
        Arrays are always converted to the string "Array"; because of this, echo and print can not by themselves show the contents of an array. To view a single element, use a construction such as echo $arr['foo']. See below for tips on viewing the
        entire contents.
      </p>
      <p>
        In order to convert objects to string magic method __toString must be used.
      </p>
      <p>
        Resources are always converted to strings with the structure "Resource id #1", where 1 is the resource number assigned to the resource by PHP at runtime. While the exact structure of this string should not be relied on and is subject to
        change, it will always be unique for a given resource within the lifetime of a script being executed (ie a Web request or CLI process) and won't be reused. To get a resource's type, use the get_resource_type() function.
      </p>
      <p>
        NULL is always converted to an empty string.
      </p>
      <p>
        As stated above, directly converting an array, object, or resource to a string does not provide any useful information about the value beyond its type. See the functions print_r() and var_dump() for more effective means of inspecting the
        contents of these types.
      </p>
      <p>
        Most PHP values can also be converted to strings for permanent storage. This method is called serialization, and is performed by the serialize() function. If the PHP engine was built with WDDX support, PHP values can also be serialized as
        well-formed XML text.
      </p>

      <h2>
        String conversion to numbers ¶
      </h2>
      <p>
        When a string is evaluated in a numeric context, the resulting value and type are determined as follows.
      </p>
      <p>
        If the string does not contain any of the characters '.', 'e', or 'E' and the numeric value fits into integer type limits (as defined by PHP_INT_MAX), the string will be evaluated as an integer. In all other cases it will be evaluated as a
        float.
      </p>
      <p>
        The value is given by the initial portion of the string. If the string starts with valid numeric data, this will be the value used. Otherwise, the value will be 0 (zero). Valid numeric data is an optional sign, followed by one or more
        digits
        (optionally containing a decimal point), followed by an optional exponent. The exponent is an 'e' or 'E' followed by one or more digits.
      </p>
      <code>
        &lt;?php<br>
        $foo = 1 + "10.5"; // $foo is float (11.5)<br>
        $foo = 1 + "-1.3e3"; // $foo is float (-1299)<br>
        $foo = 1 + "bob-1.3e3"; // $foo is integer (1)<br>
        $foo = 1 + "bob3"; // $foo is integer (1)<br>
        $foo = 1 + "10 Small Pigs"; // $foo is integer (11)<br>
        $foo = 4 + "10.2 Little Piggies"; // $foo is float (14.2)<br>
        $foo = "10.0 pigs " + 1; // $foo is float (11)<br>
        $foo = "10.0 pigs " + 1.0; // $foo is float (11)<br>
        ?&gt;<br>
      </code>
      <p>
        For more information on this conversion, see the Unix manual page for strtod(3).
      </p>
      <p>
        To test any of the examples in this section, cut and paste the examples and insert the following line to see what's going on:
      </p>
      <code>
        &lt;?php<br>
        echo "\$foo==$foo; type is " . gettype ($foo) . "<br />\n";<br>
        ?&gt;<br>
      </code>
      <p>
        Do not expect to get the code of one character by converting it to integer, as is done in C. Use the ord() and chr() functions to convert between ASCII codes and characters.
        Details of the String Type ¶
      </p>
      <p>
        The string in PHP is implemented as an array of bytes and an integer indicating the length of the buffer. It has no information about how those bytes translate to characters, leaving that task to the programmer. There are no limitations on
        the values the string can be composed of; in particular, bytes with value 0 (“NUL bytes”) are allowed anywhere in the string (however, a few functions, said in this manual not to be “binary safe”, may hand off the strings to libraries that
        ignore data after a NUL byte.)
      </p>
      <p>
        This nature of the string type explains why there is no separate “byte” type in PHP – strings take this role. Functions that return no textual data – for instance, arbitrary data read from a network socket – will still return strings.
      </p>
      <p>
        Given that PHP does not dictate a specific encoding for strings, one might wonder how string literals are encoded. For instance, is the string "á" equivalent to "\xE1" (ISO-8859-1), "\xC3\xA1" (UTF-8, C form), "\x61\xCC\x81" (UTF-8, D
        form)
        or any other possible representation? The answer is that string will be encoded in whatever fashion it is encoded in the script file. Thus, if the script is written in ISO-8859-1, the string will be encoded in ISO-8859-1 and so on.
        However,
        this does not apply if Zend Multibyte is enabled; in that case, the script may be written in an arbitrary encoding (which is explicity declared or is detected) and then converted to a certain internal encoding, which is then the encoding
        that will be used for the string literals. Note that there are some constraints on the encoding of the script (or on the internal encoding, should Zend Multibyte be enabled) – this almost always means that this encoding should be a
        compatible superset of ASCII, such as UTF-8 or ISO-8859-1. Note, however, that state-dependent encodings where the same byte values can be used in initial and non-initial shift states may be problematic.
      </p>
      <p>
        Of course, in order to be useful, functions that operate on text may have to make some assumptions about how the string is encoded. Unfortunately, there is much variation on this matter throughout PHP’s functions:
      </p>
      <p>
        Some functions assume that the string is encoded in some (any) single-byte encoding, but they do not need to interpret those bytes as specific characters. This is case of, for instance, substr(), strpos(), strlen() or strcmp(). Another way
        to think of these functions is that operate on memory buffers, i.e., they work with bytes and byte offsets.
        Other functions are passed the encoding of the string, possibly they also assume a default if no such information is given. This is the case of htmlentities() and the majority of the functions in the mbstring extension.
        Others use the current locale (see setlocale()), but operate byte-by-byte. This is the case of strcasecmp(), strtoupper() and ucfirst(). This means they can be used only with single-byte encodings, as long as the encoding is matched by the
        locale. For instance strtoupper("á") may return "Á" if the locale is correctly set and á is encoded with a single byte. If it is encoded in UTF-8, the correct result will not be returned and the resulting string may or may not be returned
        corrupted, depending on the current locale.
        Finally, they may just assume the string is using a specific encoding, usually UTF-8. This is the case of most functions in the intl extension and in the PCRE extension (in the last case, only when the u modifier is used). Although this is
        due to their special purpose, the function utf8_decode() assumes a UTF-8 encoding and the function utf8_encode() assumes an ISO-8859-1 encoding.
      </p>
      <p>
        Ultimately, this means writing correct programs using Unicode depends on carefully avoiding functions that will not work and that most likely will corrupt the data and using instead the functions that do behave correctly, generally from
        the
        intl and mbstring extensions. However, using functions that can handle Unicode encodings is just the beginning. No matter the functions the language provides, it is essential to know the Unicode specification. For instance, a program that
        assumes there is only uppercase and lowercase is making a wrong assumption.
      </p>
    </section>


    <section class="main-section" id="Arrays">
      <header>Arrays</header>
      <p>
        An array in PHP is actually an ordered map. A map is a type that associates values to keys. This type is optimized for several different uses; it can be treated as an array, list (vector), hash table (an implementation of a map), dictionary,
        collection, stack, queue, and probably more. As array values can be other arrays, trees and multidimensional arrays are also possible.
      </p>
      <p>
        Explanation of those data structures is beyond the scope of this manual, but at least one example is provided for each of them. For more information, look towards the considerable literature that exists about this broad topic.
      </p>
      <h2>
        Specifying with array() ¶
      </h2>
      <p>
        An array can be created using the array() language construct. It takes any number of comma-separated key => value pairs as arguments.
      </p>
      <code>
        array(<br>
        key => value,<br>
        key2 => value2,<br>
        key3 => value3,<br>
        ...<br>
        )<br>
      </code>
      <p>
        The comma after the last array element is optional and can be omitted. This is usually done for single-line arrays, i.e. array(1, 2) is preferred over array(1, 2, ). For multi-line arrays on the other hand the trailing comma is commonly
        used, as it allows easier addition of new elements at the end.
      </p>

      <p class="note-comment">
        As of PHP 5.4 you can also use the short array syntax, which replaces array() with [].
      </p>
      <p>
        Example #1 A simple array
      </p>
      <code>
        &lt;?php<br>
        $array = array(<br>
        "foo" => "bar",<br>
        "bar" => "foo",<br>
        );<br>

        // as of PHP 5.4<br>
        $array = [<br>
        "foo" => "bar",<br>
        "bar" => "foo",<br>
        ];<br>
        ?&gt;<br>
      </code>
      <p>
        The key can either be an integer or a string. The value can be of any type.
      </p>
      <p>
        Additionally the following key casts will occur:
      </p>
      <p>
        Strings containing valid decimal integers, unless the number is preceded by a + sign, will be cast to the integer type. E.g. the key "8" will actually be stored under 8. On the other hand "08" will not be cast, as it isn't a valid decimal
        integer.
        Floats are also cast to integers, which means that the fractional part will be truncated. E.g. the key 8.7 will actually be stored under 8.
        Bools are cast to integers, too, i.e. the key true will actually be stored under 1 and the key false under 0.
        Null will be cast to the empty string, i.e. the key null will actually be stored under "".
        Arrays and objects can not be used as keys. Doing so will result in a warning: Illegal offset type.
      </p>
      <p>
        If multiple elements in the array declaration use the same key, only the last one will be used as all others are overwritten.
      </p>
      <p>
        Example #2 Type Casting and Overwriting example
      </p>
      <code>
        &lt;?php<br>
        $array = array(<br>
        1 => "a",<br>
        "1" => "b",<br>
        1.5 => "c",<br>
        true => "d",<br>
        );<br>
        var_dump($array);<br>
        ?&gt;<br>
      </code>
      <p>
        The above example will output:
      </p>

      <code>
        array(1) {<br>
        [1]=><br>
        string(1) "d"<br>
        }<br>
      </code>
      <p>
        As all the keys in the above example are cast to 1, the value will be overwritten on every new element and the last assigned value "d" is the only one left over.
      </p>
      <p>
        PHP arrays can contain integer and string keys at the same time as PHP does not distinguish between indexed and associative arrays.
      </p>
      <p>
        Example #3 Mixed integer and string keys
      </p>
      <code>
        &lt;?php<br>
        $array = array(<br>
        "foo" => "bar",<br>
        "bar" => "foo",<br>
        100 => -100,<br>
        -100 => 100,<br>
        );<br>
        var_dump($array);<br>
        ?&gt;<br>
      </code>
      <p>
        The above example will output:
      </p>

      <code>
        array(4) {<br>
        ["foo"]=><br>
        string(3) "bar"<br>
        ["bar"]=><br>
        string(3) "foo"<br>
        [100]=><br>
        int(-100)<br>
        [-100]=><br>
        int(100)<br>
        }<br>
      </code>
      <p>
        The key is optional. If it is not specified, PHP will use the increment of the largest previously used integer key.
      </p>
      <p>
        Example #4 Indexed arrays without key
      </p>
      <code>
        &lt;?php<br>
        $array = array("foo", "bar", "hello", "world");<br>
        var_dump($array);<br>
        ?&gt;<br>
      </code>
      <p>
        The above example will output:
      </p>

      <code>
        array(4) {<br>
        [0]=><br>
        string(3) "foo"<br>
        [1]=><br>
        string(3) "bar"<br>
        [2]=><br>
        string(5) "hello"<br>
        [3]=><br>
        string(5) "world"<br>
        }<br>
      </code>
      <p>
        It is possible to specify the key only for some elements and leave it out for others:
      </p>
      <p>
        Example #5 Keys not on all elements
      </p>
      <code>&lt;?php<br>
        $array = array(<br>
        "a",<br>
        "b",<br>
        6 => "c",<br>
        "d",<br>
        );<br>
        var_dump($array);<br>
        ?&gt;<br>
      </code>
      <p>
        The above example will output:
      </p>

      <code>
        array(4) {<br>
        [0]=><br>
        string(1) "a"<br>
        [1]=><br>
        string(1) "b"<br>
        [6]=><br>
        string(1) "c"<br>
        [7]=><br>
        string(1) "d"<br>
        }<br>
      </code>
      <p>
        As you can see the last value "d" was assigned the key 7. This is because the largest integer key before that was 6.
      </p>
      <h2>
        Accessing array elements with square bracket syntax ¶
      </h2>
      <p>
        Array elements can be accessed using the array[key] syntax.
      </p>
      <p>
        Example #6 Accessing array elements
      </p>
      <code>
        &lt;?php<br>
        $array = array(<br>
        "foo" => "bar",<br>
        42 => 24,<br>
        "multi" => array(<br>
        "dimensional" => array(<br>
        "array" => "foo"<br>
        )<br>
        )<br>
        );<br>

        var_dump($array["foo"]);<br>
        var_dump($array[42]);<br>
        var_dump($array["multi"]["dimensional"]["array"]);<br>
        ?&gt;<br>
      </code>
      <p>
        The above example will output:
      </p>
      <code>
        string(3) "bar"<br>
        int(24)<br>
        string(3) "foo"<br>
      </code>
      <p class="note-comment">
        Note:

        Both square brackets and curly braces can be used interchangeably for accessing array elements (e.g. $array[42] and $array{42} will both do the same thing in the example above).
      </p>
      <p class="note-comment">
        As of PHP 5.4 it is possible to array dereference the result of a function or method call directly. Before it was only possible using a temporary variable.
      </p>
      <p class="note-comment">
        As of PHP 5.5 it is possible to array dereference an array literal.
      </p>
      <p>
        Example #7 Array dereferencing
      </p>
      <code>
        &lt;?php<br>
        function getArray() {<br>
        return array(1, 2, 3);<br>
        }<br>

        // on PHP 5.4<br>
        $secondElement = getArray()[1];<br>

        // previously<br>
        $tmp = getArray();<br>
        $secondElement = $tmp[1];<br>

        // or<br>
        list(, $secondElement) = getArray();<br>
        ?&gt;<br>
      </code>
      <p class="note-comment">
        Note:

        Attempting to access an array key which has not been defined is the same as accessing any other undefined variable: an E_NOTICE-level error message will be issued, and the result will be NULL.
      </p>
      <p class="note-comment">
        Note:

        Array dereferencing a scalar value which is not a string silently yields NULL, i.e. without issuing an error message.
      </p>
      <h2>
        Creating/modifying with square bracket syntax ¶
      </h2>
      <p>
        An existing array can be modified by explicitly setting values in it.
      </p>
      <p>
        This is done by assigning values to the array, specifying the key in brackets. The key can also be omitted, resulting in an empty pair of brackets ([]).
      </p>
      <code>
        $arr[key] = value;<br>
        $arr[] = value;<br>
        // key may be an integer or string<br>
        // value may be any value of any type<br>
      </code>
      <p>
        If $arr doesn't exist yet, it will be created, so this is also an alternative way to create an array. This practice is however discouraged because if $arr already contains some value (e.g. string from request variable) then this value will
        stay in the place and [] may actually stand for string access operator. It is always better to initialize a variable by a direct assignment.
      </p>

      <p class="note-comment">
        Note: As of PHP 7.1.0, applying the empty index operator on a string throws a fatal error. Formerly, the string was silently converted to an array.
      </p>
      <p>
        To change a certain value, assign a new value to that element using its key. To remove a key/value pair, call the unset() function on it.
      </p>
      <code>
        &lt;?php<br>
        $arr = array(5 => 1, 12 => 2);<br>

        $arr[] = 56; // This is the same as $arr[13] = 56;<br>
        // at this point of the script<br>

        $arr["x"] = 42; // This adds a new element to<br>
        // the array with key "x"<br>

        unset($arr[5]); // This removes the element from the array<br>

        unset($arr); // This deletes the whole array<br>
        ?&gt;<br>
      </code>
      <p class="note-comment">
        Note:

        As mentioned above, if no key is specified, the maximum of the existing integer indices is taken, and the new key will be that maximum value plus 1 (but at least 0). If no integer indices exist yet, the key will be 0 (zero).
      </p>
      <p>
        Note that the maximum integer key used for this need not currently exist in the array. It need only have existed in the array at some time since the last time the array was re-indexed. The following example illustrates:
      </p>
      <code>
        &lt;?php<br>
        // Create a simple array.<br>
        $array = array(1, 2, 3, 4, 5);<br>
        print_r($array);<br>

        // Now delete every item, but leave the array itself intact:<br>
        foreach ($array as $i => $value) {<br>
        unset($array[$i]);<br>
        }<br>
        print_r($array);<br>

        // Append an item (note that the new key is 5, instead of 0).<br>
        $array[] = 6;<br>
        print_r($array);<br>

        // Re-index:<br>
        $array = array_values($array);<br>
        $array[] = 7;<br>
        print_r($array);<br>
        ?&gt;<br>
      </code>
      <p>
        The above example will output:
      </p>
      <code>
        Array<br>
        (<br>
        [0] => 1<br>
        [1] => 2<br>
        [2] => 3<br>
        [3] => 4<br>
        [4] => 5<br>
        )<br>
        Array<br>
        (<br>
        )<br>
        Array<br>
        (<br>
        [5] => 6<br>
        )<br>
        Array<br>
        (<br>
        [0] => 6<br>
        [1] => 7<br>
        )<br>
      </code>
      <h2>
        Useful functions ¶
      </h2>
      <p>
        There are quite a few useful functions for working with arrays. See the array functions section.
      </p>
      <p class="note-comment">
        Note:

        The unset() function allows removing keys from an array. Be aware that the array will not be reindexed. If a true "remove and shift" behavior is desired, the array can be reindexed using the array_values() function.
      </p>

      <code>&lt;?php<br>
        $a = array(1 => 'one', 2 => 'two', 3 => 'three');<br>
        unset($a[2]);<br>
        /* will produce an array that would have been defined as<br>
        $a = array(1 => 'one', 3 => 'three');<br>
        and NOT<br>
        $a = array(1 => 'one', 2 =>'three');<br>
        */<br>

        $b = array_values($a);<br>
        // Now $b is array(0 => 'one', 1 =>'three')<br>
        ?&gt;<br>
      </code>

      <p>
        The foreach control structure exists specifically for arrays. It provides an easy way to traverse an array.
      </p>
      <h2>
        Array do's and don'ts ¶
      </h2>


      <p>
        Always use quotes around a string literal array index. For example, $foo['bar'] is correct, while $foo[bar] is not. But why? It is common to encounter this kind of syntax in old scripts:
      </p>
      <code>
        &lt;?php<br>
        $foo[bar] = 'enemy';<br>
        echo $foo[bar];<br>
        // etc<br>
        ?&gt;<br>
      </code>


      <p>
        This is wrong, but it works. The reason is that this code has an undefined constant (bar) rather than a string ('bar' - notice the quotes). It works because PHP automatically converts a bare string (an unquoted string which does not
        correspond to any known symbol) into a string which contains the bare string. For instance, if there is no defined constant named bar, then PHP will substitute in the string 'bar' and use that.
      </p>

      <div class="note-comment">
        <h3>
          Warning
        </h3>

        The fallback to treat an undefined constant as bare string is deprecated as of PHP 7.2.0, and issues an error of level E_WARNING. Formerly, an error of level E_NOTICE has been issued.
      </div>

      <p class="note-comment">
        Note: This does not mean to always quote the key. Do not quote keys which are constants or variables, as this will prevent PHP from interpreting them.
      </p>
      <code>
        &lt;?php<br>
        error_reporting(E_ALL);<br>
        ini_set('display_errors', true);<br>
        ini_set('html_errors', false);<br>
        // Simple array:<br>
        $array = array(1, 2);<br>
        $count = count($array);<br>
        for ($i = 0; $i < $count; $i++) {<br>
          echo "\nChecking $i: \n";<br>
          echo "Bad: " . $array['$i'] . "\n";<br>
          echo "Good: " . $array[$i] . "\n";<br>
          echo "Bad: {$array['$i']}\n";<br>
          echo "Good: {$array[$i]}\n";<br>
          }<br>
          ?&gt;<br>
      </code>

      <code>
        The above example will output:<br>

        Checking 0:<br>
        Notice: Undefined index: $i in /path/to/script.html on line 9<br>
        Bad:<br>
        Good: 1<br>
        Notice: Undefined index: $i in /path/to/script.html on line 11<br>
        Bad:<br>
        Good: 1<br>

        Checking 1:<br>
        Notice: Undefined index: $i in /path/to/script.html on line 9<br>
        Bad:<br>
        Good: 2<br>
        Notice: Undefined index: $i in /path/to/script.html on line 11<br>
        Bad:<br>
        Good: 2<br>
      </code>
      <p>
        More examples to demonstrate this behaviour:
      </p>
      <code>
        &lt;?php<br>
        // Show all errors<br>
        error_reporting(E_ALL);<br>

        $arr = array('fruit' => 'apple', 'veggie' => 'carrot');<br>

        // Correct<br>
        print $arr['fruit']; // apple<br>
        print $arr['veggie']; // carrot<br>

        // Incorrect. This works but also throws a PHP error of level E_NOTICE because<br>
        // of an undefined constant named fruit<br>
        //<br>
        // Notice: Use of undefined constant fruit - assumed 'fruit' in...<br>
        print $arr[fruit]; // apple<br>

        // This defines a constant to demonstrate what's going on. The value 'veggie'<br>
        // is assigned to a constant named fruit.<br>
        define('fruit', 'veggie');<br>

        // Notice the difference now<br>
        print $arr['fruit']; // apple<br>
        print $arr[fruit]; // carrot<br>

        // The following is okay, as it's inside a string. Constants are not looked for<br>
        // within strings, so no E_NOTICE occurs here<br>
        print "Hello $arr[fruit]"; // Hello apple<br>

        // With one exception: braces surrounding arrays within strings allows constants<br>
        // to be interpreted<br>
        print "Hello {$arr[fruit]}"; // Hello carrot<br>
        print "Hello {$arr['fruit']}"; // Hello apple<br>

        // This will not work, and will result in a parse error, such as:<br>
        // Parse error: parse error, expecting T_STRING' or T_VARIABLE' or T_NUM_STRING'<br>
        // This of course applies to using superglobals in strings as well<br>
        print "Hello $arr['fruit']";<br>
        print "Hello $_GET['foo']";<br>

        // Concatenation is another option<br>
        print "Hello " . $arr['fruit']; // Hello apple<br>
        ?&gt;<br>
      </code>
      <p>
        When error_reporting is set to show E_NOTICE level errors (by setting it to E_ALL, for example), such uses will become immediately visible. By default, error_reporting is set not to show notices.
      </p>
      <p>
        As stated in the syntax section, what's inside the square brackets ('[' and ']') must be an expression. This means that code like this works:
      </p>
      <code>
        &lt;?php<br>
        echo $arr[somefunc($bar)];<br>
        ?&gt;<br>
      </code>
      <p>
        This is an example of using a function return value as the array index. PHP also knows about constants:
      </p>
      <code>
        &lt;?php<br>
        $error_descriptions[E_ERROR] = "A fatal error has occurred";<br>
        $error_descriptions[E_WARNING] = "PHP issued a warning";<br>
        $error_descriptions[E_NOTICE] = "This is just an informal notice";<br>
        ?&gt;<br>
      </code>
      <p>
        Note that E_ERROR is also a valid identifier, just like bar in the first example. But the last example is in fact the same as writing:
      </p>
      <code>
        &lt;?php<br>
        $error_descriptions[1] = "A fatal error has occurred";<br>
        $error_descriptions[2] = "PHP issued a warning";<br>
        $error_descriptions[8] = "This is just an informal notice";<br>
        ?&gt;<br>
      </code>
      <p>
        because E_ERROR equals 1, etc.
        So why is it bad then?
      </p>
      <p>
        At some point in the future, the PHP team might want to add another constant or keyword, or a constant in other code may interfere. For example, it is already wrong to use the words empty and default this way, since they are reserved
        keywords.
      </p>
      <p class="note-comment">
        Note: To reiterate, inside a double-quoted string, it's valid to not surround array indexes with quotes so "$foo[bar]" is valid. See the above examples for details on why as well as the section on variable parsing in strings.
      </p>
      <h2>
        Converting to array ¶
      </h2>
      <p>
        For any of the types integer, float, string, boolean and resource, converting a value to an array results in an array with a single element with index zero and the value of the scalar which was converted. In other words, (array)$scalarValue
        is exactly the same as array($scalarValue).
      </p>
      <p>
        If an object is converted to an array, the result is an array whose elements are the object's properties. The keys are the member variable names, with a few notable exceptions: integer properties are unaccessible; private variables have the
        class name prepended to the variable name; protected variables have a '*' prepended to the variable name. These prepended values have null bytes on either side. This can result in some unexpected behaviour:
      </p>
      <code>
        &lt;?php<br>

        class A {<br>
        private $A; // This will become '\0A\0A'<br>
        }<br>

        class B extends A {<br>
        private $A; // This will become '\0B\0A'<br>
        public $AA; // This will become 'AA'<br>
        }<br>

        var_dump((array) new B());<br>
        ?&gt;<br>
      </code>
      <p>
        The above will appear to have two keys named 'AA', although one of them is actually named '\0A\0A'.
      </p>
      <p>
        Converting NULL to an array results in an empty array.
      </p>
      <h2>
        Comparing ¶
      </h2>

      <p>
        It is possible to compare arrays with the array_diff() function and with array operators.
      </p>
      <h2>
        Examples ¶
      </h2>
      <p>
        The array type in PHP is very versatile. Here are some examples:
      </p>
      <code>
        &lt;?php<br>
        // This:<br>
        $a = array( 'color' => 'red',<br>
        'taste' => 'sweet',<br>
        'shape' => 'round',<br>
        'name' => 'apple',<br>
        4 // key will be 0<br>
        );<br>

        $b = array('a', 'b', 'c');<br>

        // . . .is completely equivalent with this:<br>
        $a = array();<br>
        $a['color'] = 'red';<br>
        $a['taste'] = 'sweet';<br>
        $a['shape'] = 'round';<br>
        $a['name'] = 'apple';<br>
        $a[] = 4; // key will be 0<br>

        $b = array();<br>
        $b[] = 'a';<br>
        $b[] = 'b';<br>
        $b[] = 'c';<br>

        // After the above code is executed, $a will be the array<br>
        // array('color' => 'red', 'taste' => 'sweet', 'shape' => 'round',<br>
        // array(0 => 'a', 1 => 'b', 2 => 'c'), or simply array('a', 'b', 'c').<br>
        // 'name' => 'apple', 0 => 4), and $b will be the array<br>
        ?&gt;<br>
      </code>
      <p>
        Example #8 Using array()
      </p>
      <code>
        &lt;?php<br>
        // Array as (property-)map<br>
        $map = array( 'version' => 4,<br>
        'OS' => 'Linux',<br>
        'lang' => 'english',<br>
        'short_tags' => true<br>
        );<br>

        // strictly numerical keys<br>
        $array = array( 7,<br>
        8,<br>
        0,<br>
        156,<br>
        -10<br>
        );<br>
        // this is the same as array(0 => 7, 1 => 8, ...)<br>

        $switching = array( 10, // key = 0<br>
        5 => 6,<br>
        3 => 7,<br>
        'a' => 4,<br>
        11, // key = 6 (maximum of integer-indices was 5)<br>
        '8' => 2, // key = 8 (integer!)<br>
        '02' => 77, // key = '02'<br>
        0 => 12 // the value 10 will be overwritten by 12<br>
        );<br>

        $empty = array();<br>
        // empty array<br>
        ?&gt;<br>
      </code>
      <p>
        Example #9 Collection
      </p>
      <code>
        &lt;?php<br>
        $colors = array('red', 'blue', 'green', 'yellow');<br>

        foreach ($colors as $color) {<br>
        echo "Do you like $color?\n";<br>
        }<br>

        ?&gt;<br>
      </code>
      <p>
        The above example will output:
      </p>
      <code>
        Do you like red?<br>
        Do you like blue?<br>
        Do you like green?<br>
        Do you like yellow?<br>
      </code>
      <p>
        Changing the values of the array directly is possible by passing them by reference.
      </p>
      <p>
        Example #10 Changing element in the loop
      </p>
      <code>
        &lt;?php<br>
        foreach ($colors as &$color) {<br>
        $color = strtoupper($color);<br>
        }<br>
        unset($color); /* ensure that following writes to<br>
        $color will not modify the last array element */<br>

        print_r($colors);<br>
        ?&gt;<br>
      </code>
      <p>
        The above example will output:
      </p>

      <code>
        Array<br>
        (<br>
        [0] => RED<br>
        [1] => BLUE<br>
        [2] => GREEN<br>
        [3] => YELLOW<br>
        )<br>
      </code>
      <p>
        This example creates a one-based array.
      </p>
      <p>
        Example #11 One-based index
      </p>
      <code>
        &lt;?php<br>
        $firstquarter = array(1 => 'January', 'February', 'March');<br>
        print_r($firstquarter);<br>
        ?&gt;<br>
      </code>
      <p>
        The above example will output:
      </p>
      <code>
        Array<br>
        (<br>
        [1] => 'January'<br>
        [2] => 'February'<br>
        [3] => 'March'<br>
        )<br>
      </code>
      <p>
        Example #12 Filling an array
      </p>
      <code>
        &lt;?php<br>
        // fill an array with all items from a directory<br>
        $handle = opendir('.');<br>
        while (false !== ($file = readdir($handle))) {<br>
        $files[] = $file;<br>
        }<br>
        closedir($handle);<br>
        ?&gt;<br>
      </code>
      <p>
        Arrays are ordered. The order can be changed using various sorting functions. See the array functions section for more information. The count() function can be used to count the number of items in an array.
      </p>
      <p>
        Example #13 Sorting an array
      </p>
      <code>
        &lt;?php<br>
        sort($files);<br>
        print_r($files);<br>
        ?&gt;<br>
      </code>
      <p>
        Because the value of an array can be anything, it can also be another array. This enables the creation of recursive and multi-dimensional arrays.
      </p>
      <p>
        Example #14 Recursive and multi-dimensional arrays
      </p>
      <code>
        &lt;?php<br>
        $fruits = array ( "fruits" => array ( "a" => "orange",<br>
        "b" => "banana",<br>
        "c" => "apple"<br>
        ),<br>
        "numbers" => array ( 1,<br>
        2,<br>
        3,<br>
        4,<br>
        5,<br>
        6<br>
        ),<br>
        "holes" => array ( "first",<br>
        5 => "second",<br>
        "third"<br>
        )<br>
        );<br>

        // Some examples to address values in the array above<br>
        echo $fruits["holes"][5]; // prints "second"<br>
        echo $fruits["fruits"]["a"]; // prints "orange"<br>
        unset($fruits["holes"][0]); // remove "first"<br>

        // Create a new multi-dimensional array<br>
        $juices["apple"]["green"] = "good";<br>
        ?&gt;<br>
      </code>
      <p>
        Array assignment always involves value copying. Use the reference operator to copy an array by reference.
      </p>
      <code>
        &lt;?php<br>
        $arr1 = array(2, 3);<br>
        $arr2 = $arr1;<br>
        $arr2[] = 4; // $arr2 is changed,<br>
        // $arr1 is still array(2, 3)<br>

        $arr3 = &$arr1;<br>
        $arr3[] = 4; // now $arr1 and $arr3 are the same<br>
        ?&gt;<br>
      </code>
    </section>


    <section class="main-section" id="Iterables">
      <header>Iterables</header>
      <p>
        Iterable is a pseudo-type introduced in PHP 7.1. It accepts any array or object implementing the Traversable interface. Both of these types are iterable using foreach and can be used with yield from within a generator.
      </p>
      <h2>
        Using Iterables ¶
      </h2>
      <p>
        Iterable can be used as a parameter type to indicate that a function requires a set of values, but does not care about the form of the value set since it will be used with foreach. If a value is not an array or instance of Traversable, a
        TypeError will be thrown.
      </p>
      <p>
        Example #1 Iterable parameter type example
      </p>
      <code>&lt;?php<br>

        function foo(iterable $iterable) {<br>
        foreach ($iterable as $value) {<br>
        // ...<br>
        }<br>
        }<br>

        ?&gt;<br>
      </code>
      <p>
        Parameters declared as iterable may use NULL or an array as a default value.
      </p>
      <p>
        Example #2 Iterable parameter default value example
      </p>
      <code>
        &lt;?php<br>

        function foo(iterable $iterable = []) {<br>
        // ...<br>
        }<br>

        ?&gt;<br>
      </code>
      <p>
        Iterable can also be used as a return type to indicate a function will return an iterable value. If the returned value is not an array or instance of Traversable, a TypeError will be thrown.
      </p>
      <p>
        Example #3 Iterable return type example
      </p>
      <code>
        &lt;?php<br>

        function bar(): iterable {<br>
        return [1, 2, 3];<br>
        }<br>

        ?&gt;<br>
      </code>
      <p>
        Functions declaring iterable as a return type may also be generators.
      </p>
      <p>
        Example #4 Iterable generator return type example
      </p>
      <code>&lt;?php<br>

        function gen(): iterable {<br>
        yield 1;<br>
        yield 2;<br>
        yield 3;<br>
        }<br>

        ?&gt;<br>
      </code>
      <h2>
        Iterable Type Variance ¶
      </h2>
      <p>
        Classes extending/implementing may broaden methods using array or Traversable as parameter types to iterable or narrow return types from iterable to array or Traversable.
      </p>
      <p>
        Example #5 Iterable type variance example
      </p>
      <code>
        &lt;?php<br>
        interface Example {<br>
        public function method(array $array): iterable;<br>
        }<br>
        class ExampleImplementation implements Example {<br>
        public function method(iterable $iterable): array {<br>
        // Parameter broadened and return type narrowed.<br>
        }<br>
        }<br>
        ?&gt;<br>
      </code>
    </section>


    <section class="main-section" id="Objects">
      <header>Objects</header>
      <p>
        To create a new object, use the new statement to instantiate a class:
      </p>
      <code>
        &lt;?php<br>
        class foo<br>
        {<br>
        function do_foo()<br>
        {<br>
        echo "Doing foo.";<br>
        }<br>
        }<br>
        $bar = new foo;<br>
        $bar->do_foo();<br>
        ?&gt;<br>
      </code>
      <h2>
        Converting to object ¶
      </h2>
      <p>
        If an object is converted to an object, it is not modified. If a value of any other type is converted to an object, a new instance of the stdClass built-in class is created. If the value was NULL, the new instance will be empty. An array
        converts to an object with properties named by keys and corresponding values. Note that in this case before PHP 7.2.0 numeric keys have been inaccessible unless iterated.
      </p>
      <code>&lt;?php<br>
        $obj = (object) array('1' => 'foo');<br>
        var_dump(isset($obj->{'1'})); // outputs 'bool(true)' as of PHP 7.2.0; 'bool(false)' previously<br>
        var_dump(key($obj)); // outputs 'string(1) "1"' as of PHP 7.2.0; 'int(1)' previously<br>
        ?&gt;<br>
      </code>
      <p>
        For any other value, a member variable named scalar will contain the value.
      </p>
      <code>
        &lt;?php<br>
        $obj = (object) 'ciao';<br>
        echo $obj->scalar; // outputs 'ciao'<br>
        ?&gt;<br>
      </code>
    </section>


    <section class="main-section" id="Resources">
      <header>Resources</header>
      <p>
        A resource is a special variable, holding a reference to an external resource. Resources are created and used by special functions. See the appendix for a listing of all these functions and the corresponding resource types.
      </p>
      <h2>
        Converting to resource ¶
      </h2>
      <p>
        As resource variables hold special handles to opened files, database connections, image canvas areas and the like, converting to a resource makes no sense.
      </p>
      <h2>
        Freeing resources ¶
      </h2>
      <p>
        Thanks to the reference-counting system being part of Zend Engine, a resource with no more references to it is detected automatically, and it is freed by the garbage collector. For this reason, it is rarely necessary to free the memory
        manually.
      </p>
      <p class="note-comment">
        Note: Persistent database links are an exception to this rule. They are not destroyed by the garbage collector. See the persistent connections section for more information.
      </p>
    </section>


    <section class="main-section" id="NULL">
      <header>NULL</header>
      <p>
        The special NULL value represents a variable with no value. NULL is the only possible value of type null.
      </p>
      <p>
        A variable is considered to be null if:
      </p>
      <p>
        it has been assigned the constant NULL.
      </p>
      <p>
        it has not been set to any value yet.
      </p>
      <p>
        it has been unset().
      </p>
      <h2>
        Syntax ¶
      </h2>
      <p>
        There is only one value of type null, and that is the case-insensitive constant NULL.
      </p>
      <code>
        &lt;?php<br>
        $var = NULL;<br>
        ?&gt;<br>
      </code>
      <p>
        See also the functions is_null() and unset().
      </p>
      <h2>
        Casting to NULL ¶
      </h2>
      <div class="note-comment">
        <h3>
          Warning
        </h3>
        This feature has been DEPRECATED as of PHP 7.2.0. Relying on this feature is highly discouraged.
      </div>
      Casting a variable to null using (unset) $var will not remove the variable or unset its value. It will only return a NULL value.
    </section>


    <section class="main-section" id="Callbacks_/_Callables">
      <header>Callbacks / Callables</header>

      <p>
        Callbacks can be denoted by callable type hint as of PHP 5.4. This documentation used callback type information for the same purpose.
      </p>
      <p>
        Some functions like call_user_func() or usort() accept user-defined callback functions as a parameter. Callback functions can not only be simple functions, but also object methods, including static class methods.
      </p>
      <h2>
        Passing ¶
      </h2>
      <p>
        A PHP function is passed by its name as a string. Any built-in or user-defined function can be used, except language constructs such as: array(), echo, empty(), eval(), exit(), isset(), list(), print or unset().
      </p>
      <p>
        A method of an instantiated object is passed as an array containing an object at index 0 and the method name at index 1. Accessing protected and private methods from within a class is allowed.
      </p>
      <p>
        Static class methods can also be passed without instantiating an object of that class by passing the class name instead of an object at index 0. As of PHP 5.2.3, it is also possible to pass 'ClassName::methodName'.
      </p>
      <p>
        Apart from common user-defined function, anonymous functions can also be passed to a callback parameter.
      </p>
      <p>
        Example #1 Callback function examples
      </p>
      <code>
        &lt;?php<br>

        // An example callback function<br>
        function my_callback_function() {<br>
        echo 'hello world!';<br>
        }<br>

        // An example callback method<br>
        class MyClass {<br>
        static function myCallbackMethod() {<br>
        echo 'Hello World!';<br>
        }<br>
        }<br>

        // Type 1: Simple callback<br>
        call_user_func('my_callback_function');<br>

        // Type 2: Static class method call<br>
        call_user_func(array('MyClass', 'myCallbackMethod'));<br>

        // Type 3: Object method call<br>
        $obj = new MyClass();<br>
        call_user_func(array($obj, 'myCallbackMethod'));<br>

        // Type 4: Static class method call (As of PHP 5.2.3)<br>
        call_user_func('MyClass::myCallbackMethod');<br>

        // Type 5: Relative static class method call (As of PHP 5.3.0)<br>
        class A {<br>
        public static function who() {<br>
        echo "A\n";<br>
        }<br>
        }<br>

        class B extends A {<br>
        public static function who() {<br>
        echo "B\n";<br>
        }<br>
        }<br>

        call_user_func(array('B', 'parent::who')); // A<br>

        // Type 6: Objects implementing __invoke can be used as callables (since PHP 5.3)<br>
        class C {<br>
        public function __invoke($name) {<br>
        echo 'Hello ', $name, "\n";<br>
        }<br>
        }<br>

        $c = new C();<br>
        call_user_func($c, 'PHP!');<br>
        ?&gt;<br>
      </code>
      <p>
        Example #2 Callback example using a Closure
      </p>
      <code>&lt;?php<br>
        // Our closure<br>
        $double = function($a) {<br>
        return $a * 2;<br>
        };<br>

        // This is our range of numbers<br>
        $numbers = range(1, 5);<br>

        // Use the closure as a callback here to<br>
        // double the size of each element in our<br>
        // range<br>
        $new_numbers = array_map($double, $numbers);<br>

        print implode(' ', $new_numbers);<br>
        ?&gt;<br>
      </code>
      <p>
        The above example will output:
      </p>
      <code>
        2 4 6 8 10
      </code>

      <p class="note-comment">
        Note:

        Callbacks registered with functions such as call_user_func() and call_user_func_array() will not be called if there is an uncaught exception thrown in a previous callback.
      </p>

    </section>


    <section class="main-section" id="Pseudo-types_and_variables_used_in_this_documentation">
      <header>Pseudo-types and variables used in this documentation</header>

      <p>
        Pseudo-types are keywords used in the PHP documentation to specify the types or values an argument can have. Please note that they are not primitives of the PHP language. So you cannot use pseudo-types as typehints in your own custom
        functions.
        mixed
      </p>
      <p>
        mixed indicates that a parameter may accept multiple (but not necessarily all) types.
      </p>
      <p>
        gettype() for example will accept all PHP types, while str_replace() will accept strings and arrays.
        number
      </p>
      <p>
        number indicates that a parameter can be either integer or float.
        callback
      </p>
      <p>
        callback pseudo-types was used in this documentation before callable type hint was introduced by PHP 5.4. It means exactly the same.
        array|object
      </p>
      <p>
        array|object indicates that a parameter can be either array or object.
        void
      </p>
      <p>
        void as a return type means that the return value is useless. void in a parameter list means that the function doesn't accept any parameters. As of PHP 7.1 void is accepted as a function return type hint.
        ...
      </p>
      <p>
        $... in function prototypes means and so on. This variable name is used when a function can take an endless number of arguments.
      </p>
    </section>


    <section class="main-section" id="Type_Juggling">
      <header>Type Juggling</header>
      <p>
        PHP does not require (or support) explicit type definition in variable declaration; a variable's type is determined by the context in which the variable is used. That is to say, if a string value is assigned to variable $var, $var becomes a
        string. If an integer value is then assigned to $var, it becomes an integer.
      </p>
      <p>
        An example of PHP's automatic type conversion is the multiplication operator '*'. If either operand is a float, then both operands are evaluated as floats, and the result will be a float. Otherwise, the operands will be interpreted as
        integers, and the result will also be an integer. Note that this does not change the types of the operands themselves; the only change is in how the operands are evaluated and what the type of the expression itself is.
      </p>
      <code>
        &lt;?php<br>
        $foo = "1"; // $foo is string (ASCII 49)<br>
        $foo *= 2; // $foo is now an integer (2)<br>
        $foo = $foo * 1.3; // $foo is now a float (2.6)<br>
        $foo = 5 * "10 Little Piggies"; // $foo is integer (50)<br>
        $foo = 5 * "10 Small Pigs"; // $foo is integer (50)<br>
        ?&gt;<br>
      </code>
      <p>
        If the last two examples above seem odd, see String conversion to numbers.
      </p>
      <p>
        To force a variable to be evaluated as a certain type, see the section on Type casting. To change the type of a variable, see the settype() function.
      </p>
      <p>
        To test any of the examples in this section, use the var_dump() function.
      </p>
      <p class="note-comment">
        Note:

        The behaviour of an automatic conversion to array is currently undefined.
      </p>
      <p>
        Also, because PHP supports indexing into strings via offsets using the same syntax as array indexing, the following example holds true for all PHP versions:
      </p>
      <code>
        &lt;?php<br>
        $a = 'car'; // $a is a string<br>
        $a[0] = 'b'; // $a is still a string<br>
        echo $a; // bar<br>
        ?&gt;<br>
      </code>
      <h2>
        Type Casting ¶
      </h2>
      <p>
        Type casting in PHP works much as it does in C: the name of the desired type is written in parentheses before the variable which is to be cast.
      </p>
      <code>
        &lt;?php<br>
        $foo = 10; // $foo is an integer<br>
        $bar = (boolean) $foo; // $bar is a boolean<br>
        ?&gt;<br>
      </code>
      <p>
        The casts allowed are:
      </p>
      <ul>
        <li>
          (int), (integer) - cast to integer
        </li>
        <li>
          (bool), (boolean) - cast to boolean
        </li>
        <li>
          (float), (double), (real) - cast to float
        </li>
        <li>
          (string) - cast to string
        </li>
        <li>
          (array) - cast to array
        </li>
        <li>
          (object) - cast to object
        </li>
        <li>
          (unset) - cast to NULL
        </li>

        <li>
          (binary) casting and b prefix forward support was added in PHP 5.2.1. Note that the (binary) cast is essential the same as (string), but it should not be relied upon.
        </li>
      </ul>
      <p>
        The (unset) cast has been deprecated as of PHP 7.2.0. Note that the (unset) cast is the same as assigning the value NULL to the variable or call. The (unset) cast will be removed as of PHP 8.0.0.
      </p>
      <p class="note-comment">
        Note that tabs and spaces are allowed inside the parentheses, so the following are functionally equivalent:
      </p>
      <code>
        &lt;?php<br>
        $foo = (int) $bar;<br>
        $foo = ( int ) $bar;<br>
        ?&gt;<br>
      </code>
      <p>
        Casting literal strings and variables to binary strings:
      </p>
      <code>
        &lt;?php <br>
        $binary = (binary) $string; <br>
        $binary = b"binary string"; <br>
        ?&gt; <br>
      </code>
      <p class="note-comment">
        Note: Instead of casting a variable to a string, it is also possible to enclose the variable in double quotes.
      </p>
      <code>
        &lt;?php<br>
        $foo = 10; // $foo is an integer<br>
        $str = "$foo"; // $str is a string<br>
        $fst = (string) $foo; // $fst is also a string<br>

        // This prints out that "they are the same"<br>
        if ($fst === $str) {<br>
        echo "they are the same";<br>
        }<br>
        ?&gt;<br>
      </code>
    </section>




    <h1 id="Variables"> Variables </h1>
    <section class="main-section" id="Variable_Basics">
      <header>Variable Basics</header>
      <p>
        Variables in PHP are represented by a dollar sign followed by the name of the variable. The variable name is case-sensitive.
      </p>
      <p>
        Variable names follow the same rules as other labels in PHP. A valid variable name starts with a letter or underscore, followed by any number of letters, numbers, or underscores. As a regular expression, it would be expressed thus:
        [a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*
      </p>
      <p class="note-comment">
        Note: For our purposes here, a letter is a-z, A-Z, and the bytes from 127 through 255 (0x7f-0xff).
      </p>
      <p class="note-comment">
        Note: $this is a special variable that can't be assigned.
      </p>
      <p class="note-comment">
        Tip

        See also the Userland Naming Guide.
      </p>
      <p>
        For information on variable related functions, see the Variable Functions Reference.
      </p>
      <code>
        &lt;?php<br>
        $var = 'Bob';<br>
        $Var = 'Joe';<br>
        echo "$var, $Var"; // outputs "Bob, Joe"<br>

        $4site = 'not yet'; // invalid; starts with a number<br>
        $_4site = 'not yet'; // valid; starts with an underscore<br>
        $täyte = 'mansikka'; // valid; 'ä' is (Extended) ASCII 228.<br>
        ?&gt;<br>
      </code>
      <p>
        By default, variables are always assigned by value. That is to say, when you assign an expression to a variable, the entire value of the original expression is copied into the destination variable. This means, for instance, that after
        assigning one variable's value to another, changing one of those variables will have no effect on the other. For more information on this kind of assignment, see the chapter on Expressions.
      </p>
      <p>
        PHP also offers another way to assign values to variables: assign by reference. This means that the new variable simply references (in other words, "becomes an alias for" or "points to") the original variable. Changes to the new variable
        affect the original, and vice versa.
      </p>
      <p>
        To assign by reference, simply prepend an ampersand (&amp) to the beginning of the variable which is being assigned (the source variable). For instance, the following code snippet outputs 'My name is Bob' twice:
      </p>
      <code>
        &lt;?php<br>
        $foo = 'Bob'; // Assign the value 'Bob' to $foo<br>
        $bar = &amp$foo; // Reference $foo via $bar.<br>
        $bar = "My name is $bar"; // Alter $bar...<br>
        echo $bar;<br>
        echo $foo; // $foo is altered too.<br>
        ?&gt;<br>
      </code>
      <p>
        One important thing to note is that only named variables may be assigned by reference.
      </p>
      <code>
        &lt;?php<br>
        $foo = 25;<br>
        $bar = &amp$foo; // This is a valid assignment.<br>
        $bar = &amp(24 * 7); // Invalid; references an unnamed expression.<br>

        function test()<br>
        {<br>
        return 25;<br>
        }<br>

        $bar = &test(); // Invalid.<br>
        ?&gt;<br>
      </code>
      <p>
        It is not necessary to initialize variables in PHP however it is a very good practice. Uninitialized variables have a default value of their type depending on the context in which they are used - booleans default to FALSE, integers and
        floats default to zero, strings (e.g. used in echo) are set as an empty string and arrays become to an empty array.
      </p>
      <p>
        Example #1 Default values of uninitialized variables
      </p>
      <code>&lt;?php<br>
        // Unset AND unreferenced (no use context) variable; outputs NULL<br>
        var_dump($unset_var);<br>

        // Boolean usage; outputs 'false' (See ternary operators for more on this syntax)<br>
        echo($unset_bool ? "true\n" : "false\n");<br>

        // String usage; outputs 'string(3) "abc"'<br>
        $unset_str .= 'abc';<br>
        var_dump($unset_str);<br>

        // Integer usage; outputs 'int(25)'<br>
        $unset_int += 25; // 0 + 25 => 25<br>
        var_dump($unset_int);<br>

        // Float/double usage; outputs 'float(1.25)'<br>
        $unset_float += 1.25;<br>
        var_dump($unset_float);<br>

        // Array usage; outputs array(1) { [3]=> string(3) "def" }<br>
        $unset_arr[3] = "def"; // array() + array(3 => "def") => array(3 => "def")<br>
        var_dump($unset_arr);<br>

        // Object usage; creates new stdClass object (see http://www.php.net/manual/en/reserved.classes.php)<br>
        // Outputs: object(stdClass)#1 (1) { ["foo"]=> string(3) "bar" }<br>
        $unset_obj->foo = 'bar';<br>
        var_dump($unset_obj);<br>
        ?&gt;<br>
      </code>
      <p>
        Relying on the default value of an uninitialized variable is problematic in the case of including one file into another which uses the same variable name. It is also a major security risk with register_globals turned on. E_NOTICE level error
        is issued in case of working with uninitialized variables, however not in the case of appending elements to the uninitialized array. isset() language construct can be used to detect if a variable has been already initialized.
      </p>
    </section>


    <section class="main-section" id="Predefined_Variable">
      <header>Predefined Variable</header>
      <p>
        PHP provides a large number of predefined variables to any script which it runs. Many of these variables, however, cannot be fully documented as they are dependent upon which server is running, the version and setup of the server, and other
        factors. Some of these variables will not be available when PHP is run on the command line. For a listing of these variables, please see the section on Reserved Predefined Variables.
      </p>
      <div class="note-comment">
        <h3>
          Warning
        </h3>
        In PHP 4.2.0 and later, the default value for the PHP directive register_globals is off. This is a major change in PHP. Having register_globals off affects the set of predefined variables available in the global scope. For example, to get
        DOCUMENT_ROOT you'll use $_SERVER['DOCUMENT_ROOT'] instead of $DOCUMENT_ROOT, or $_GET['id'] from the URL http://www.example.com/test.php?id=3 instead of $id, or $_ENV['HOME'] instead of $HOME.
      </div>
      <p>
        For related information on this change, read the configuration entry for register_globals, the security chapter on Using Register Globals , as well as the PHP » 4.1.0 and » 4.2.0 Release Announcements.
      </p>
      <p>
        Using the available PHP Reserved Predefined Variables, like the superglobal arrays, is preferred.
      </p>
      <p>
        From version 4.1.0 onward, PHP provides an additional set of predefined arrays containing variables from the web server (if applicable), the environment, and user input. These new arrays are rather special in that they are automatically
        global--i.e., automatically available in every scope. For this reason, they are often known as "superglobals". (There is no mechanism in PHP for user-defined superglobals.) The superglobals are listed below; however, for a listing of their
        contents and further discussion on PHP predefined variables and their natures, please see the section Reserved Predefined Variables. Also, you'll notice how the older predefined variables ($HTTP_*_VARS) still exist. As of PHP 5.0.0, the long
        PHP predefined variable arrays may be disabled with the register_long_arrays directive.
      </p>
      <p class="note-comment">
        Note: Variable variables
        Superglobals cannot be used as variable variables inside functions or class methods.
      </p>
      <p class="note-comment">
        Note:
        Even though both the superglobal and HTTP_*_VARS can exist at the same time; they are not identical, so modifying one will not change the other.
      </p>
      <p>
        If certain variables in variables_order are not set, their appropriate PHP predefined arrays are also left empty.
      </p>
    </section>


    <section class="main-section" id="Variable_scope">
      <header>Variable scope</header>
      <p>
        The scope of a variable is the context within which it is defined. For the most part all PHP variables only have a single scope. This single scope spans included and required files as well. For example:
      </p>
      <code>
        &lt;?php<br>
        $a = 1;<br>
        include 'b.inc';<br>
        ?&gt;<br>
      </code>
      <p>
        Here the $a variable will be available within the included b.inc script. However, within user-defined functions a local function scope is introduced. Any variable used inside a function is by default limited to the local function scope. For
        example:
      </p>
      <code>
        &lt;?php<br>
        $a = 1; /* global scope */<br>

        function test()<br>
        {<br>
        echo $a; /* reference to local scope variable */<br>
        }<br>

        test();<br>
        ?&gt;<br>
      </code>
      <p>
        This script will not produce any output because the echo statement refers to a local version of the $a variable, and it has not been assigned a value within this scope. You may notice that this is a little bit different from the C language
        in that global variables in C are automatically available to functions unless specifically overridden by a local definition. This can cause some problems in that people may inadvertently change a global variable. In PHP global variables must
        be declared global inside a function if they are going to be used in that function.
      </p>
      <h2>
        The global keyword ¶
      </h2>
      <p>
        First, an example use of global:
      </p>
      <p>
        Example #1 Using global
      </p>
      <code>
        &lt;?php<br>
        $a = 1;<br>
        $b = 2;<br>

        function Sum()<br>
        {<br>
        global $a, $b;<br>

        $b = $a + $b;<br>
        }<br>

        Sum();<br>
        echo $b;<br>
        ?&gt;<br>
      </code>
      <p>
        The above script will output 3. By declaring $a and $b global within the function, all references to either variable will refer to the global version. There is no limit to the number of global variables that can be manipulated by a function.
      </p>
      <p>
        A second way to access variables from the global scope is to use the special PHP-defined $GLOBALS array. The previous example can be rewritten as:
      </p>
      <p>
        Example #2 Using $GLOBALS instead of global
      </p>
      <code>
        &lt;?php<br>
        $a = 1;<br>
        $b = 2;<br>

        function Sum()<br>
        {<br>
        $GLOBALS['b'] = $GLOBALS['a'] + $GLOBALS['b'];<br>
        }<br>

        Sum();<br>
        echo $b;<br>
        ?&gt;<br>
      </code>
      <p>
        The $GLOBALS array is an associative array with the name of the global variable being the key and the contents of that variable being the value of the array element. Notice how $GLOBALS exists in any scope, this is because $GLOBALS is a
        superglobal. Here's an example demonstrating the power of superglobals:
      </p>
      <p>
        Example #3 Example demonstrating superglobals and scope
      </p>
      <code>
        &lt;?php<br>
        function test_global()<br>
        {<br>
        // Most predefined variables aren't "super" and require<br>
        // 'global' to be available to the functions local scope.<br>
        global $HTTP_POST_VARS;<br>

        echo $HTTP_POST_VARS['name'];<br>

        // Superglobals are available in any scope and do<br>
        // not require 'global'. Superglobals are available<br>
        // as of PHP 4.1.0, and HTTP_POST_VARS is now<br>
        // deemed deprecated.<br>
        echo $_POST['name'];<br>
        }<br>
        ?&gt;<br>
      </code>
      <p class="note-comment">
        Note:
        Using global keyword outside a function is not an error. It can be used if the file is included from inside a function.
      </p>
      <h2>
        Using static variables ¶
      </h2>
      <p>
        Another important feature of variable scoping is the static variable. A static variable exists only in a local function scope, but it does not lose its value when program execution leaves this scope. Consider the following example:
      </p>
      <p>
        Example #4 Example demonstrating need for static variables
      </p>
      <code>&lt;?php<br>
        function test()<br>
        {<br>
        $a = 0;<br>
        echo $a;<br>
        $a++;<br>
        }<br>
        ?&gt;<br>
      </code>
      <p>
        This function is quite useless since every time it is called it sets $a to 0 and prints 0. The $a++ which increments the variable serves no purpose since as soon as the function exits the $a variable disappears. To make a useful counting
        function which will not lose track of the current count, the $a variable is declared static:
      </p>
      <p>
        Example #5 Example use of static variables
      </p>
      <code>
        &lt;?php<br>
        function test()<br>
        {<br>
        static $a = 0;<br>
        echo $a;<br>
        $a++;<br>
        }<br>
        ?&gt;<br>
      </code>
      <p>
        Now, $a is initialized only in first call of function and every time the test() function is called it will print the value of $a and increment it.
      </p>
      <p>
        Static variables also provide one way to deal with recursive functions. A recursive function is one which calls itself. Care must be taken when writing a recursive function because it is possible to make it recurse indefinitely. You must
        make sure you have an adequate way of terminating the recursion. The following simple function recursively counts to 10, using the static variable $count to know when to stop:
      </p>
      <p>
        Example #6 Static variables with recursive functions
      </p>
      <code>
        &lt;?php<br>
        function test()<br>
        {<br>
        static $count = 0;<br>

        $count++;<br>
        echo $count;<br>
        if ($count < 10) {<br>
          test();<br>
          }<br>
          $count--;<br>
          }<br>
          ?&gt;<br>
      </code>
      <p class="note-comment">
        Note:
        Static variables may be declared as seen in the examples above. From PHP 5.6 you can assign values to these variables which are the result of expressions, but you can't use any function here, what will cause a parse error.
      </p>
      <p>
        Example #7 Declaring static variables
      </p>
      <code>
        &lt;?php <br>
        function foo(){ <br>
        static $int = 0; // correct <br>
        static $int = 1+2; // correct (as of PHP 5.6) <br>
        static $int = sqrt(121); // wrong (as it is a function) <br>

        $int++; <br>
        echo $int; <br>
        } <br>
        ?&gt; <br>
      </code>
      <p class="note-comment">
        Note:
        Static declarations are resolved in compile-time.
      </p>
      <h2>
        References with global and static variables ¶
      </h2>
      <p>
        The Zend Engine 1, driving PHP 4, implements the static and global modifier for variables in terms of references. For example, a true global variable imported inside a function scope with the global statement actually creates a reference to
        the global variable. This can lead to unexpected behaviour which the following example addresses:
      </p>
      <code>
        &lt;?php <br>
        function test_global_ref() { <br>
        global $obj; <br>
        $obj = &new stdclass; <br>
        } <br>

        function test_global_noref() { <br>
        global $obj; <br>
        $obj = new stdclass; <br>
        } <br>

        test_global_ref(); <br>
        var_dump($obj); <br>
        test_global_noref(); <br>
        var_dump($obj); <br>
        ?&gt; <br>
      </code>
      <p>
        The above example will output:
      </p>
      <code>
        NULL<br>
        object(stdClass)(0) {<br>
        }<br>
      </code>
      <p>
        A similar behaviour applies to the static statement. References are not stored statically:
      </p>
      <code>
        &lt;?php<br>
        function &get_instance_ref() {<br>
        static $obj;<br>

        echo 'Static object: ';<br>
        var_dump($obj);<br>
        if (!isset($obj)) {<br>
        // Assign a reference to the static variable<br>
        $obj = &new stdclass;<br>
        }<br>
        $obj->property++;<br>
        return $obj;<br>
        }<br>

        function &get_instance_noref() {<br>
        static $obj;<br>

        echo 'Static object: ';<br>
        var_dump($obj);<br>
        if (!isset($obj)) {<br>
        // Assign the object to the static variable<br>
        $obj = new stdclass;<br>
        }<br>
        $obj->property++;<br>
        return $obj;<br>
        }<br>

        $obj1 = get_instance_ref();<br>
        $still_obj1 = get_instance_ref();<br>
        echo "\n";<br>
        $obj2 = get_instance_noref();<br>
        $still_obj2 = get_instance_noref();<br>
        ?&gt;<br>
      </code>
      <p>
        The above example will output:
      </p>

      <code>
        Static object: NULL<br>
        Static object: NULL<br>

        Static object: NULL<br>
        Static object: object(stdClass)(1) {<br>
        ["property"]=><br>
        int(1)<br>
        }<br>
      </code>
      <p>
        This example demonstrates that when assigning a reference to a static variable, it's not remembered when you call the &get_instance_ref() function a second time.
      </p>
    </section>


    <section class="main-section" id="Variable_variables">
      <header>Variable variables</header>
      <p>
        Sometimes it is convenient to be able to have variable variable names. That is, a variable name which can be set and used dynamically. A normal variable is set with a statement such as:
      </p>
      <code>
        &lt;?php<br>
        $a = 'hello';<br>
        ?&gt;<br>
      </code>
      <p>
        A variable variable takes the value of a variable and treats that as the name of a variable. In the above example, hello, can be used as the name of a variable by using two dollar signs. i.e.
      </p>
      <code>
        &lt;?php<br>
        $$a = 'world';<br>
        ?&gt;<br>
      </code>
      <p>
        At this point two variables have been defined and stored in the PHP symbol tree: $a with contents "hello" and $hello with contents "world". Therefore, this statement:
      </p>
      <code>
        &lt;?php<br>
        echo "$a ${$a}";<br>
        ?&gt;<br>
      </code>
      <p>
        produces the exact same output as:
      </p>
      <code>
        &lt;?php<br>
        echo "$a $hello";<br>
        ?&gt;<br>
      </code>
      <p>
        i.e. they both produce: hello world.
      </p>
      <p>
        In order to use variable variables with arrays, you have to resolve an ambiguity problem. That is, if you write $$a[1] then the parser needs to know if you meant to use $a[1] as a variable, or if you wanted $$a as the variable and then the
        [1] index from that variable. The syntax for resolving this ambiguity is: ${$a[1]} for the first case and ${$a}[1] for the second.
      </p>
      <p>
        Class properties may also be accessed using variable property names. The variable property name will be resolved within the scope from which the call is made. For instance, if you have an expression such as $foo->$bar, then the local scope
        will be examined for $bar and its value will be used as the name of the property of $foo. This is also true if $bar is an array access.
      </p>
      <div class="note-comment">
        <h3>
          Caution
        </h3>
        Further dereferencing a variable property that is an array has different semantics between PHP 5 and PHP 7. The PHP 7.0 migration guide includes further details on the types of expressions that have changed, and how to place curly braces to
        avoid ambiguity.
      </div>
      <p>
        Curly braces may also be used, to clearly delimit the property name. They are most useful when accessing values within a property that contains an array, when the property name is made of mulitple parts, or when the property name contains
        characters that are not otherwise valid (e.g. from json_decode() or SimpleXML).
      </p>
      <p>
        Example #1 Variable property example
      </p>
      <code>
        &lt;?php<br>
        class foo {<br>
        var $bar = 'I am bar.';<br>
        var $arr = array('I am A.', 'I am B.', 'I am C.');<br>
        var $r = 'I am r.';<br>
        }<br>

        $foo = new foo();<br>
        $bar = 'bar';<br>
        $baz = array('foo', 'bar', 'baz', 'quux');<br>
        echo $foo->$bar . "\n";<br>
        echo $foo->{$baz[1]} . "\n";<br>

        $start = 'b';<br>
        $end = 'ar';<br>
        echo $foo->{$start . $end} . "\n";<br>

        $arr = 'arr';<br>
        echo $foo->{$arr[1]} . "\n";<br>

        ?&gt;<br>
      </code>
      <p>
        The above example will output:
      </p>
      <code>
        I am bar.
        I am bar.
        I am bar.
        I am r.
      </code>
    </section>


    <section class="main-section" id="Variables_From_External_Sources">
      <header>Variables From External Sources</header>
<p>
      When a form is submitted to a PHP script, the information from that form is automatically made available to the script. There are few ways to access this information, for example:
    </p>
<p>
      Example #1 A simple HTML form
    </p>
    <code>
      &lt;form action="foo.php" method="post"&gt;<br />
      Name: &lt;input type="text" name="username" /&gt;&lt;br /&gt;<br />
      Email: &lt;input type="text" name="email" /&gt;&lt;br /&gt;<br />
      &lt;input type="submit" name="submit" value="Submit me!" /&gt;<br />
      &lt;/form&gt;
    </code>
      <p>
      As of PHP 5.4.0, there are only two ways to access data from your HTML forms. Currently available methods are listed below:
      </p>
<p>
      Example #2 Accessing data from a simple POST HTML form
    </p>
      <code>
        &lt;?php <br>
        echo $_POST['username']; <br>
        echo $_REQUEST['username']; <br>
        ?&gt; <br>
      </code>
<p>
      There were some other ways of accessing user input in old PHP versions. These are listed below. See changelog at the bottom of the page for more details.
    </p>
<p>
      Example #3 Old methods of accessing user input
    </p>
      <code>
        &lt;?php<br>
        // WATCH OUT: these methods ARE NOT supported anymore.<br>
        // Valid ones were described above.<br>

        // Using import_request_variables() - this function has been removed in PHP 5.4.0<br>
        import_request_variables('p', 'p_');<br>
        echo $p_username;<br>

        // These long predefined variables were removed in PHP 5.4.0<br>
        echo $HTTP_POST_VARS['username'];<br>

        // Using register_globals. This feature was removed in PHP 5.4.0<br>
        echo $username;<br>
        ?&gt;<br>
      </code>
<p>
      Using a GET form is similar except you'll use the appropriate GET predefined variable instead. GET also applies to the QUERY_STRING (the information after the '?' in a URL). So, for example, http://www.example.com/test.php?id=3 contains GET
      data which is accessible with $_GET['id']. See also $_REQUEST.
    </p>
      <p class="note-comment">
      Note:
      Dots and spaces in variable names are converted to underscores. For example <input name="a.b" /> becomes $_REQUEST["a_b"].
    </p>
<p>
      PHP also understands arrays in the context of form variables (see the related faq). You may, for example, group related variables together, or use this feature to retrieve values from a multiple select input. For example, let's post a form to
      itself and upon submission display the data:
    </p>
<p>
      Example #4 More complex form variables
    </p>
      <code>
        &lt;?php<br>
        if ($_POST) {<br>
        echo '&lt;pre&gt;';<br>
        echo htmlspecialchars(print_r($_POST, true));<br>
        echo '&lt;/pre&gt;';<br>
      }<br>
        ?&gt;<br>
      </code>
      <code>
      &lt;form action="" method="post"&gt;<br />
      Name: &lt;input type="text" name="personal[name]" /&gt;&lt;br /&gt;<br />
      Email: &lt;input type="text" name="personal[email]" /&gt;&lt;br /&gt;<br />
      Beer: &lt;br /&gt;<br />&lt;select multiple name="beer[]"&gt;<br />
      &lt;option value="warthog"&gt;Warthog&lt;/option&gt;<br />
      &lt;option value="guinness"&gt;Guinness&lt;/option&gt;<br />
      &lt;option value="stuttgarter"&gt;Stuttgarter Schwabenbr&auml;u&lt;/option&gt;<br />
      &lt;/select&gt;&lt;br /&gt;<br />
      &lt;input type="submit" value="submit me!" /&gt;<br />
      &lt;/form&gt;
        <p class="note-comment">
          Note: If an external variable name begins with a valid array syntax, trailing characters are silently ignored. For example, <input name="foo[bar]baz"> becomes $_REQUEST['foo']['bar'].
        </p>
        <h2>
          IMAGE SUBMIT variable names ¶
        </h2>
        <p>
          When submitting a form, it is possible to use an image instead of the standard submit button with a tag like:
        </p>

        &lt; input type="image" src="image.gif" name="sub" /&gt;
      </code>
      <p>
        When the user clicks somewhere on the image, the accompanying form will be transmitted to the server with two additional variables, sub_x and sub_y. These contain the coordinates of the user click within the image. The experienced may note
        that the actual variable names sent by the browser contains a period rather than an underscore, but PHP converts the period to an underscore automatically.
      </p>
      <h2>
        HTTP Cookies ¶
      </h2>
      <p>
        PHP transparently supports HTTP cookies as defined by » RFC 6265. Cookies are a mechanism for storing data in the remote browser and thus tracking or identifying return users. You can set cookies using the setcookie() function. Cookies are
        part of the HTTP header, so the SetCookie function must be called before any output is sent to the browser. This is the same restriction as for the header() function. Cookie data is then available in the appropriate cookie data arrays, such
        as $_COOKIE as well as in $_REQUEST. See the setcookie() manual page for more details and examples.
      </p>
      <p>
        If you wish to assign multiple values to a single cookie variable, you may assign it as an array. For example:
      </p>
      <code>
        &lt;?php<br>
        setcookie("MyCookie[foo]", 'Testing 1', time()+3600);<br>
        setcookie("MyCookie[bar]", 'Testing 2', time()+3600);<br>
        ?&gt;<br>
      </code>
      <p>
        That will create two separate cookies although MyCookie will now be a single array in your script. If you want to set just one cookie with multiple values, consider using serialize() or explode() on the value first.
      </p>
      <p>
        Note that a cookie will replace a previous cookie by the same name in your browser unless the path or domain is different. So, for a shopping cart application you may want to keep a counter and pass this along. i.e.
      </p>
      <p>
        Example #5 A setcookie() example
      </p>
      <code>
        &lt;?php<br>
        if (isset($_COOKIE['count'])) {<br>
        $count = $_COOKIE['count'] + 1;<br>
        } else {<br>
        $count = 1;<br>
        }<br>
        setcookie('count', $count, time()+3600);<br>
        setcookie("Cart[$count]", $item, time()+3600);<br>
        ?&gt;<br>
      </code>
      <h2>
        Dots in incoming variable names ¶
      </h2>
      <p>
        Typically, PHP does not alter the names of variables when they are passed into a script. However, it should be noted that the dot (period, full stop) is not a valid character in a PHP variable name. For the reason, look at it:
      </p>
      <code>
        &lt;?php<br>
        $varname.ext; /* invalid variable name */<br>
        ?&gt;<br>
      </code>
      <p>
        Now, what the parser sees is a variable named $varname, followed by the string concatenation operator, followed by the barestring (i.e. unquoted string which doesn't match any known key or reserved words) 'ext'. Obviously, this doesn't have
        the intended result.
      </p>
      <p>
        For this reason, it is important to note that PHP will automatically replace any dots in incoming variable names with underscores.
      </p>
      <h2>
        Determining variable types ¶
      </h2>
      <p>
        Because PHP determines the types of variables and converts them (generally) as needed, it is not always obvious what type a given variable is at any one time. PHP includes several functions which find out what type a variable is, such as:
        gettype(), is_array(), is_float(), is_int(), is_object(), and is_string(). See also the chapter on Types.
      </p>
      <p>
        HTTP being a text protocol, most, if not all, content that comes in Superglobal arrays, like $_POST and $_GET will remain as strings. PHP will not try to convert values to a specific type. In the example below, $_GET["var1"] will contain the
        string "null" and $_GET["var2"], the string "123".
      </p>
      <p>
        /index.php?var1=null&var2=123
      </p>
    </section>




    <h1 id="Constants"> Constants </h1>
    <section class="main-section" id="Syntax">
      <header>Syntax</header>

      You can define a constant by using the define()-function or by using the const keyword outside a class definition as of PHP 5.3.0. While define() allows a constant to be defined to an arbitrary expression, the const keyword has restrictions as outlined in the next paragraph. Once a constant is defined, it can never be changed or undefined.

      When using the const keyword, only scalar data (boolean, integer, float and string) can be contained in constants prior to PHP 5.6. From PHP 5.6 onwards, it is possible to define a constant as a scalar expression, and it is also possible to define an array constant. It is possible to define constants as a resource, but it should be avoided, as it can cause unexpected results.

      You can get the value of a constant by simply specifying its name. Unlike with variables, you should not prepend a constant with a $. You can also use the function constant() to read a constant's value if you wish to obtain the constant's name dynamically. Use get_defined_constants() to get a list of all defined constants.

      Note: Constants and (global) variables are in a different namespace. This implies that for example TRUE and $TRUE are generally different.

      If you use an undefined constant, PHP assumes that you mean the name of the constant itself, just as if you called it as a string (CONSTANT vs "CONSTANT"). This fallback is deprecated as of PHP 7.2.0, and an error of level E_WARNING is issued when it happens (previously, an error of level E_NOTICE has been issued instead.) See also the manual entry on why $foo[bar] is wrong (unless you first define() bar as a constant). This does not apply to (fully) qualified constants, which will raise a fatal error if undefined. If you simply want to check if a constant is set, use the defined() function.

      These are the differences between constants and variables:

      Constants do not have a dollar sign ($) before them;
      Prior to PHP 5.3, Constants may only be defined using the define() function, not by simple assignment;
      Constants may be defined and accessed anywhere without regard to variable scoping rules;
      Constants may not be redefined or undefined once they have been set; and
      Constants may only evaluate to scalar values. As of PHP 5.6 it is possible to define array constant using const keywords and as of PHP 7 array constants can also be defined using define() You may use arrays in constant scalar expressions (for example, const FOO = array(1,2,3)[0];), but the end result must be a value of allowed type.

      Example #1 Defining Constants
      <code>&lt;?php
      define("CONSTANT", "Hello world.");
      echo CONSTANT; // outputs "Hello world."
      echo Constant; // outputs "Constant" and issues a notice.
      ?&gt;</code>

      Example #2 Defining Constants using the const keyword
      <code>&lt;?php
      // Works as of PHP 5.3.0
      const CONSTANT = 'Hello World';

      echo CONSTANT;

      // Works as of PHP 5.6.0
      const ANOTHER_CONST = CONSTANT.'; Goodbye World';
      echo ANOTHER_CONST;

      const ANIMALS = array('dog', 'cat', 'bird');
      echo ANIMALS[1]; // outputs "cat"

      // Works as of PHP 7
      define('ANIMALS', array(
      'dog',
      'cat',
      'bird'
      ));
      echo ANIMALS[1]; // outputs "cat"
      ?&gt;</code>

      Note:

      As opposed to defining constants using define(), constants defined using the const keyword must be declared at the top-level scope because they are defined at compile-time. This means that they cannot be declared inside functions, loops, if statements or try/ catch blocks.

      Note:

      Constants defined using the const keyword are always case-sensitive, while constants defined using define() may be case-insensitive.

    </section>


    <section class="main-section" id="Magic_constants">
      <header>Magic constants</header>
      PHP provides a large number of predefined constants to any script which it runs. Many of these constants, however, are created by various extensions, and will only be present when those extensions are available, either via dynamic loading or because they have been compiled in.

      There are nine magical constants that change depending on where they are used. For example, the value of __LINE__ depends on the line that it's used on in your script. All these "magical" constants are resolved at compile time, unlike regular constants, which are resolved at runtime. These special constants are case-insensitive and are as follows:

      A few "magical" PHP constants Name 	Description
      __LINE__ 	The current line number of the file.
      __FILE__ 	The full path and filename of the file with symlinks resolved. If used inside an include, the name of the included file is returned.
      __DIR__ 	The directory of the file. If used inside an include, the directory of the included file is returned. This is equivalent to dirname(__FILE__). This directory name does not have a trailing slash unless it is the root directory.
      __FUNCTION__ 	The function name, or {closure} for anonymous functions.
      __CLASS__ 	The class name. The class name includes the namespace it was declared in (e.g. Foo\Bar). Note that as of PHP 5.4 __CLASS__ works also in traits. When used in a trait method, __CLASS__ is the name of the class the trait is used in.
      __TRAIT__ 	The trait name. The trait name includes the namespace it was declared in (e.g. Foo\Bar).
      __METHOD__ 	The class method name.
      __NAMESPACE__ 	The name of the current namespace.
      ClassName::class 	The fully qualified class name. See also ::class.
    </section>





    <h1 id="Expressions"> Expressions </h1>
    <section class="main-section" id="Expression">
      <header>Expression</header>
      Expressions are the most important building blocks of PHP. In PHP, almost anything you write is an expression. The simplest yet most accurate way to define an expression is "anything that has a value".

      The most basic forms of expressions are constants and variables. When you type "$a = 5", you're assigning '5' into $a. '5', obviously, has the value 5, or in other words '5' is an expression with the value of 5 (in this case, '5' is an integer constant).

      After this assignment, you'd expect $a's value to be 5 as well, so if you wrote $b = $a, you'd expect it to behave just as if you wrote $b = 5. In other words, $a is an expression with the value of 5 as well. If everything works right, this is exactly what will happen.

      Slightly more complex examples for expressions are functions. For instance, consider the following function:
      <code>&lt;?php
      function foo ()
      {
      return 5;
      }
      ?&gt;</code>

      Assuming you're familiar with the concept of functions (if you're not, take a look at the chapter about functions), you'd assume that typing $c = foo() is essentially just like writing $c = 5, and you're right. Functions are expressions with the value of their return value. Since foo() returns 5, the value of the expression 'foo()' is 5. Usually functions don't just return a static value but compute something.

      Of course, values in PHP don't have to be integers, and very often they aren't. PHP supports four scalar value types: integer values, floating point values (float), string values and boolean values (scalar values are values that you can't 'break' into smaller pieces, unlike arrays, for instance). PHP also supports two composite (non-scalar) types: arrays and objects. Each of these value types can be assigned into variables or returned from functions.

      PHP takes expressions much further, in the same way many other languages do. PHP is an expression-oriented language, in the sense that almost everything is an expression. Consider the example we've already dealt with, '$a = 5'. It's easy to see that there are two values involved here, the value of the integer constant '5', and the value of $a which is being updated to 5 as well. But the truth is that there's one additional value involved here, and that's the value of the assignment itself. The assignment itself evaluates to the assigned value, in this case 5. In practice, it means that '$a = 5', regardless of what it does, is an expression with the value 5. Thus, writing something like '$b = ($a = 5)' is like writing '$a = 5; $b = 5;' (a semicolon marks the end of a statement). Since assignments are parsed in a right to left order, you can also write '$b = $a = 5'.

      Another good example of expression orientation is pre- and post-increment and decrement. Users of PHP and many other languages may be familiar with the notation of variable++ and variable--. These are increment and decrement operators. In PHP, like in C, there are two types of increment - pre-increment and post-increment. Both pre-increment and post-increment essentially increment the variable, and the effect on the variable is identical. The difference is with the value of the increment expression. Pre-increment, which is written '++$variable', evaluates to the incremented value (PHP increments the variable before reading its value, thus the name 'pre-increment'). Post-increment, which is written '$variable++' evaluates to the original value of $variable, before it was incremented (PHP increments the variable after reading its value, thus the name 'post-increment').

      A very common type of expressions are comparison expressions. These expressions evaluate to either FALSE or TRUE. PHP supports > (bigger than), >= (bigger than or equal to), == (equal), != (not equal), < (smaller than) and <= (smaller than or equal to). The language also supports a set of strict equivalence operators: === (equal to and same type) and !== (not equal to or not same type). These expressions are most commonly used inside conditional execution, such as if statements.

      The last example of expressions we'll deal with here is combined operator-assignment expressions. You already know that if you want to increment $a by 1, you can simply write '$a++' or '++$a'. But what if you want to add more than one to it, for instance 3? You could write '$a++' multiple times, but this is obviously not a very efficient or comfortable way. A much more common practice is to write '$a = $a + 3'. '$a + 3' evaluates to the value of $a plus 3, and is assigned back into $a, which results in incrementing $a by 3. In PHP, as in several other languages like C, you can write this in a shorter way, which with time would become clearer and quicker to understand as well. Adding 3 to the current value of $a can be written '$a += 3'. This means exactly "take the value of $a, add 3 to it, and assign it back into $a". In addition to being shorter and clearer, this also results in faster execution. The value of '$a += 3', like the value of a regular assignment, is the assigned value. Notice that it is NOT 3, but the combined value of $a plus 3 (this is the value that's assigned into $a). Any two-place operator can be used in this operator-assignment mode, for example '$a -= 5' (subtract 5 from the value of $a), '$b *= 7' (multiply the value of $b by 7), etc.

      There is one more expression that may seem odd if you haven't seen it in other languages, the ternary conditional operator:

      <code>&lt;?php
      $first ? $second : $third
      ?&gt;</code>

      If the value of the first subexpression is TRUE (non-zero), then the second subexpression is evaluated, and that is the result of the conditional expression. Otherwise, the third subexpression is evaluated, and that is the value.

      The following example should help you understand pre- and post-increment and expressions in general a bit better:

      <code>&lt;?php
      function double($i)
      {
      return $i*2;
      }
      $b = $a = 5;        /* assign the value five into the variable $a and $b */
      $c = $a++;          /* post-increment, assign original value of $a
                  (5) to $c */
      $e = $d = ++$b;     /* pre-increment, assign the incremented value of
                  $b (6) to $d and $e */

      /* at this point, both $d and $e are equal to 6 */

      $f = double($d++);  /* assign twice the value of $d before
                  the increment, 2*6 = 12 to $f */
      $g = double(++$e);  /* assign twice the value of $e after
                  the increment, 2*7 = 14 to $g */
      $h = $g += 10;      /* first, $g is incremented by 10 and ends with the
                  value of 24. the value of the assignment (24) is
                  then assigned into $h, and $h ends with the value
                  of 24 as well. */
      ?&gt;</code>

      Some expressions can be considered as statements. In this case, a statement has the form of 'expr ;' that is, an expression followed by a semicolon. In '$b = $a = 5;', '$a = 5' is a valid expression, but it's not a statement by itself. '$b = $a = 5;' however is a valid statement.

      One last thing worth mentioning is the truth value of expressions. In many events, mainly in conditional execution and loops, you're not interested in the specific value of the expression, but only care about whether it means TRUE or FALSE. The constants TRUE and FALSE (case-insensitive) are the two possible boolean values. When necessary, an expression is automatically converted to boolean. See the section about type-casting for details about how.

      PHP provides a full and powerful implementation of expressions, and documenting it entirely goes beyond the scope of this manual. The above examples should give you a good idea about what expressions are and how you can construct useful expressions. Throughout the rest of this manual we'll write expr to indicate any valid PHP expression.

    </section>




    <h1 id="operators"> Operators</h1>
    <p>
    An operator is something that takes one or more values (or expressions, in programming jargon) and yields another value (so that the construction itself becomes an expression).
  </p>
  <p>
    Operators can be grouped according to the number of values they take. Unary operators take only one value, for example ! (the logical not operator) or ++ (the increment operator). Binary operators take two values, such as the familiar arithmetical operators + (plus) and - (minus), and the majority of PHP operators fall into this category. Finally, there is a single ternary operator, ? :, which takes three values; this is usually referred to simply as "the ternary operator" (although it could perhaps more properly be called the conditional operator).
  </p>

    <section class="main-section" id="Operator_Precedence">
      <header>Operator Precedence</header>

      The precedence of an operator specifies how "tightly" it binds two expressions together. For example, in the expression 1 + 5 * 3, the answer is 16 and not 18 because the multiplication ("*") operator has a higher precedence than the addition ("+") operator. Parentheses may be used to force precedence, if necessary. For instance: (1 + 5) * 3 evaluates to 18.

      When operators have equal precedence their associativity decides how the operators are grouped. For example "-" is left-associative, so 1 - 2 - 3 is grouped as (1 - 2) - 3 and evaluates to -4. "=" on the other hand is right-associative, so $a = $b = $c is grouped as $a = ($b = $c).

      Operators of equal precedence that are non-associative cannot be used next to each other, for example 1 < 2 > 1 is illegal in PHP. The expression 1 <= 1 == 1 on the other hand is legal, because the == operator has lesser precedence than the <= operator.

      Use of parentheses, even when not strictly necessary, can often increase readability of the code by making grouping explicit rather than relying on the implicit operator precedence and associativity.

      The following table lists the operators in order of precedence, with the highest-precedence ones at the top. Operators on the same line have equal precedence, in which case associativity decides grouping.
      Operator Precedence Associativity 	Operators 	Additional Information
      non-associative 	clone new 	clone and new
      left 	[ 	array()
      right 	** 	arithmetic
      right 	++ -- ~ (int) (float) (string) (array) (object) (bool) @ 	types and increment/decrement
      non-associative 	instanceof 	types
      right 	! 	logical
      left 	* / % 	arithmetic
      left 	+ - . 	arithmetic and string
      left 	<< >> 	bitwise
      non-associative 	< <= > >= 	comparison
      non-associative 	== != === !== <> <=> 	comparison
      left 	& 	bitwise and references
      left 	^ 	bitwise
      left 	| 	bitwise
      left 	&& 	logical
      left 	|| 	logical
      right 	?? 	comparison
      left 	? : 	ternary
      right 	= += -= *= **= /= .= %= &= |= ^= <<= >>= 	assignment
      left 	and 	logical
      left 	xor 	logical
      left 	or 	logical

      Example #1 Associativity
      <code>&lt;?php
        $a = 3 * 3 % 5; // (3 * 3) % 5 = 4
        // ternary operator associativity differs from C/C++
        $a = true ? 0 : true ? 1 : 2; // (true ? 0 : true) ? 1 : 2 = 2

        $a = 1;
        $b = 2;
        $a = $b += 3; // $a = ($b += 3) -> $a = 5, $b = 5
        ?&gt;</code>

        Operator precedence and associativity only determine how expressions are grouped, they do not specify an order of evaluation. PHP does not (in the general case) specify in which order an expression is evaluated and code that assumes a specific order of evaluation should be avoided, because the behavior can change between versions of PHP or depending on the surrounding code.

        Example #2 Undefined order of evaluation
        <code>&lt;?php
          $a = 1;
          echo $a + $a++; // may print either 2 or 3

          $i = 1;
          $array[$i] = $i++; // may set either index 1 or 2
          ?&gt;</code>

          Example #3 +, - and . have the same precedence
          <code>&lt;?php
            $x = 4;
            // this line might result in unexpected output:
            echo "x minus one equals " . $x-1 . ", or so I hope\n";
            // because it is evaluated like this line:
            echo (("x minus one equals " . $x) - 1) . ", or so I hope\n";
            // the desired precendence can be enforced by using parentheses:
            echo "x minus one equals " . ($x-1) . ", or so I hope\n";
            ?&gt;</code>

            The above example will output:

            -1, or so I hope
            -1, or so I hope
            x minus one equals 3, or so I hope

            Note:

            Although = has a lower precedence than most other operators, PHP will still allow expressions similar to the following: if (!$a = foo()), in which case the return value of foo() is put into $a.
    </section>


    <section class="main-section" id="Arithmetic_Operators">
      <header>Arithmetic Operators</header>


      Remember basic arithmetic from school? These work just like those.
      Arithmetic Operators Example 	Name 	Result
      +$a 	Identity 	Conversion of $a to int or float as appropriate.
      -$a 	Negation 	Opposite of $a.
      $a + $b 	Addition 	Sum of $a and $b.
      $a - $b 	Subtraction 	Difference of $a and $b.
      $a * $b 	Multiplication 	Product of $a and $b.
      $a / $b 	Division 	Quotient of $a and $b.
      $a % $b 	Modulo 	Remainder of $a divided by $b.
      $a ** $b 	Exponentiation 	Result of raising $a to the $b'th power. Introduced in PHP 5.6.

      The division operator ("/") returns a float value unless the two operands are integers (or strings that get converted to integers) and the numbers are evenly divisible, in which case an integer value will be returned. For integer division, see intdiv().

      Operands of modulo are converted to integers (by stripping the decimal part) before processing. For floating-point modulo, see fmod().

      The result of the modulo operator % has the same sign as the dividend — that is, the result of $a % $b will have the same sign as $a. For example:
      <code>&lt;?php

        echo (5 % 3)."\n";           // prints 2
        echo (5 % -3)."\n";          // prints 2
        echo (-5 % 3)."\n";          // prints -2
        echo (-5 % -3)."\n";         // prints -2

        ?&gt;</code>
    </section>


    <section class="main-section" id="Assignment_Operators">
      <header>Assignment Operators</header>
      The basic assignment operator is "=". Your first inclination might be to think of this as "equal to". Don't. It really means that the left operand gets set to the value of the expression on the right (that is, "gets set to").

      The value of an assignment expression is the value assigned. That is, the value of "$a = 3" is 3. This allows you to do some tricky things:
      <code>&lt;?php

        $a = ($b = 4) + 5; // $a is equal to 9 now, and $b has been set to 4.

        ?&gt;</code>

        In addition to the basic assignment operator, there are "combined operators" for all of the binary arithmetic, array union and string operators that allow you to use a value in an expression and then set its value to the result of that expression. For example:
        <code>&lt;?php

          $a = 3;
          $a += 5; // sets $a to 8, as if we had said: $a = $a + 5;
          $b = "Hello ";
          $b .= "There!"; // sets $b to "Hello There!", just like $b = $b . "There!";

          ?&gt;</code>

          Note that the assignment copies the original variable to the new one (assignment by value), so changes to one will not affect the other. This may also have relevance if you need to copy something like a large array inside a tight loop.

          An exception to the usual assignment by value behaviour within PHP occurs with objects, which are assigned by reference. Objects may be explicitly copied via the clone keyword.
          Assignment by Reference ¶

          Assignment by reference is also supported, using the "$var = &amp$othervar;" syntax. Assignment by reference means that both variables end up pointing at the same data, and nothing is copied anywhere.

          Example #1 Assigning by reference
          <code>&lt;?php
            $a = 3;
            $b = &amp$a; // $b is a reference to $a

            print "$a\n"; // prints 3
            print "$b\n"; // prints 3

            $a = 4; // change $a

            print "$a\n"; // prints 4
            print "$b\n"; // prints 4 as well, since $b is a reference to $a, which has
            // been changed
            ?&gt;</code>

            The new operator returns a reference automatically, so assigning the result of new by reference results in an E_DEPRECATED message in PHP 5.3 and later, and an E_STRICT message in earlier versions.

            For example, this code will result in a warning:
            <code>&lt;?php
              class C {}

              /* The following line generates the following error message:
              * Deprecated: Assigning the return value of new by reference is deprecated in...
              */
              $o = &new C;
              ?&gt;</code>

              More information on references and their potential uses can be found in the References Explained section of the manual.
    </section>


    <section class="main-section" id="Bitwise_Operators">
      <header>Bitwise Operators</header>



      Bitwise operators allow evaluation and manipulation of specific bits within an integer.
      Bitwise Operators Example 	Name 	Result
      $a & $b 	And 	Bits that are set in both $a and $b are set.
      $a | $b 	Or (inclusive or) 	Bits that are set in either $a or $b are set.
      $a ^ $b 	Xor (exclusive or) 	Bits that are set in $a or $b but not both are set.
      ~ $a 	Not 	Bits that are set in $a are not set, and vice versa.
      $a << $b 	Shift left 	Shift the bits of $a $b steps to the left (each step means "multiply by two")
      $a >> $b 	Shift right 	Shift the bits of $a $b steps to the right (each step means "divide by two")

      Bit shifting in PHP is arithmetic. Bits shifted off either end are discarded. Left shifts have zeros shifted in on the right while the sign bit is shifted out on the left, meaning the sign of an operand is not preserved. Right shifts have copies of the sign bit shifted in on the left, meaning the sign of an operand is preserved.

      Use parentheses to ensure the desired precedence. For example, $a & $b == true evaluates the equivalency then the bitwise and; while ($a & $b) == true evaluates the bitwise and then the equivalency.

      If both operands for the &, | and ^ operators are strings, then the operation will be performed on the ASCII values of the characters that make up the strings and the result will be a string. In all other cases, both operands will be converted to integers and the result will be an integer.

      If the operand for the ~ operator is a string, the operation will be performed on the ASCII values of the characters that make up the string and the result will be a string, otherwise the operand and the result will be treated as integers.

      Both operands and the result for the << and >> operators are always treated as integers.

      PHP's error_reporting ini setting uses bitwise values,
      providing a real-world demonstration of turning
      bits off. To show all errors, except for notices,
      the php.ini file instructions say to use:
      E_ALL & ~E_NOTICE


      This works by starting with E_ALL:
      00000000000000000111011111111111
      Then taking the value of E_NOTICE...
      00000000000000000000000000001000
      ... and inverting it via ~:
      11111111111111111111111111110111
      Finally, it uses AND (&) to find the bits turned
      on in both values:
      00000000000000000111011111110111


      Another way to accomplish that is using XOR (^)
      to find bits that are on in only one value or the other:
      E_ALL ^ E_NOTICE


      error_reporting can also be used to demonstrate turning bits on.
      The way to show just errors and recoverable errors is:
      E_ERROR | E_RECOVERABLE_ERROR


      This process combines E_ERROR
      00000000000000000000000000000001
      and
      00000000000000000001000000000000
      using the OR (|) operator
      to get the bits turned on in either value:
      00000000000000000001000000000001


      Example #1 Bitwise AND, OR and XOR operations on integers
      <code>&lt;?php
      /*
      * Ignore the top section,
      * it is just formatting to make output clearer.
      */

      $format = '(%1$2d = %1$04b) = (%2$2d = %2$04b)'
      . ' %3$s (%4$2d = %4$04b)' . "\n";

      echo &lt;&lt;&lt;EOH
      ---------     ---------  -- ---------
      result        value      op test
      ---------     ---------  -- ---------
      EOH;


      /*
      * Here are the examples.
      */

      $values = array(0, 1, 2, 4, 8);
      $test = 1 + 4;

      echo "\n Bitwise AND \n";
      foreach ($values as $value) {
      $result = $value & $test;
      printf($format, $result, $value, '&', $test);
      }

      echo "\n Bitwise Inclusive OR \n";
      foreach ($values as $value) {
      $result = $value | $test;
      printf($format, $result, $value, '|', $test);
      }

      echo "\n Bitwise Exclusive OR (XOR) \n";
      foreach ($values as $value) {
      $result = $value ^ $test;
      printf($format, $result, $value, '^', $test);
      }
      ?&gt;</code>

      The above example will output:

      ---------     ---------  -- ---------
      result        value      op test
      ---------     ---------  -- ---------
      Bitwise AND
      ( 0 = 0000) = ( 0 = 0000) & ( 5 = 0101)
      ( 1 = 0001) = ( 1 = 0001) & ( 5 = 0101)
      ( 0 = 0000) = ( 2 = 0010) & ( 5 = 0101)
      ( 4 = 0100) = ( 4 = 0100) & ( 5 = 0101)
      ( 0 = 0000) = ( 8 = 1000) & ( 5 = 0101)

      Bitwise Inclusive OR
      ( 5 = 0101) = ( 0 = 0000) | ( 5 = 0101)
      ( 5 = 0101) = ( 1 = 0001) | ( 5 = 0101)
      ( 7 = 0111) = ( 2 = 0010) | ( 5 = 0101)
      ( 5 = 0101) = ( 4 = 0100) | ( 5 = 0101)
      (13 = 1101) = ( 8 = 1000) | ( 5 = 0101)

      Bitwise Exclusive OR (XOR)
      ( 5 = 0101) = ( 0 = 0000) ^ ( 5 = 0101)
      ( 4 = 0100) = ( 1 = 0001) ^ ( 5 = 0101)
      ( 7 = 0111) = ( 2 = 0010) ^ ( 5 = 0101)
      ( 1 = 0001) = ( 4 = 0100) ^ ( 5 = 0101)
      (13 = 1101) = ( 8 = 1000) ^ ( 5 = 0101)

      Example #2 Bitwise XOR operations on strings
      <code>&lt;?php
      echo 12 ^ 9; // Outputs '5'

      echo "12" ^ "9"; // Outputs the Backspace character (ascii 8)
            // ('1' (ascii 49)) ^ ('9' (ascii 57)) = #8

      echo "hallo" ^ "hello"; // Outputs the ascii values #0 #4 #0 #0 #0
                   // 'a' ^ 'e' = #4

      echo 2 ^ "3"; // Outputs 1
         // 2 ^ ((int)"3") == 1

      echo "2" ^ 3; // Outputs 1
         // ((int)"2") ^ 3 == 1
      ?&gt;</code>

      Example #3 Bit shifting on integers
      <code>&lt;?php
      /*
      * Here are the examples.
      */

      echo "\n--- BIT SHIFT RIGHT ON POSITIVE INTEGERS ---\n";

      $val = 4;
      $places = 1;
      $res = $val >> $places;
      p($res, $val, '>>', $places, 'copy of sign bit shifted into left side');

      $val = 4;
      $places = 2;
      $res = $val >> $places;
      p($res, $val, '>>', $places);

      $val = 4;
      $places = 3;
      $res = $val >> $places;
      p($res, $val, '>>', $places, 'bits shift out right side');

      $val = 4;
      $places = 4;
      $res = $val >> $places;
      p($res, $val, '>>', $places, 'same result as above; can not shift beyond 0');


      echo "\n--- BIT SHIFT RIGHT ON NEGATIVE INTEGERS ---\n";

      $val = -4;
      $places = 1;
      $res = $val >> $places;
      p($res, $val, '>>', $places, 'copy of sign bit shifted into left side');

      $val = -4;
      $places = 2;
      $res = $val >> $places;
      p($res, $val, '>>', $places, 'bits shift out right side');

      $val = -4;
      $places = 3;
      $res = $val >> $places;
      p($res, $val, '>>', $places, 'same result as above; can not shift beyond -1');


      echo "\n--- BIT SHIFT LEFT ON POSITIVE INTEGERS ---\n";

      $val = 4;
      $places = 1;
      $res = $val << $places;
      p($res, $val, '<<', $places, 'zeros fill in right side');

      $val = 4;
      $places = (PHP_INT_SIZE * 8) - 4;
      $res = $val << $places;
      p($res, $val, '<<', $places);

      $val = 4;
      $places = (PHP_INT_SIZE * 8) - 3;
      $res = $val << $places;
      p($res, $val, '<<', $places, 'sign bits get shifted out');

      $val = 4;
      $places = (PHP_INT_SIZE * 8) - 2;
      $res = $val << $places;
      p($res, $val, '<<', $places, 'bits shift out left side');


      echo "\n--- BIT SHIFT LEFT ON NEGATIVE INTEGERS ---\n";

      $val = -4;
      $places = 1;
      $res = $val << $places;
      p($res, $val, '<<', $places, 'zeros fill in right side');

      $val = -4;
      $places = (PHP_INT_SIZE * 8) - 3;
      $res = $val << $places;
      p($res, $val, '<<', $places);

      $val = -4;
      $places = (PHP_INT_SIZE * 8) - 2;
      $res = $val << $places;
      p($res, $val, '<<', $places, 'bits shift out left side, including sign bit');


      /*
      * Ignore this bottom section,
      * it is just formatting to make output clearer.
      */

      function p($res, $val, $op, $places, $note = '') {
      $format = '%0' . (PHP_INT_SIZE * 8) . "b\n";

      printf("Expression: %d = %d %s %d\n", $res, $val, $op, $places);

      echo " Decimal:\n";
      printf("  val=%d\n", $val);
      printf("  res=%d\n", $res);

      echo " Binary:\n";
      printf('  val=' . $format, $val);
      printf('  res=' . $format, $res);

      if ($note) {
      echo " NOTE: $note\n";
      }

      echo "\n";
      }
      ?&gt;</code>

      Output of the above example on 32 bit machines:


      --- BIT SHIFT RIGHT ON POSITIVE INTEGERS ---
      Expression: 2 = 4 >> 1
      Decimal:
      val=4
      res=2
      Binary:
      val=00000000000000000000000000000100
      res=00000000000000000000000000000010
      NOTE: copy of sign bit shifted into left side

      Expression: 1 = 4 >> 2
      Decimal:
      val=4
      res=1
      Binary:
      val=00000000000000000000000000000100
      res=00000000000000000000000000000001

      Expression: 0 = 4 >> 3
      Decimal:
      val=4
      res=0
      Binary:
      val=00000000000000000000000000000100
      res=00000000000000000000000000000000
      NOTE: bits shift out right side

      Expression: 0 = 4 >> 4
      Decimal:
      val=4
      res=0
      Binary:
      val=00000000000000000000000000000100
      res=00000000000000000000000000000000
      NOTE: same result as above; can not shift beyond 0


      --- BIT SHIFT RIGHT ON NEGATIVE INTEGERS ---
      Expression: -2 = -4 >> 1
      Decimal:
      val=-4
      res=-2
      Binary:
      val=11111111111111111111111111111100
      res=11111111111111111111111111111110
      NOTE: copy of sign bit shifted into left side

      Expression: -1 = -4 >> 2
      Decimal:
      val=-4
      res=-1
      Binary:
      val=11111111111111111111111111111100
      res=11111111111111111111111111111111
      NOTE: bits shift out right side

      Expression: -1 = -4 >> 3
      Decimal:
      val=-4
      res=-1
      Binary:
      val=11111111111111111111111111111100
      res=11111111111111111111111111111111
      NOTE: same result as above; can not shift beyond -1


      --- BIT SHIFT LEFT ON POSITIVE INTEGERS ---
      Expression: 8 = 4 << 1
      Decimal:
      val=4
      res=8
      Binary:
      val=00000000000000000000000000000100
      res=00000000000000000000000000001000
      NOTE: zeros fill in right side

      Expression: 1073741824 = 4 << 28
      Decimal:
      val=4
      res=1073741824
      Binary:
      val=00000000000000000000000000000100
      res=01000000000000000000000000000000

      Expression: -2147483648 = 4 << 29
      Decimal:
      val=4
      res=-2147483648
      Binary:
      val=00000000000000000000000000000100
      res=10000000000000000000000000000000
      NOTE: sign bits get shifted out

      Expression: 0 = 4 << 30
      Decimal:
      val=4
      res=0
      Binary:
      val=00000000000000000000000000000100
      res=00000000000000000000000000000000
      NOTE: bits shift out left side


      --- BIT SHIFT LEFT ON NEGATIVE INTEGERS ---
      Expression: -8 = -4 << 1
      Decimal:
      val=-4
      res=-8
      Binary:
      val=11111111111111111111111111111100
      res=11111111111111111111111111111000
      NOTE: zeros fill in right side

      Expression: -2147483648 = -4 << 29
      Decimal:
      val=-4
      res=-2147483648
      Binary:
      val=11111111111111111111111111111100
      res=10000000000000000000000000000000

      Expression: 0 = -4 << 30
      Decimal:
      val=-4
      res=0
      Binary:
      val=11111111111111111111111111111100
      res=00000000000000000000000000000000
      NOTE: bits shift out left side, including sign bit

      Output of the above example on 64 bit machines:


      --- BIT SHIFT RIGHT ON POSITIVE INTEGERS ---
      Expression: 2 = 4 >> 1
      Decimal:
      val=4
      res=2
      Binary:
      val=0000000000000000000000000000000000000000000000000000000000000100
      res=0000000000000000000000000000000000000000000000000000000000000010
      NOTE: copy of sign bit shifted into left side

      Expression: 1 = 4 >> 2
      Decimal:
      val=4
      res=1
      Binary:
      val=0000000000000000000000000000000000000000000000000000000000000100
      res=0000000000000000000000000000000000000000000000000000000000000001

      Expression: 0 = 4 >> 3
      Decimal:
      val=4
      res=0
      Binary:
      val=0000000000000000000000000000000000000000000000000000000000000100
      res=0000000000000000000000000000000000000000000000000000000000000000
      NOTE: bits shift out right side

      Expression: 0 = 4 >> 4
      Decimal:
      val=4
      res=0
      Binary:
      val=0000000000000000000000000000000000000000000000000000000000000100
      res=0000000000000000000000000000000000000000000000000000000000000000
      NOTE: same result as above; can not shift beyond 0


      --- BIT SHIFT RIGHT ON NEGATIVE INTEGERS ---
      Expression: -2 = -4 >> 1
      Decimal:
      val=-4
      res=-2
      Binary:
      val=1111111111111111111111111111111111111111111111111111111111111100
      res=1111111111111111111111111111111111111111111111111111111111111110
      NOTE: copy of sign bit shifted into left side

      Expression: -1 = -4 >> 2
      Decimal:
      val=-4
      res=-1
      Binary:
      val=1111111111111111111111111111111111111111111111111111111111111100
      res=1111111111111111111111111111111111111111111111111111111111111111
      NOTE: bits shift out right side

      Expression: -1 = -4 >> 3
      Decimal:
      val=-4
      res=-1
      Binary:
      val=1111111111111111111111111111111111111111111111111111111111111100
      res=1111111111111111111111111111111111111111111111111111111111111111
      NOTE: same result as above; can not shift beyond -1


      --- BIT SHIFT LEFT ON POSITIVE INTEGERS ---
      Expression: 8 = 4 << 1
      Decimal:
      val=4
      res=8
      Binary:
      val=0000000000000000000000000000000000000000000000000000000000000100
      res=0000000000000000000000000000000000000000000000000000000000001000
      NOTE: zeros fill in right side

      Expression: 4611686018427387904 = 4 << 60
      Decimal:
      val=4
      res=4611686018427387904
      Binary:
      val=0000000000000000000000000000000000000000000000000000000000000100
      res=0100000000000000000000000000000000000000000000000000000000000000

      Expression: -9223372036854775808 = 4 << 61
      Decimal:
      val=4
      res=-9223372036854775808
      Binary:
      val=0000000000000000000000000000000000000000000000000000000000000100
      res=1000000000000000000000000000000000000000000000000000000000000000
      NOTE: sign bits get shifted out

      Expression: 0 = 4 << 62
      Decimal:
      val=4
      res=0
      Binary:
      val=0000000000000000000000000000000000000000000000000000000000000100
      res=0000000000000000000000000000000000000000000000000000000000000000
      NOTE: bits shift out left side


      --- BIT SHIFT LEFT ON NEGATIVE INTEGERS ---
      Expression: -8 = -4 << 1
      Decimal:
      val=-4
      res=-8
      Binary:
      val=1111111111111111111111111111111111111111111111111111111111111100
      res=1111111111111111111111111111111111111111111111111111111111111000
      NOTE: zeros fill in right side

      Expression: -9223372036854775808 = -4 << 61
      Decimal:
      val=-4
      res=-9223372036854775808
      Binary:
      val=1111111111111111111111111111111111111111111111111111111111111100
      res=1000000000000000000000000000000000000000000000000000000000000000

      Expression: 0 = -4 << 62
      Decimal:
      val=-4
      res=0
      Binary:
      val=1111111111111111111111111111111111111111111111111111111111111100
      res=0000000000000000000000000000000000000000000000000000000000000000
      NOTE: bits shift out left side, including sign bit

      Warning

      Prior to PHP 7.0, shifting integers by values greater than or equal to the system long integer width, or by negative numbers, results in undefined behavior. In other words, if you're using PHP 5.x, don't shift more than 31 bits on a 32-bit system, and don't shift more than 63 bits on 64-bit system.

      Use functions from the gmp extension for bitwise manipulation on numbers beyond PHP_INT_MAX.

    </section>


    <section class="main-section" id="Comparison_Operators">
      <header>Comparison Operators</header>

      Comparison operators, as their name implies, allow you to compare two values. You may also be interested in viewing the type comparison tables, as they show examples of various type related comparisons.
      Comparison Operators Example 	Name 	Result
      $a == $b 	Equal 	TRUE if $a is equal to $b after type juggling.
      $a === $b 	Identical 	TRUE if $a is equal to $b, and they are of the same type.
      $a != $b 	Not equal 	TRUE if $a is not equal to $b after type juggling.
      $a <> $b 	Not equal 	TRUE if $a is not equal to $b after type juggling.
      $a !== $b 	Not identical 	TRUE if $a is not equal to $b, or they are not of the same type.
      $a < $b 	Less than 	TRUE if $a is strictly less than $b.
      $a > $b 	Greater than 	TRUE if $a is strictly greater than $b.
      $a <= $b 	Less than or equal to 	TRUE if $a is less than or equal to $b.
      $a >= $b 	Greater than or equal to 	TRUE if $a is greater than or equal to $b.
      $a <=> $b 	Spaceship 	An integer less than, equal to, or greater than zero when $a is respectively less than, equal to, or greater than $b. Available as of PHP 7.

      If you compare a number with a string or the comparison involves numerical strings, then each string is converted to a number and the comparison performed numerically. These rules also apply to the switch statement. The type conversion does not take place when the comparison is === or !== as this involves comparing the type as well as the value.
      <code>&lt;?php
      var_dump(0 == "a"); // 0 == 0 -> true
      var_dump("1" == "01"); // 1 == 1 -> true
      var_dump("10" == "1e1"); // 10 == 10 -> true
      var_dump(100 == "1e2"); // 100 == 100 -> true

      switch ("a") {
      case 0:
      echo "0";
      break;
      case "a": // never reached because "a" is already matched with 0
      echo "a";
      break;
      }
      ?&gt;</code>
      <code>&lt;?php
      // Integers
      echo 1 <=> 1; // 0
      echo 1 <=> 2; // -1
      echo 2 <=> 1; // 1

      // Floats
      echo 1.5 <=> 1.5; // 0
      echo 1.5 <=> 2.5; // -1
      echo 2.5 <=> 1.5; // 1

      // Strings
      echo "a" <=> "a"; // 0
      echo "a" <=> "b"; // -1
      echo "b" <=> "a"; // 1

      echo "a" <=> "aa"; // -1
      echo "zz" <=> "aa"; // 1

      // Arrays
      echo [] <=> []; // 0
      echo [1, 2, 3] <=> [1, 2, 3]; // 0
      echo [1, 2, 3] <=> []; // 1
      echo [1, 2, 3] <=> [1, 2, 1]; // 1
      echo [1, 2, 3] <=> [1, 2, 4]; // -1

      // Objects
      $a = (object) ["a" => "b"];
      $b = (object) ["a" => "b"];
      echo $a <=> $b; // 0

      $a = (object) ["a" => "b"];
      $b = (object) ["a" => "c"];
      echo $a <=> $b; // -1

      $a = (object) ["a" => "c"];
      $b = (object) ["a" => "b"];
      echo $a <=> $b; // 1

      // not only values are compared; keys must match
      $a = (object) ["a" => "b"];
      $b = (object) ["b" => "b"];
      echo $a <=> $b; // 1

      ?&gt;</code>

      For various types, comparison is done according to the following table (in order).
      Comparison with Various Types Type of Operand 1 	Type of Operand 2 	Result
      null or string 	string 	Convert NULL to "", numerical or lexical comparison
      bool or null 	anything 	Convert both sides to bool, FALSE < TRUE
      object 	object 	Built-in classes can define its own comparison, different classes are uncomparable, same class see Object Comparison
      string, resource or number 	string, resource or number 	Translate strings and resources to numbers, usual math
      array 	array 	Array with fewer members is smaller, if key from operand 1 is not found in operand 2 then arrays are uncomparable, otherwise - compare value by value (see following example)
      object 	anything 	object is always greater
      array 	anything 	array is always greater

      Example #1 Boolean/null comparison
      <code>&lt;?php
      // Bool and null are compared as bool always
      var_dump(1 == TRUE);  // TRUE - same as (bool)1 == TRUE
      var_dump(0 == FALSE); // TRUE - same as (bool)0 == FALSE
      var_dump(100 < TRUE); // FALSE - same as (bool)100 < TRUE
      var_dump(-10 < FALSE);// FALSE - same as (bool)-10 < FALSE
      var_dump(min(-100, -10, NULL, 10, 100)); // NULL - (bool)NULL < (bool)-100 is FALSE < TRUE
      ?&gt;</code>

      Example #2 Transcription of standard array comparison
      <code>&lt;?php
      // Arrays are compared like this with standard comparison operators
      function standard_array_compare($op1, $op2)
      {
      if (count($op1) < count($op2)) {
      return -1; // $op1 < $op2
      } elseif (count($op1) > count($op2)) {
      return 1; // $op1 > $op2
      }
      foreach ($op1 as $key => $val) {
      if (!array_key_exists($key, $op2)) {
       return null; // uncomparable
      } elseif ($val < $op2[$key]) {
       return -1;
      } elseif ($val > $op2[$key]) {
       return 1;
      }
      }
      return 0; // $op1 == $op2
      }
      ?&gt;</code>

      See also strcasecmp(), strcmp(), Array operators, and the manual section on Types.
      Warning
      Comparison of floating point numbers

      Because of the way floats are represented internally, you should not test two floats for equality.

    </section>


    <section class="main-section" id="Error_Control_Operators">
      <header>Error Control Operators</header>

      PHP supports one error control operator: the at sign (@). When prepended to an expression in PHP, any error messages that might be generated by that expression will be ignored.

      If you have set a custom error handler function with set_error_handler() then it will still get called, but this custom error handler can (and should) call error_reporting() which will return 0 when the call that triggered the error was preceded by an @.

      If the track_errors feature is enabled, any error message generated by the expression will be saved in the variable $php_errormsg. This variable will be overwritten on each error, so check early if you want to use it.

      <code>&lt;?php
      /* Intentional file error */
      $my_file = @file ('non_existent_file') or
      die ("Failed opening file: error was '$php_errormsg'");

      // this works for any expression, not just functions:
      $value = @$cache[$key];
      // will not issue a notice if the index $key doesn't exist.

      ?&gt;</code>

      Note: The @-operator works only on expressions. A simple rule of thumb is: if you can take the value of something, you can prepend the @ operator to it. For instance, you can prepend it to variables, function and include calls, constants, and so forth. You cannot prepend it to function or class definitions, or conditional structures such as if and foreach, and so forth.

      See also error_reporting() and the manual section for Error Handling and Logging functions.
      Warning

      Currently the "@" error-control operator prefix will even disable error reporting for critical errors that will terminate script execution. Among other things, this means that if you use "@" to suppress errors from a certain function and either it isn't available or has been mistyped, the script will die right there with no indication as to why.


    </section>


    <section class="main-section" id="Execution_Operators">
      <header>Execution Operators</header>

      PHP supports one execution operator: backticks (``). Note that these are not single-quotes! PHP will attempt to execute the contents of the backticks as a shell command; the output will be returned (i.e., it won't simply be dumped to output; it can be assigned to a variable). Use of the backtick operator is identical to shell_exec().
      <code>&lt;?php
      $output = `ls -al`;
      echo "<pre>$output</pre>";
      ?&gt;</code>

      Note:

      The backtick operator is disabled when safe mode is enabled or shell_exec() is disabled.

      Note:

      Unlike some other languages, backticks have no special meaning within double-quoted strings.

    </section>


    <section class="main-section" id="Incrementing/Decrementing_Operators">
      <header>Incrementing/Decrementing Operators</header>

      PHP supports C-style pre- and post-increment and decrement operators.

      Note: The increment/decrement operators only affect numbers and strings. Arrays, objects and resources are not affected. Decrementing NULL values has no effect too, but incrementing them results in 1.

      Increment/decrement Operators Example 	Name 	Effect
      ++$a 	Pre-increment 	Increments $a by one, then returns $a.
      $a++ 	Post-increment 	Returns $a, then increments $a by one.
      --$a 	Pre-decrement 	Decrements $a by one, then returns $a.
      $a-- 	Post-decrement 	Returns $a, then decrements $a by one.

      Here's a simple example script:
      <code>&lt;?php
      echo "<h3>Postincrement</h3>";
      $a = 5;
      echo "Should be 5: " . $a++ . "<br />\n";
      echo "Should be 6: " . $a . "<br />\n";

      echo "<h3>Preincrement</h3>";
      $a = 5;
      echo "Should be 6: " . ++$a . "<br />\n";
      echo "Should be 6: " . $a . "<br />\n";

      echo "<h3>Postdecrement</h3>";
      $a = 5;
      echo "Should be 5: " . $a-- . "<br />\n";
      echo "Should be 4: " . $a . "<br />\n";

      echo "<h3>Predecrement</h3>";
      $a = 5;
      echo "Should be 4: " . --$a . "<br />\n";
      echo "Should be 4: " . $a . "<br />\n";
      ?&gt;</code>

      PHP follows Perl's convention when dealing with arithmetic operations on character variables and not C's. For example, in PHP and Perl $a = 'Z'; $a++; turns $a into 'AA', while in C a = 'Z'; a++; turns a into '[' (ASCII value of 'Z' is 90, ASCII value of '[' is 91). Note that character variables can be incremented but not decremented and even so only plain ASCII alphabets and digits (a-z, A-Z and 0-9) are supported. Incrementing/decrementing other character variables has no effect, the original string is unchanged.

      Example #1 Arithmetic Operations on Character Variables
      <code>&lt;?php
      echo '== Alphabets ==' . PHP_EOL;
      $s = 'W';
      for ($n=0; $n<6; $n++) {
      echo ++$s . PHP_EOL;
      }
      // Digit characters behave differently
      echo '== Digits ==' . PHP_EOL;
      $d = 'A8';
      for ($n=0; $n<6; $n++) {
      echo ++$d . PHP_EOL;
      }
      $d = 'A08';
      for ($n=0; $n<6; $n++) {
      echo ++$d . PHP_EOL;
      }
      ?&gt;</code>

      The above example will output:

      == Characters ==
      X
      Y
      Z
      AA
      AB
      AC
      == Digits ==
      A9
      B0
      B1
      B2
      B3
      B4
      A09
      A10
      A11
      A12
      A13
      A14

      Incrementing or decrementing booleans has no effect.


    </section>


    <section class="main-section" id="Logical_Operators">
      <header>Logical Operators</header>

      Logical Operators Example 	Name 	Result
      $a and $b 	And 	TRUE if both $a and $b are TRUE.
      $a or $b 	Or 	TRUE if either $a or $b is TRUE.
      $a xor $b 	Xor 	TRUE if either $a or $b is TRUE, but not both.
      ! $a 	Not 	TRUE if $a is not TRUE.
      $a && $b 	And 	TRUE if both $a and $b are TRUE.
      $a || $b 	Or 	TRUE if either $a or $b is TRUE.

      The reason for the two different variations of "and" and "or" operators is that they operate at different precedences. (See Operator Precedence.)

      Example #1 Logical operators illustrated
      <code>&lt;?php

      // --------------------
      // foo() will never get called as those operators are short-circuit

      $a = (false && foo());
      $b = (true  || foo());
      $c = (false and foo());
      $d = (true  or  foo());

      // --------------------
      // "||" has a greater precedence than "or"

      // The result of the expression (false || true) is assigned to $e
      // Acts like: ($e = (false || true))
      $e = false || true;

      // The constant false is assigned to $f before the "or" operation occurs
      // Acts like: (($f = false) or true)
      $f = false or true;

      var_dump($e, $f);

      // --------------------
      // "&&" has a greater precedence than "and"

      // The result of the expression (true && false) is assigned to $g
      // Acts like: ($g = (true && false))
      $g = true && false;

      // The constant true is assigned to $h before the "and" operation occurs
      // Acts like: (($h = true) and false)
      $h = true and false;

      var_dump($g, $h);
      ?&gt;</code>

      The above example will output something similar to:

      bool(true)
      bool(false)
      bool(false)
      bool(true)


    </section>


    <section class="main-section" id="String_Operators">
      <header>String Operators</header>

      There are two string operators. The first is the concatenation operator ('.'), which returns the concatenation of its right and left arguments. The second is the concatenating assignment operator ('.='), which appends the argument on the right side to the argument on the left side. Please read Assignment Operators for more information.

      <code>&lt;?php
      $a = "Hello ";
      $b = $a . "World!"; // now $b contains "Hello World!"

      $a = "Hello ";
      $a .= "World!";     // now $a contains "Hello World!"
      ?&gt;</code>

    </section>


    <section class="main-section" id="Array_Operators">
      <header>Array Operators</header>

      Array Operators Example 	Name 	Result
      $a + $b 	Union 	Union of $a and $b.
      $a == $b 	Equality 	TRUE if $a and $b have the same key/value pairs.
      $a === $b 	Identity 	TRUE if $a and $b have the same key/value pairs in the same order and of the same types.
      $a != $b 	Inequality 	TRUE if $a is not equal to $b.
      $a <> $b 	Inequality 	TRUE if $a is not equal to $b.
      $a !== $b 	Non-identity 	TRUE if $a is not identical to $b.

      The + operator returns the right-hand array appended to the left-hand array; for keys that exist in both arrays, the elements from the left-hand array will be used, and the matching elements from the right-hand array will be ignored.

      <code>&lt;?php
      $a = array("a" => "apple", "b" => "banana");
      $b = array("a" => "pear", "b" => "strawberry", "c" => "cherry");

      $c = $a + $b; // Union of $a and $b
      echo "Union of \$a and \$b: \n";
      var_dump($c);

      $c = $b + $a; // Union of $b and $a
      echo "Union of \$b and \$a: \n";
      var_dump($c);

      $a += $b; // Union of $a += $b is $a and $b
      echo "Union of \$a += \$b: \n";
      var_dump($a);
      ?&gt;</code>
      When executed, this script will print the following:

      Union of $a and $b:
      array(3) {
      ["a"]=>
      string(5) "apple"
      ["b"]=>
      string(6) "banana"
      ["c"]=>
      string(6) "cherry"
      }
      Union of $b and $a:
      array(3) {
      ["a"]=>
      string(4) "pear"
      ["b"]=>
      string(10) "strawberry"
      ["c"]=>
      string(6) "cherry"
      }
      Union of $a += $b:
      array(3) {
      ["a"]=>
      string(5) "apple"
      ["b"]=>
      string(6) "banana"
      ["c"]=>
      string(6) "cherry"
      }

      Elements of arrays are equal for the comparison if they have the same key and value.

      Example #1 Comparing arrays
      <code>&lt;?php
      $a = array("apple", "banana");
      $b = array(1 => "banana", "0" => "apple");

      var_dump($a == $b); // bool(true)
      var_dump($a === $b); // bool(false)
      ?&gt;</code>

    </section>


    <section class="main-section" id="Type_Operators">
      <header>Type Operators</header>


      instanceof is used to determine whether a PHP variable is an instantiated object of a certain class:

      Example #1 Using instanceof with classes
      <code>&lt;?php
      class MyClass
      {
      }

      class NotMyClass
      {
      }
      $a = new MyClass;

      var_dump($a instanceof MyClass);
      var_dump($a instanceof NotMyClass);
      ?&gt;</code>

      The above example will output:

      bool(true)
      bool(false)

      instanceof can also be used to determine whether a variable is an instantiated object of a class that inherits from a parent class:

      Example #2 Using instanceof with inherited classes
      <code>&lt;?php
      class ParentClass
      {
      }

      class MyClass extends ParentClass
      {
      }

      $a = new MyClass;

      var_dump($a instanceof MyClass);
      var_dump($a instanceof ParentClass);
      ?&gt;</code>

      The above example will output:

      bool(true)
      bool(true)

      To check if an object is not an instanceof a class, the logical not operator can be used.

      Example #3 Using instanceof to check if object is not an instanceof a class
      <code>&lt;?php
      class MyClass
      {
      }

      $a = new MyClass;
      var_dump(!($a instanceof stdClass));
      ?&gt;</code>

      The above example will output:

      bool(true)

      Lastly, instanceof can also be used to determine whether a variable is an instantiated object of a class that implements an interface:

      Example #4 Using instanceof with interfaces
      <code>&lt;?php
      interface MyInterface
      {
      }

      class MyClass implements MyInterface
      {
      }

      $a = new MyClass;

      var_dump($a instanceof MyClass);
      var_dump($a instanceof MyInterface);
      ?&gt;</code>

      The above example will output:

      bool(true)
      bool(true)

      Although instanceof is usually used with a literal classname, it can also be used with another object or a string variable:

      Example #5 Using instanceof with other variables
      <code>&lt;?php
      interface MyInterface
      {
      }

      class MyClass implements MyInterface
      {
      }

      $a = new MyClass;
      $b = new MyClass;
      $c = 'MyClass';
      $d = 'NotMyClass';

      var_dump($a instanceof $b); // $b is an object of class MyClass
      var_dump($a instanceof $c); // $c is a string 'MyClass'
      var_dump($a instanceof $d); // $d is a string 'NotMyClass'
      ?&gt;</code>

      The above example will output:

      bool(true)
      bool(true)
      bool(false)

      instanceof does not throw any error if the variable being tested is not an object, it simply returns FALSE. Constants, however, are not allowed.

      Example #6 Using instanceof to test other variables
      <code>&lt;?php
      $a = 1;
      $b = NULL;
      $c = imagecreate(5, 5);
      var_dump($a instanceof stdClass); // $a is an integer
      var_dump($b instanceof stdClass); // $b is NULL
      var_dump($c instanceof stdClass); // $c is a resource
      var_dump(FALSE instanceof stdClass);
      ?&gt;</code>

      The above example will output:

      bool(false)
      bool(false)
      bool(false)
      PHP Fatal error:  instanceof expects an object instance, constant given

      There are a few pitfalls to be aware of. Before PHP version 5.1.0, instanceof would call __autoload() if the class name did not exist. In addition, if the class was not loaded, a fatal error would occur. This can be worked around by using a dynamic class reference, or a string variable containing the class name:

      Example #7 Avoiding classname lookups and fatal errors with instanceof in PHP 5.0
      <code>&lt;?php
      $d = 'NotMyClass';
      var_dump($a instanceof $d); // no fatal error here
      ?&gt;</code>

      The above example will output:

      bool(false)

      The instanceof operator was introduced in PHP 5. Before this time is_a() was used but is_a() has since been deprecated in favor of instanceof. Note that as of PHP 5.3.0, is_a() is no longer deprecated.

    </section>




    <h1 id="Control_structures"> Control Structures </h1>
    <section class="main-section" id="Control_Structures_Introduction">
      <header>Control Structures Introduction</header>

      The if construct is one of the most important features of many languages, PHP included. It allows for conditional execution of code fragments. PHP features an if structure that is similar to that of C:

      if (expr)
      statement

      As described in the section about expressions, expression is evaluated to its Boolean value. If expression evaluates to TRUE, PHP will execute statement, and if it evaluates to FALSE - it'll ignore it. More information about what values evaluate to FALSE can be found in the 'Converting to boolean' section.

      The following example would display a is bigger than b if $a is bigger than $b:
      <code>&lt;?php
      if ($a > $b)
      echo "a is bigger than b";
      ?&gt;</code>

      Often you'd want to have more than one statement to be executed conditionally. Of course, there's no need to wrap each statement with an if clause. Instead, you can group several statements into a statement group. For example, this code would display a is bigger than b if $a is bigger than $b, and would then assign the value of $a into $b:
      <code>&lt;?php
      if ($a > $b) {
      echo "a is bigger than b";
      $b = $a;
      }
      ?&gt;</code>

      If statements can be nested infinitely within other if statements, which provides you with complete flexibility for conditional execution of the various parts of your program.

    </section>




    <section class="main-section" id="if">
      <header>if</header>

      Often you'd want to execute a statement if a certain condition is met, and a different statement if the condition is not met. This is what else is for. else extends an if statement to execute a statement in case the expression in the if statement evaluates to FALSE. For example, the following code would display a is greater than b if $a is greater than $b, and a is NOT greater than b otherwise:
      <code>&lt;?php
      if ($a > $b) {<br>
      echo "a is greater than b";<br>
    } else {<br>
      echo "a is NOT greater than b";<br>
    }<br>
      ?&gt;<br>
    </code>
      The else statement is only executed if the if expression evaluated to FALSE, and if there were any elseif expressions - only if they evaluated to FALSE as well

    </section>




    <section class="main-section" id="else">
      <header>else</header>
      The else statement is only executed if the if expression evaluated to FALSE, and if there were any elseif expressions - only if they evaluated to FALSE as well
      <code>&lt;?php
      if ($a > $b) {<br>
      echo "a is greater than b";<br>
    } else {<br>
      echo "a is NOT greater than b";<br>
    }<br>
      ?&gt;<br>
    </code>

    </section>




    <section class="main-section" id="elseif/else_if">
      <header>elseif/else if</header>

      elseif, as its name suggests, is a combination of if and else. Like else, it extends an if statement to execute a different statement in case the original if expression evaluates to FALSE. However, unlike else, it will execute that alternative expression only if the elseif conditional expression evaluates to TRUE. For example, the following code would display a is bigger than b, a equal to b or a is smaller than b:
      <code>&lt;?php
      if ($a > $b) {
      echo "a is bigger than b";
      } elseif ($a == $b) {
      echo "a is equal to b";
      } else {
      echo "a is smaller than b";
      }
      ?&gt;</code>

      There may be several elseifs within the same if statement. The first elseif expression (if any) that evaluates to TRUE would be executed. In PHP, you can also write 'else if' (in two words) and the behavior would be identical to the one of 'elseif' (in a single word). The syntactic meaning is slightly different (if you're familiar with C, this is the same behavior) but the bottom line is that both would result in exactly the same behavior.

      The elseif statement is only executed if the preceding if expression and any preceding elseif expressions evaluated to FALSE, and the current elseif expression evaluated to TRUE.

      Note: Note that elseif and else if will only be considered exactly the same when using curly brackets as in the above example. When using a colon to define your if/elseif conditions, you must not separate else if into two words, or PHP will fail with a parse error.

      <code>&lt;?php

      /* Incorrect Method: */
      if ($a > $b):
      echo $a." is greater than ".$b;
      else if ($a == $b): // Will not compile.
      echo "The above line causes a parse error.";
      endif;


      /* Correct Method: */
      if ($a > $b):
      echo $a." is greater than ".$b;
      elseif ($a == $b): // Note the combination of the words.
      echo $a." equals ".$b;
      else:
      echo $a." is neither greater than or equal to ".$b;
      endif;

      ?&gt;</code>


    </section>




    <section class="main-section" id="Alternative_syntax_for_control_structures">
      <header>Alternative syntax for control structures</header>

      PHP offers an alternative syntax for some of its control structures; namely, if, while, for, foreach, and switch. In each case, the basic form of the alternate syntax is to change the opening brace to a colon (:) and the closing brace to endif;, endwhile;, endfor;, endforeach;, or endswitch;, respectively.
      <code>&lt;?php if ($a == 5): ?&gt;</code>
      A is equal to 5
      <code>&lt;?php endif; ?&gt;</code>

      In the above example, the HTML block "A is equal to 5" is nested within an if statement written in the alternative syntax. The HTML block would be displayed only if $a is equal to 5.

      The alternative syntax applies to else and elseif as well. The following is an if structure with elseif and else in the alternative format:
      <code>&lt;?php
      if ($a == 5):
      echo "a equals 5";
      echo "...";
      elseif ($a == 6):
      echo "a equals 6";
      echo "!!!";
      else:
      echo "a is neither 5 nor 6";
      endif;
      ?&gt;</code>

      Note:

      Mixing syntaxes in the same control block is not supported.

      Warning

      Any output (including whitespace) between a switch statement and the first case will result in a syntax error. For example, this is invalid:
      <code>&lt;?php switch ($foo): ?&gt;</code>
      <code>&lt;?php case 1: ?&gt;</code>
      ...
      <code>&lt;?php endswitch ?&gt;</code>

      Whereas this is valid, as the trailing newline after the switch statement is considered part of the closing ?&gt;</code> and hence nothing is output between the switch and case:
      <code>&lt;?php switch ($foo): ?&gt;</code>
      <code>&lt;?php case 1: ?&gt;</code>
      ...
      <code>&lt;?php endswitch ?&gt;</code>

    </section>




    <section class="main-section" id="while">
      <header>while</header>
      while loops are the simplest type of loop in PHP. They behave just like their C counterparts. The basic form of a while statement is:

      while (expr)
      statement

      The meaning of a while statement is simple. It tells PHP to execute the nested statement(s) repeatedly, as long as the while expression evaluates to TRUE. The value of the expression is checked each time at the beginning of the loop, so even if this value changes during the execution of the nested statement(s), execution will not stop until the end of the iteration (each time PHP runs the statements in the loop is one iteration). Sometimes, if the while expression evaluates to FALSE from the very beginning, the nested statement(s) won't even be run once.

      Like with the if statement, you can group multiple statements within the same while loop by surrounding a group of statements with curly braces, or by using the alternate syntax:

      while (expr):
      statement
      ...
      endwhile;

      The following examples are identical, and both print the numbers 1 through 10:
      <code>&lt;?php
      /* example 1 */

      $i = 1;
      while ($i <= 10) {
      echo $i++;  /* the printed value would be
              $i before the increment
              (post-increment) */
      }

      /* example 2 */

      $i = 1;
      while ($i <= 10):
      echo $i;
      $i++;
      endwhile;
      ?&gt;</code>

    </section>


    <section class="main-section" id="do-while">
      <header>do-while</header>
    </section>


    <section class="main-section" id="for">
      <header>for</header>

      for loops are the most complex loops in PHP. They behave like their C counterparts. The syntax of a for loop is:

      for (expr1; expr2; expr3)
      statement

      The first expression (expr1) is evaluated (executed) once unconditionally at the beginning of the loop.

      In the beginning of each iteration, expr2 is evaluated. If it evaluates to TRUE, the loop continues and the nested statement(s) are executed. If it evaluates to FALSE, the execution of the loop ends.

      At the end of each iteration, expr3 is evaluated (executed).

      Each of the expressions can be empty or contain multiple expressions separated by commas. In expr2, all expressions separated by a comma are evaluated but the result is taken from the last part. expr2 being empty means the loop should be run indefinitely (PHP implicitly considers it as TRUE, like C). This may not be as useless as you might think, since often you'd want to end the loop using a conditional break statement instead of using the for truth expression.

      Consider the following examples. All of them display the numbers 1 through 10:
      <code>&lt;?php
      /* example 1 */

      for ($i = 1; $i <= 10; $i++) {
      echo $i;
      }

      /* example 2 */

      for ($i = 1; ; $i++) {
      if ($i > 10) {
      break;
      }
      echo $i;
      }

      /* example 3 */

      $i = 1;
      for (; ; ) {
      if ($i > 10) {
      break;
      }
      echo $i;
      $i++;
      }

      /* example 4 */

      for ($i = 1, $j = 0; $i <= 10; $j += $i, print $i, $i++);
      ?&gt;</code>

      Of course, the first example appears to be the nicest one (or perhaps the fourth), but you may find that being able to use empty expressions in for loops comes in handy in many occasions.

      PHP also supports the alternate "colon syntax" for for loops.

      for (expr1; expr2; expr3):
      statement
      ...
      endfor;

      It's a common thing to many users to iterate through arrays like in the example below.

      <code>&lt;?php
      /*
      * This is an array with some data we want to modify
      * when running through the for loop.
      */
      $people = array(
      array('name' => 'Kalle', 'salt' => 856412),
      array('name' => 'Pierre', 'salt' => 215863)
      );

      for($i = 0; $i < count($people); ++$i) {
      $people[$i]['salt'] = mt_rand(000000, 999999);
      }
      ?&gt;</code>

      The above code can be slow, because the array size is fetched on every iteration. Since the size never changes, the loop be easily optimized by using an intermediate variable to store the size instead of repeatedly calling count():

      <code>&lt;?php
      $people = array(
      array('name' => 'Kalle', 'salt' => 856412),
      array('name' => 'Pierre', 'salt' => 215863)
      );

      for($i = 0, $size = count($people); $i < $size; ++$i) {
      $people[$i]['salt'] = mt_rand(000000, 999999);
      }
      ?&gt;</code>



    </section>


    <section class="main-section" id="foreach">
      <header>foreach</header>


      The foreach construct provides an easy way to iterate over arrays. foreach works only on arrays and objects, and will issue an error when you try to use it on a variable with a different data type or an uninitialized variable. There are two syntaxes:

      foreach (array_expression as $value)
      statement
      foreach (array_expression as $key => $value)
      statement

      The first form loops over the array given by array_expression. On each iteration, the value of the current element is assigned to $value and the internal array pointer is advanced by one (so on the next iteration, you'll be looking at the next element).

      The second form will additionally assign the current element's key to the $key variable on each iteration.

      It is possible to customize object iteration.

      Note:

      In PHP 5, when foreach first starts executing, the internal array pointer is automatically reset to the first element of the array. This means that you do not need to call reset() before a foreach loop.

      As foreach relies on the internal array pointer in PHP 5, changing it within the loop may lead to unexpected behavior.

      In PHP 7, foreach does not use the internal array pointer.

      In order to be able to directly modify array elements within the loop precede $value with &. In that case the value will be assigned by reference.
      <code>&lt;?php
      $arr = array(1, 2, 3, 4);
      foreach ($arr as &amp$value) {
      $value = $value * 2;
      }
      // $arr is now array(2, 4, 6, 8)
      unset($value); // break the reference with the last element
      ?&gt;</code>
      Warning

      Reference of a $value and the last array element remain even after the foreach loop. It is recommended to destroy it by unset(). Otherwise you will experience the following behavior:
      <code>&lt;?php
      $arr = array(1, 2, 3, 4);
      foreach ($arr as &amp$value) {
      $value = $value * 2;
      }
      // $arr is now array(2, 4, 6, 8)

      // without an unset($value), $value is still a reference to the last item: $arr[3]

      foreach ($arr as $key => $value) {
      // $arr[3] will be updated with each value from $arr...
      echo "{$key} => {$value} ";
      print_r($arr);
      }
      // ...until ultimately the second-to-last value is copied onto the last value

      // output:
      // 0 => 2 Array ( [0] => 2, [1] => 4, [2] => 6, [3] => 2 )
      // 1 => 4 Array ( [0] => 2, [1] => 4, [2] => 6, [3] => 4 )
      // 2 => 6 Array ( [0] => 2, [1] => 4, [2] => 6, [3] => 6 )
      // 3 => 6 Array ( [0] => 2, [1] => 4, [2] => 6, [3] => 6 )
      ?&gt;</code>

      Before PHP 5.5.0, referencing $value is only possible if the iterated array can be referenced (i.e. if it is a variable). The following code works only as of PHP 5.5.0:
      <code>&lt;?php
      foreach (array(1, 2, 3, 4) as &amp$value) {
      $value = $value * 2;
      }
      ?&gt;</code>

      Note:

      foreach does not support the ability to suppress error messages using '@'.

      Some more examples to demonstrate usage:
      <code>&lt;?php
      /* foreach example 1: value only */

      $a = array(1, 2, 3, 17);

      foreach ($a as $v) {
      echo "Current value of \$a: $v.\n";
      }

      /* foreach example 2: value (with its manual access notation printed for illustration) */

      $a = array(1, 2, 3, 17);

      $i = 0; /* for illustrative purposes only */

      foreach ($a as $v) {
      echo "\$a[$i] => $v.\n";
      $i++;
      }

      /* foreach example 3: key and value */

      $a = array(
      "one" => 1,
      "two" => 2,
      "three" => 3,
      "seventeen" => 17
      );

      foreach ($a as $k => $v) {
      echo "\$a[$k] => $v.\n";
      }

      /* foreach example 4: multi-dimensional arrays */
      $a = array();
      $a[0][0] = "a";
      $a[0][1] = "b";
      $a[1][0] = "y";
      $a[1][1] = "z";

      foreach ($a as $v1) {
      foreach ($v1 as $v2) {
      echo "$v2\n";
      }
      }

      /* foreach example 5: dynamic arrays */

      foreach (array(1, 2, 3, 4, 5) as $v) {
      echo "$v\n";
      }
      ?&gt;</code>
      Unpacking nested arrays with list() ¶

      (PHP 5 >= 5.5.0, PHP 7)

      PHP 5.5 added the ability to iterate over an array of arrays and unpack the nested array into loop variables by providing a list() as the value.

      For example:
      <code>&lt;?php
      $array = [
      [1, 2],
      [3, 4],
      ];

      foreach ($array as list($a, $b)) {
      // $a contains the first element of the nested array,
      // and $b contains the second element.
      echo "A: $a; B: $b\n";
      }
      ?&gt;</code>

      The above example will output:

      A: 1; B: 2
      A: 3; B: 4

      You can provide fewer elements in the list() than there are in the nested array, in which case the leftover array values will be ignored:
      <code>&lt;?php
      $array = [
      [1, 2],
      [3, 4],
      ];

      foreach ($array as list($a)) {
      // Note that there is no $b here.
      echo "$a\n";
      }
      ?&gt;</code>

      The above example will output:

      1
      3

      A notice will be generated if there aren't enough array elements to fill the list():
      <code>&lt;?php
      $array = [
      [1, 2],
      [3, 4],
      ];

      foreach ($array as list($a, $b, $c)) {
      echo "A: $a; B: $b; C: $c\n";
      }
      ?&gt;</code>

      The above example will output:


      Notice: Undefined offset: 2 in example.php on line 7
      A: 1; B: 2; C:

      Notice: Undefined offset: 2 in example.php on line 7
      A: 3; B: 4; C:



    </section>


    <section class="main-section" id="break">
      <header>break</header>

      break ends execution of the current for, foreach, while, do-while or switch structure.

      break accepts an optional numeric argument which tells it how many nested enclosing structures are to be broken out of. The default value is 1, only the immediate enclosing structure is broken out of.

      <code>&lt;?php
      $arr = array('one', 'two', 'three', 'four', 'stop', 'five');
      foreach ($arr as $val) {
      if ($val == 'stop') {
      break;    /* You could also write 'break 1;' here. */
      }
      echo "$val<br />\n";
      }

      /* Using the optional argument. */

      $i = 0;
      while (++$i) {
      switch ($i) {
      case 5:
       echo "At 5<br />\n";
       break 1;  /* Exit only the switch. */
      case 10:
       echo "At 10; quitting<br />\n";
       break 2;  /* Exit the switch and the while. */
      default:
       break;
      }
      }
      ?&gt;</code>
    </section>


    <section class="main-section" id="continue">
      <header>continue</header>
      continue is used within looping structures to skip the rest of the current loop iteration and continue execution at the condition evaluation and then the beginning of the next iteration.

      Note: In PHP the switch statement is considered a looping structure for the purposes of continue. continue behaves like break (when no arguments are passed). If a switch is inside a loop, continue 2 will continue with the next iteration of the outer loop.

      continue accepts an optional numeric argument which tells it how many levels of enclosing loops it should skip to the end of. The default value is 1, thus skipping to the end of the current loop.

      <code>&lt;?php
      foreach ($arr as $key => $value) {
      if (!($key % 2)) { // skip even members
      continue;
      }
      do_something_odd($value);
      }

      $i = 0;
      while ($i++ < 5) {
      echo "Outer<br />\n";
      while (1) {
      echo "Middle<br />\n";
      while (1) {
       echo "Inner<br />\n";
       continue 3;
      }
      echo "This never gets output.<br />\n";
      }
      echo "Neither does this.<br />\n";
      }
      ?&gt;</code>

      Omitting the semicolon after continue can lead to confusion. Here's an example of what you shouldn't do.

      <code>&lt;?php
      for ($i = 0; $i < 5; ++$i) {
      if ($i == 2)
      continue
      print "$i\n";
      }
      ?&gt;</code>

      One can expect the result to be:

      0
      1
      3
      4

      but, in PHP versions below 5.4.0, this script will output:

      2

      because the entire continue print "$i\n"; is evaluated as a single expression, and so print is called only when $i == 2 is true. (The return value of print is passed to continue as the numeric argument.)


    </section>


    <section class="main-section" id="switch">
      <header>switch</header>


      he switch statement is similar to a series of IF statements on the same expression. In many occasions, you may want to compare the same variable (or expression) with many different values, and execute a different piece of code depending on which value it equals to. This is exactly what the switch statement is for.

      Note: Note that unlike some other languages, the continue statement applies to switch and acts similar to break. If you have a switch inside a loop and wish to continue to the next iteration of the outer loop, use continue 2.

      Note:

      Note that switch/case does loose comparison.

      Changelog Version 	Description
      7.0.0 	Multiple default cases will raise a E_COMPILE_ERROR error.

      The following two examples are two different ways to write the same thing, one using a series of if and elseif statements, and the other using the switch statement:

      Example #1 switch structure
      <code>&lt;?php
      if ($i == 0) {
      echo "i equals 0";
      } elseif ($i == 1) {
      echo "i equals 1";
      } elseif ($i == 2) {
      echo "i equals 2";
      }

      switch ($i) {
      case 0:
      echo "i equals 0";
      break;
      case 1:
      echo "i equals 1";
      break;
      case 2:
      echo "i equals 2";
      break;
      }
      ?&gt;</code>

      Example #2 switch structure allows usage of strings
      <code>&lt;?php
      switch ($i) {
      case "apple":
      echo "i is apple";
      break;
      case "bar":
      echo "i is bar";
      break;
      case "cake":
      echo "i is cake";
      break;
      }
      ?&gt;</code>

      It is important to understand how the switch statement is executed in order to avoid mistakes. The switch statement executes line by line (actually, statement by statement). In the beginning, no code is executed. Only when a case statement is found whose expression evaluates to a value that matches the value of the switch expression does PHP begin to execute the statements. PHP continues to execute the statements until the end of the switch block, or the first time it sees a break statement. If you don't write a break statement at the end of a case's statement list, PHP will go on executing the statements of the following case. For example:
      <code>&lt;?php
      switch ($i) {
      case 0:
      echo "i equals 0";
      case 1:
      echo "i equals 1";
      case 2:
      echo "i equals 2";
      }
      ?&gt;</code>

      Here, if $i is equal to 0, PHP would execute all of the echo statements! If $i is equal to 1, PHP would execute the last two echo statements. You would get the expected behavior ('i equals 2' would be displayed) only if $i is equal to 2. Thus, it is important not to forget break statements (even though you may want to avoid supplying them on purpose under certain circumstances).

      In a switch statement, the condition is evaluated only once and the result is compared to each case statement. In an elseif statement, the condition is evaluated again. If your condition is more complicated than a simple compare and/or is in a tight loop, a switch may be faster.

      The statement list for a case can also be empty, which simply passes control into the statement list for the next case.
      <code>&lt;?php
      switch ($i) {
      case 0:
      case 1:
      case 2:
      echo "i is less than 3 but not negative";
      break;
      case 3:
      echo "i is 3";
      }
      ?&gt;</code>

      A special case is the default case. This case matches anything that wasn't matched by the other cases. For example:
      <code>&lt;?php
      switch ($i) {
      case 0:
      echo "i equals 0";
      break;
      case 1:
      echo "i equals 1";
      break;
      case 2:
      echo "i equals 2";
      break;
      default:
      echo "i is not equal to 0, 1 or 2";
      }
      ?&gt;</code>

      The alternative syntax for control structures is supported with switches. For more information, see Alternative syntax for control structures.
      <code>&lt;?php
      switch ($i):
      case 0:
      echo "i equals 0";
      break;
      case 1:
      echo "i equals 1";
      break;
      case 2:
      echo "i equals 2";
      break;
      default:
      echo "i is not equal to 0, 1 or 2";
      endswitch;
      ?&gt;</code>

      It's possible to use a semicolon instead of a colon after a case like:
      <code>&lt;?php
      switch($beer)
      {
      case 'tuborg';
      case 'carlsberg';
      case 'heineken';
      echo 'Good choice';
      break;
      default;
      echo 'Please make a new selection...';
      break;
      }
      ?&gt;</code>



    </section>


    <section class="main-section" id="declare">
      <header>declare</header>

      he declare construct is used to set execution directives for a block of code. The syntax of declare is similar to the syntax of other flow control constructs:

      declare (directive)
      statement

      The directive section allows the behavior of the declare block to be set. Currently only three directives are recognized: the ticks directive (See below for more information on the ticks directive), the encoding directive (See below for more information on the encoding directive) and the strict_types directive (See for more information the strict section on the Function arguments page)

      Version 	Description
      5.3.0 	Added encoding directive
      7.0.0 	Added strict_types directive

      As directives are handled as the file is being compiled, only literals may be given as directive values. Variables and constants cannot be used. To illustrate:
      <code>&lt;?php
      // This is valid:
      declare(ticks=1);

      // This is invalid:
      const TICK_VALUE = 1;
      declare(ticks=TICK_VALUE);
      ?&gt;</code>

      The statement part of the declare block will be executed - how it is executed and what side effects occur during execution may depend on the directive set in the directive block.

      The declare construct can also be used in the global scope, affecting all code following it (however if the file with declare was included then it does not affect the parent file).
      <code>&lt;?php
      // these are the same:

      // you can use this:
      declare(ticks=1) {
      // entire script here
      }

      // or you can use this:
      declare(ticks=1);
      // entire script here
      ?&gt;</code>
      Ticks ¶

      A tick is an event that occurs for every N low-level tickable statements executed by the parser within the declare block. The value for N is specified using ticks=N within the declare block's directive section.

      Not all statements are tickable. Typically, condition expressions and argument expressions are not tickable.

      The event(s) that occur on each tick are specified using the register_tick_function(). See the example below for more details. Note that more than one event can occur for each tick.

      Example #1 Tick usage example
      <code>&lt;?php

      declare(ticks=1);

      // A function called on each tick event
      function tick_handler()
      {
      echo "tick_handler() called\n";
      }

      register_tick_function('tick_handler');

      $a = 1;

      if ($a > 0) {
      $a += 2;
      print($a);
      }

      ?&gt;</code>

      Example #2 Ticks usage example
      <code>&lt;?php

      function tick_handler()
      {
      echo "tick_handler() called\n";
      }

      $a = 1;
      tick_handler();

      if ($a > 0) {
      $a += 2;
      tick_handler();
      print($a);
      tick_handler();
      }
      tick_handler();

      ?&gt;</code>

      See also register_tick_function() and unregister_tick_function().
      Encoding ¶

      A script's encoding can be specified per-script using the encoding directive.

      Example #3 Declaring an encoding for the script.
      <code>&lt;?php
      declare(encoding='ISO-8859-1');
      // code here
      ?&gt;</code>
      Caution

      When combined with namespaces, the only legal syntax for declare is declare(encoding='...'); where ... is the encoding value. declare(encoding='...') {} will result in a parse error when combined with namespaces.

      The encoding declare value is ignored in PHP 5.3 unless php is compiled with --enable-zend-multibyte.

      Note that PHP does not expose whether --enable-zend-multibyte was used to compile PHP other than by phpinfo().






    </section>


    <section class="main-section" id="return">
      <header>return</header>

      return returns program control to the calling module. Execution resumes at the expression following the called module's invocation.

      If called from within a function, the return statement immediately ends execution of the current function, and returns its argument as the value of the function call. return also ends the execution of an eval() statement or script file.

      If called from the global scope, then execution of the current script file is ended. If the current script file was included or required, then control is passed back to the calling file. Furthermore, if the current script file was included, then the value given to return will be returned as the value of the include call. If return is called from within the main script file, then script execution ends. If the current script file was named by the auto_prepend_file or auto_append_file configuration options in php.ini, then that script file's execution is ended.

      For more information, see Returning values.

      Note: Note that since return is a language construct and not a function, the parentheses surrounding its argument are not required and their use is discouraged.

      Note: If no parameter is supplied, then the parentheses must be omitted and NULL will be returned. Calling return with parentheses but with no arguments will result in a parse error.




    </section>


    <section class="main-section" id="require">
      <header>require</header>
      require is identical to include except upon failure it will also produce a fatal E_COMPILE_ERROR level error. In other words, it will halt the script whereas include only emits a warning (E_WARNING) which allows the script to continue.



    </section>


    <section class="main-section" id="include">
      <header>include</header>

      The include statement includes and evaluates the specified file.

      The documentation below also applies to require.

      Files are included based on the file path given or, if none is given, the include_path specified. If the file isn't found in the include_path, include will finally check in the calling script's own directory and the current working directory before failing. The include construct will emit a warning if it cannot find a file; this is different behavior from require, which will emit a fatal error.

      If a path is defined — whether absolute (starting with a drive letter or \ on Windows, or / on Unix/Linux systems) or relative to the current directory (starting with . or ..) — the include_path will be ignored altogether. For example, if a filename begins with ../, the parser will look in the parent directory to find the requested file.

      For more information on how PHP handles including files and the include path, see the documentation for include_path.

      When a file is included, the code it contains inherits the variable scope of the line on which the include occurs. Any variables available at that line in the calling file will be available within the called file, from that point forward. However, all functions and classes defined in the included file have the global scope.

      Example #1 Basic include example
      vars.php
      <code>&lt;?php

      $color = 'green';
      $fruit = 'apple';

      ?&gt;</code>

      test.php
      <code>&lt;?php

      echo "A $color $fruit"; // A

      include 'vars.php';

      echo "A $color $fruit"; // A green apple

      ?&gt;</code>

      If the include occurs inside a function within the calling file, then all of the code contained in the called file will behave as though it had been defined inside that function. So, it will follow the variable scope of that function. An exception to this rule are magic constants which are evaluated by the parser before the include occurs.

      Example #2 Including within functions
      <code>&lt;?php

      function foo()
      {
      global $color;

      include 'vars.php';

      echo "A $color $fruit";
      }

      /* vars.php is in the scope of foo() so     *
      * $fruit is NOT available outside of this  *
      * scope.  $color is because we declared it *
      * as global.                               */

      foo();                    // A green apple
      echo "A $color $fruit";   // A green

      ?&gt;</code>

      When a file is included, parsing drops out of PHP mode and into HTML mode at the beginning of the target file, and resumes again at the end. For this reason, any code inside the target file which should be executed as PHP code must be enclosed within valid PHP start and end tags.

      If "URL include wrappers" are enabled in PHP, you can specify the file to be included using a URL (via HTTP or other supported wrapper - see Supported Protocols and Wrappers for a list of protocols) instead of a local pathname. If the target server interprets the target file as PHP code, variables may be passed to the included file using a URL request string as used with HTTP GET. This is not strictly speaking the same thing as including the file and having it inherit the parent file's variable scope; the script is actually being run on the remote server and the result is then being included into the local script.

      Example #3 include through HTTP
      <code>&lt;?php

      /* This example assumes that www.example.com is configured to parse .php
      * files and not .txt files. Also, 'Works' here means that the variables
      * $foo and $bar are available within the included file. */

      // Won't work; file.txt wasn't handled by www.example.com as PHP
      include 'http://www.example.com/file.txt?foo=1&bar=2';

      // Won't work; looks for a file named 'file.php?foo=1&bar=2' on the
      // local filesystem.
      include 'file.php?foo=1&bar=2';

      // Works.
      include 'http://www.example.com/file.php?foo=1&bar=2';

      $foo = 1;
      $bar = 2;
      include 'file.txt';  // Works.
      include 'file.php';  // Works.

      ?&gt;</code>
      Warning
      Security warning

      Remote file may be processed at the remote server (depending on the file extension and the fact if the remote server runs PHP or not) but it still has to produce a valid PHP script because it will be processed at the local server. If the file from the remote server should be processed there and outputted only, readfile() is much better function to use. Otherwise, special care should be taken to secure the remote script to produce a valid and desired code.

      See also Remote files, fopen() and file() for related information.

      Handling Returns: include returns FALSE on failure and raises a warning. Successful includes, unless overridden by the included file, return 1. It is possible to execute a return statement inside an included file in order to terminate processing in that file and return to the script which called it. Also, it's possible to return values from included files. You can take the value of the include call as you would for a normal function. This is not, however, possible when including remote files unless the output of the remote file has valid PHP start and end tags (as with any local file). You can declare the needed variables within those tags and they will be introduced at whichever point the file was included.

      Because include is a special language construct, parentheses are not needed around its argument. Take care when comparing return value.

      Example #4 Comparing return value of include
      <code>&lt;?php
      // won't work, evaluated as include(('vars.php') == TRUE), i.e. include('')
      if (include('vars.php') == TRUE) {
      echo 'OK';
      }

      // works
      if ((include 'vars.php') == TRUE) {
      echo 'OK';
      }
      ?&gt;</code>

      Example #5 include and the return statement
      return.php
      <code>&lt;?php

      $var = 'PHP';

      return $var;

      ?&gt;</code>

      noreturn.php
      <code>&lt;?php

      $var = 'PHP';

      ?&gt;</code>

      testreturns.php
      <code>&lt;?php

      $foo = include 'return.php';

      echo $foo; // prints 'PHP'

      $bar = include 'noreturn.php';

      echo $bar; // prints 1

      ?&gt;</code>

      $bar is the value 1 because the include was successful. Notice the difference between the above examples. The first uses return within the included file while the other does not. If the file can't be included, FALSE is returned and E_WARNING is issued.

      If there are functions defined in the included file, they can be used in the main file independent if they are before return or after. If the file is included twice, PHP 5 issues fatal error because functions were already declared, while PHP 4 doesn't complain about functions defined after return. It is recommended to use include_once instead of checking if the file was already included and conditionally return inside the included file.

      Another way to "include" a PHP file into a variable is to capture the output by using the Output Control Functions with include. For example:

      Example #6 Using output buffering to include a PHP file into a string
      <code>&lt;?php
      $string = get_include_contents('somefile.php');

      function get_include_contents($filename) {
      if (is_file($filename)) {
      ob_start();
      include $filename;
      return ob_get_clean();
      }
      return false;
      }

      ?&gt;</code>

      In order to automatically include files within scripts, see also the auto_prepend_file and auto_append_file configuration options in php.ini.


    </section>


    <section class="main-section" id="require_once">
      <header>require_once</header>
      The require_once statement is identical to require except PHP will check if the file has already been included, and if so, not include (require) it again.

      See the include_once documentation for information about the _once behaviour, and how it differs from its non _once siblings.

    </section>


    <section class="main-section" id="include_once">
      <header>include_once</header>
      The include_once statement includes and evaluates the specified file during the execution of the script. This is a behavior similar to the include statement, with the only difference being that if the code from a file has already been included, it will not be included again, and include_once returns TRUE. As the name suggests, the file will be included just once.

      include_once may be used in cases where the same file might be included and evaluated more than once during a particular execution of a script, so in this case it may help avoid problems such as function redefinitions, variable value reassignments, etc.

      See the include documentation for information about how this function works.

      Note:

      With PHP 4, _once functionality differs with case-insensitive operating systems (like Windows) so for example:

      Example #1 include_once with a case insensitive OS in PHP 4
      <code>&lt;?php
      include_once "a.php"; // this will include a.php
      include_once "A.php"; // this will include a.php again! (PHP 4 only)
      ?&gt;</code>

      This behaviour changed in PHP 5, so for example with Windows the path is normalized first so that C:\PROGRA~1\A.php is realized the same as C:\Program Files\a.php and the file is included just once.


    </section>


    <section class="main-section" id="goto">
      <header>goto</header>
      The goto operator can be used to jump to another section in the program. The target point is specified by a label followed by a colon, and the instruction is given as goto followed by the desired target label. This is not a full unrestricted goto. The target label must be within the same file and context, meaning that you cannot jump out of a function or method, nor can you jump into one. You also cannot jump into any sort of loop or switch structure. You may jump out of these, and a common use is to use a goto in place of a multi-level break.

      Example #1 goto example
      <code>&lt;?php
      goto a;
      echo 'Foo';

      a:
      echo 'Bar';
      ?&gt;</code>

      The above example will output:

      Bar

      Example #2 goto loop example
      <code>&lt;?php
      for($i=0,$j=50; $i<100; $i++) {
      while($j--) {
      if($j==17) goto end;
      }
      }
      echo "i = $i";
      end:
      echo 'j hit 17';
      ?&gt;</code>

      The above example will output:

      j hit 17

      Example #3 This will not work
      <code>&lt;?php
      goto loop;
      for($i=0,$j=50; $i<100; $i++) {
      while($j--) {
      loop:
      }
      }
      echo "$i = $i";
      ?&gt;</code>

      The above example will output:

      Fatal error: 'goto' into loop or switch statement is disallowed in
      script on line 2


    </section>




    <h1 id="Functions"> Functions </h1>
    <section class="main-section" id="User-defined_functions">
      <header>User-defined functions</header>
      A function may be defined using syntax such as the following:

      Example #1 Pseudo code to demonstrate function uses
      <code>&lt;?php
      function foo($arg_1, $arg_2, /* ..., */ $arg_n)
      {
      echo "Example function.\n";
      return $retval;
      }
      ?&gt;</code>

      Any valid PHP code may appear inside a function, even other functions and class definitions.

      Function names follow the same rules as other labels in PHP. A valid function name starts with a letter or underscore, followed by any number of letters, numbers, or underscores. As a regular expression, it would be expressed thus: [a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*.
      Tip

      See also the Userland Naming Guide.

      Functions need not be defined before they are referenced, except when a function is conditionally defined as shown in the two examples below.

      When a function is defined in a conditional manner such as the two examples shown. Its definition must be processed prior to being called.

      Example #2 Conditional functions
      <code>&lt;?php

      $makefoo = true;

      /* We can't call foo() from here
      since it doesn't exist yet,
      but we can call bar() */

      bar();

      if ($makefoo) {
      function foo()
      {
      echo "I don't exist until program execution reaches me.\n";
      }
      }

      /* Now we can safely call foo()
      since $makefoo evaluated to true */

      if ($makefoo) foo();

      function bar()
      {
      echo "I exist immediately upon program start.\n";
      }

      ?&gt;</code>

      Example #3 Functions within functions
      <code>&lt;?php
      function foo()
      {
      function bar()
      {
      echo "I don't exist until foo() is called.\n";
      }
      }

      /* We can't call bar() yet
      since it doesn't exist. */

      foo();

      /* Now we can call bar(),
      foo()'s processing has
      made it accessible. */

      bar();

      ?&gt;</code>

      All functions and classes in PHP have the global scope - they can be called outside a function even if they were defined inside and vice versa.

      PHP does not support function overloading, nor is it possible to undefine or redefine previously-declared functions.

      Note: Function names are case-insensitive, though it is usually good form to call functions as they appear in their declaration.

      Both variable number of arguments and default arguments are supported in functions. See also the function references for func_num_args(), func_get_arg(), and func_get_args() for more information.

      It is possible to call recursive functions in PHP.

      Example #4 Recursive functions
      <code>&lt;?php
      function recursion($a)
      {
      if ($a < 20) {
      echo "$a\n";
      recursion($a + 1);
      }
      }
      ?&gt;</code>

    </section>


    <section class="main-section" id="Function_arguments">
      <header>Function arguments</header>

      Information may be passed to functions via the argument list, which is a comma-delimited list of expressions. The arguments are evaluated from left to right.

      PHP supports passing arguments by value (the default), passing by reference, and default argument values. Variable-length argument lists are also supported.

      Example #1 Passing arrays to functions
      <code>&lt;?php
      function takes_array($input)
      {
      echo "$input[0] + $input[1] = ", $input[0]+$input[1];
      }
      ?&gt;</code>
      Passing arguments by reference ¶

      By default, function arguments are passed by value (so that if the value of the argument within the function is changed, it does not get changed outside of the function). To allow a function to modify its arguments, they must be passed by reference.

      To have an argument to a function always passed by reference, prepend an ampersand (&) to the argument name in the function definition:

      Example #2 Passing function parameters by reference
      <code>&lt;?php
      function add_some_extra(&amp$string)
      {
      $string .= 'and something extra.';
      }
      $str = 'This is a string, ';
      add_some_extra($str);
      echo $str;    // outputs 'This is a string, and something extra.'
      ?&gt;</code>
      Default argument values ¶

      A function may define C++-style default values for scalar arguments as follows:

      Example #3 Use of default parameters in functions
      <code>&lt;?php
      function makecoffee($type = "cappuccino")
      {
      return "Making a cup of $type.\n";
      }
      echo makecoffee();
      echo makecoffee(null);
      echo makecoffee("espresso");
      ?&gt;</code>

      The above example will output:

      Making a cup of cappuccino.
      Making a cup of .
      Making a cup of espresso.

      PHP also allows the use of arrays and the special type NULL as default values, for example:

      Example #4 Using non-scalar types as default values
      <code>&lt;?php
      function makecoffee($types = array("cappuccino"), $coffeeMaker = NULL)
      {
      $device = is_null($coffeeMaker) ? "hands" : $coffeeMaker;
      return "Making a cup of ".join(", ", $types)." with $device.\n";
      }
      echo makecoffee();
      echo makecoffee(array("cappuccino", "lavazza"), "teapot");
      ?&gt;</code>

      The default value must be a constant expression, not (for example) a variable, a class member or a function call.

      Note that when using default arguments, any defaults should be on the right side of any non-default arguments; otherwise, things will not work as expected. Consider the following code snippet:

      Example #5 Incorrect usage of default function arguments
      <code>&lt;?php
      function makeyogurt($type = "acidophilus", $flavour)
      {
      return "Making a bowl of $type $flavour.\n";
      }

      echo makeyogurt("raspberry");   // won't work as expected
      ?&gt;</code>

      The above example will output:

      Warning: Missing argument 2 in call to makeyogurt() in
      /usr/local/etc/httpd/htdocs/phptest/functest.html on line 41
      Making a bowl of raspberry .

      Now, compare the above with this:

      Example #6 Correct usage of default function arguments
      <code>&lt;?php
      function makeyogurt($flavour, $type = "acidophilus")
      {
      return "Making a bowl of $type $flavour.\n";
      }

      echo makeyogurt("raspberry");   // works as expected
      ?&gt;</code>

      The above example will output:

      Making a bowl of acidophilus raspberry.

      Note: As of PHP 5, arguments that are passed by reference may have a default value.

      Type declarations ¶

      Note:

      Type declarations were also known as type hints in PHP 5.

      Type declarations allow functions to require that parameters are of a certain type at call time. If the given value is of the incorrect type, then an error is generated: in PHP 5, this will be a recoverable fatal error, while PHP 7 will throw a TypeError exception.

      To specify a type declaration, the type name should be added before the parameter name. The declaration can be made to accept NULL values if the default value of the parameter is set to NULL.
      Valid types ¶
      Type 	Description 	Minimum PHP version
      Class/interface name 	The parameter must be an instanceof the given class or interface name. 	PHP 5.0.0
      self 	The parameter must be an instanceof the same class as the one the method is defined on. This can only be used on class and instance methods. 	PHP 5.0.0
      array 	The parameter must be an array. 	PHP 5.1.0
      callable 	The parameter must be a valid callable. 	PHP 5.4.0
      bool 	The parameter must be a boolean value. 	PHP 7.0.0
      float 	The parameter must be a floating point number. 	PHP 7.0.0
      int 	The parameter must be an integer. 	PHP 7.0.0
      string 	The parameter must be a string. 	PHP 7.0.0
      iterable 	The parameter must be either an array or an instanceof Traversable. 	PHP 7.1.0
      object 	The parameter must be an object. 	PHP 7.2.0
      Warning

      Aliases for the above scalar types are not supported. Instead, they are treated as class or interface names. For example, using boolean as a parameter or return type will require an argument or return value that is an instanceof the class or interface boolean, rather than of type bool:

      <code>&lt;?php
      function test(boolean $param) {}
      test(true);
      ?&gt;</code>

      The above example will output:

      Fatal error: Uncaught TypeError: Argument 1 passed to test() must be an instance of boolean, boolean given, called in - on line 1 and defined in -:1


      Examples ¶

      Example #7 Basic class type declaration
      <code>&lt;?php
      class C {}
      class D extends C {}

      // This doesn't extend C.
      class E {}

      function f(C $c) {
      echo get_class($c)."\n";
      }

      f(new C);
      f(new D);
      f(new E);
      ?&gt;</code>

      The above example will output:

      C
      D

      Fatal error: Uncaught TypeError: Argument 1 passed to f() must be an instance of C, instance of E given, called in - on line 14 and defined in -:8
      Stack trace:
      #0 -(14): f(Object(E))
      #1 {main}
      thrown in - on line 8

      Example #8 Basic interface type declaration
      <code>&lt;?php
      interface I { public function f(); }
      class C implements I { public function f() {} }

      // This doesn't implement I.
      class E {}

      function f(I $i) {
      echo get_class($i)."\n";
      }

      f(new C);
      f(new E);
      ?&gt;</code>

      The above example will output:

      C

      Fatal error: Uncaught TypeError: Argument 1 passed to f() must implement interface I, instance of E given, called in - on line 13 and defined in -:8
      Stack trace:
      #0 -(13): f(Object(E))
      #1 {main}
      thrown in - on line 8

      Example #9 Nullable type declaration
      <code>&lt;?php
      class C {}

      function f(C $c = null) {
      var_dump($c);
      }

      f(new C);
      f(null);
      ?&gt;</code>

      The above example will output:

      object(C)#1 (0) {
      }
      NULL

      Strict typing ¶

      By default, PHP will coerce values of the wrong type into the expected scalar type if possible. For example, a function that is given an integer for a parameter that expects a string will get a variable of type string.

      It is possible to enable strict mode on a per-file basis. In strict mode, only a variable of exact type of the type declaration will be accepted, or a TypeError will be thrown. The only exception to this rule is that an integer may be given to a function expecting a float. Function calls from within internal functions will not be affected by the strict_types declaration.

      To enable strict mode, the declare statement is used with the strict_types declaration:
      Caution

      Enabling strict mode will also affect return type declarations.

      Note:

      Strict typing applies to function calls made from within the file with strict typing enabled, not to the functions declared within that file. If a file without strict typing enabled makes a call to a function that was defined in a file with strict typing, the caller's preference (weak typing) will be respected, and the value will be coerced.

      Note:

      Strict typing is only defined for scalar type declarations, and as such, requires PHP 7.0.0 or later, as scalar type declarations were added in that version.

      Example #10 Strict typing
      <code>&lt;?php
      declare(strict_types=1);

      function sum(int $a, int $b) {
      return $a + $b;
      }

      var_dump(sum(1, 2));
      var_dump(sum(1.5, 2.5));
      ?&gt;</code>

      The above example will output:

      int(3)

      Fatal error: Uncaught TypeError: Argument 1 passed to sum() must be of the type integer, float given, called in - on line 9 and defined in -:4
      Stack trace:
      #0 -(9): sum(1.5, 2.5)
      #1 {main}
      thrown in - on line 4

      Example #11 Weak typing
      <code>&lt;?php
      function sum(int $a, int $b) {
      return $a + $b;
      }

      var_dump(sum(1, 2));

      // These will be coerced to integers: note the output below!
      var_dump(sum(1.5, 2.5));
      ?&gt;</code>

      The above example will output:

      int(3)
      int(3)

      Example #12 Catching TypeError
      <code>&lt;?php
      declare(strict_types=1);

      function sum(int $a, int $b) {
      return $a + $b;
      }

      try {
      var_dump(sum(1, 2));
      var_dump(sum(1.5, 2.5));
      } catch (TypeError $e) {
      echo 'Error: '.$e->getMessage();
      }
      ?&gt;</code>

      The above example will output:

      int(3)
      Error: Argument 1 passed to sum() must be of the type integer, float given, called in - on line 10

      Variable-length argument lists ¶

      PHP has support for variable-length argument lists in user-defined functions. This is implemented using the ... token in PHP 5.6 and later, and using the func_num_args(), func_get_arg(), and func_get_args() functions in PHP 5.5 and earlier.
      ... in PHP 5.6+ ¶

      In PHP 5.6 and later, argument lists may include the ... token to denote that the function accepts a variable number of arguments. The arguments will be passed into the given variable as an array; for example:

      Example #13 Using ... to access variable arguments
      <code>&lt;?php
      function sum(...$numbers) {
      $acc = 0;
      foreach ($numbers as $n) {
      $acc += $n;
      }
      return $acc;
      }

      echo sum(1, 2, 3, 4);
      ?&gt;</code>

      The above example will output:

      10

      You can also use ... when calling functions to unpack an array or Traversable variable or literal into the argument list:

      Example #14 Using ... to provide arguments
      <code>&lt;?php
      function add($a, $b) {
      return $a + $b;
      }

      echo add(...[1, 2])."\n";

      $a = [1, 2];
      echo add(...$a);
      ?&gt;</code>

      The above example will output:

      3
      3

      You may specify normal positional arguments before the ... token. In this case, only the trailing arguments that don't match a positional argument will be added to the array generated by ....

      It is also possible to add a type hint before the ... token. If this is present, then all arguments captured by ... must be objects of the hinted class.

      Example #15 Type hinted variable arguments
      <code>&lt;?php
      function total_intervals($unit, DateInterval ...$intervals) {
      $time = 0;
      foreach ($intervals as $interval) {
      $time += $interval->$unit;
      }
      return $time;
      }

      $a = new DateInterval('P1D');
      $b = new DateInterval('P2D');
      echo total_intervals('d', $a, $b).' days';

      // This will fail, since null isn't a DateInterval object.
      echo total_intervals('d', null);
      ?&gt;</code>

      The above example will output:

      3 days
      Catchable fatal error: Argument 2 passed to total_intervals() must be an instance of DateInterval, null given, called in - on line 14 and defined in - on line 2

      Finally, you may also pass variable arguments by reference by prefixing the ... with an ampersand (&).
      Older versions of PHP ¶

      No special syntax is required to note that a function is variadic; however access to the function's arguments must use func_num_args(), func_get_arg() and func_get_args().

      The first example above would be implemented as follows in PHP 5.5 and earlier:

      Example #16 Accessing variable arguments in PHP 5.5 and earlier
      <code>&lt;?php
      function sum() {
      $acc = 0;
      foreach (func_get_args() as $n) {
      $acc += $n;
      }
      return $acc;
      }

      echo sum(1, 2, 3, 4);
      ?&gt;</code>

      The above example will output:

      10

    </section>


    <section class="main-section" id="Returning_values">
      <header>Returning values</header>

      Values are returned by using the optional return statement. Any type may be returned, including arrays and objects. This causes the function to end its execution immediately and pass control back to the line from which it was called. See return for more information.

      Note:

      If the return is omitted the value NULL will be returned.

      Use of return

      Example #1 Use of return
      <code>&lt;?php
      function square($num)
      {
      return $num * $num;
      }
      echo square(4);   // outputs '16'.
      ?&gt;</code>

      A function can not return multiple values, but similar results can be obtained by returning an array.

      Example #2 Returning an array to get multiple values
      <code>&lt;?php
      function small_numbers()
      {
      return array (0, 1, 2);
      }
      list ($zero, $one, $two) = small_numbers();
      ?&gt;</code>

      To return a reference from a function, use the reference operator & in both the function declaration and when assigning the returned value to a variable:

      Example #3 Returning a reference from a function
      <code>&lt;?php
      function &returns_reference()
      {
      return $someref;
      }

      $newref =& returns_reference();
      ?&gt;</code>

      For more information on references, please check out References Explained.
      Return type declarations ¶

      PHP 7 adds support for return type declarations. Similarly to argument type declarations, return type declarations specify the type of the value that will be returned from a function. The same types are available for return type declarations as are available for argument type declarations.

      Strict typing also has an effect on return type declarations. In the default weak mode, returned values will be coerced to the correct type if they are not already of that type. In strong mode, the returned value must be of the correct type, otherwise a TypeError will be thrown.

      Note:

      When overriding a parent method, the child's method must match any return type declaration on the parent. If the parent doesn't define a return type, then the child method may do so.

      Examples ¶

      Example #4 Basic return type declaration
      <code>&lt;?php
      function sum($a, $b): float {
      return $a + $b;
      }

      // Note that a float will be returned.
      var_dump(sum(1, 2));
      ?&gt;</code>

      The above example will output:

      float(3)

      Example #5 Strict mode in action
      <code>&lt;?php
      declare(strict_types=1);

      function sum($a, $b): int {
      return $a + $b;
      }

      var_dump(sum(1, 2));
      var_dump(sum(1, 2.5));
      ?&gt;</code>

      The above example will output:

      int(3)

      Fatal error: Uncaught TypeError: Return value of sum() must be of the type integer, float returned in - on line 5 in -:5
      Stack trace:
      #0 -(9): sum(1, 2.5)
      #1 {main}
      thrown in - on line 5

      Example #6 Returning an object
      <code>&lt;?php
      class C {}

      function getC(): C {
      return new C;
      }

      var_dump(getC());
      ?&gt;</code>

      The above example will output:

      object(C)#1 (0) {
      }



    </section>


    <section class="main-section" id="Variable_functions">
      <header>Variable functions</header>


      PHP supports the concept of variable functions. This means that if a variable name has parentheses appended to it, PHP will look for a function with the same name as whatever the variable evaluates to, and will attempt to execute it. Among other things, this can be used to implement callbacks, function tables, and so forth.

      Variable functions won't work with language constructs such as echo, print, unset(), isset(), empty(), include, require and the like. Utilize wrapper functions to make use of any of these constructs as variable functions.

      Example #1 Variable function example
      <code>&lt;?php
      function foo() {
      echo "In foo()<br />\n";
      }

      function bar($arg = '')
      {
      echo "In bar(); argument was '$arg'.<br />\n";
      }

      // This is a wrapper function around echo
      function echoit($string)
      {
      echo $string;
      }

      $func = 'foo';
      $func();        // This calls foo()

      $func = 'bar';
      $func('test');  // This calls bar()

      $func = 'echoit';
      $func('test');  // This calls echoit()
      ?&gt;</code>

      Object methods can also be called with the variable functions syntax.

      Example #2 Variable method example
      <code>&lt;?php
      class Foo
      {
      function Variable()
      {
      $name = 'Bar';
      $this->$name(); // This calls the Bar() method
      }

      function Bar()
      {
      echo "This is Bar";
      }
      }

      $foo = new Foo();
      $funcname = "Variable";
      $foo->$funcname();  // This calls $foo->Variable()

      ?&gt;</code>

      When calling static methods, the function call is stronger than the static property operator:

      Example #3 Variable method example with static properties
      <code>&lt;?php
      class Foo
      {
      static $variable = 'static property';
      static function Variable()
      {
      echo 'Method Variable called';
      }
      }

      echo Foo::$variable; // This prints 'static property'. It does need a $variable in this scope.
      $variable = "Variable";
      Foo::$variable();  // This calls $foo->Variable() reading $variable in this scope.

      ?&gt;</code>

      As of PHP 5.4.0, you can call any callable stored in a variable.

      Example #4 Complex callables
      <code>&lt;?php
      class Foo
      {
      static function bar()
      {
      echo "bar\n";
      }
      function baz()
      {
      echo "baz\n";
      }
      }

      $func = array("Foo", "bar");
      $func(); // prints "bar"
      $func = array(new Foo, "baz");
      $func(); // prints "baz"
      $func = "Foo::bar";
      $func(); // prints "bar" as of PHP 7.0.0; prior, it raised a fatal error
      ?&gt;</code>



    </section>


    <section class="main-section" id="bookmark_(built-in)_functions">
      <header>bookmark (built-in) functions</header>
      Information may be passed to functions via the argument list, which is a comma-delimited list of expressions. The arguments are evaluated from left to right.

      PHP supports passing arguments by value (the default), passing by reference, and default argument values. Variable-length argument lists are also supported.

      Example #1 Passing arrays to functions
      <code>&lt;?php
      function takes_array($input)
      {
      echo "$input[0] + $input[1] = ", $input[0]+$input[1];
      }
      ?&gt;</code>
      Passing arguments by reference ¶

      By default, function arguments are passed by value (so that if the value of the argument within the function is changed, it does not get changed outside of the function). To allow a function to modify its arguments, they must be passed by reference.

      To have an argument to a function always passed by reference, prepend an ampersand (&) to the argument name in the function definition:

      Example #2 Passing function parameters by reference
      <code>&lt;?php
      function add_some_extra(&amp$string)
      {
      $string .= 'and something extra.';
      }
      $str = 'This is a string, ';
      add_some_extra($str);
      echo $str;    // outputs 'This is a string, and something extra.'
      ?&gt;</code>
      Default argument values ¶

      A function may define C++-style default values for scalar arguments as follows:

      Example #3 Use of default parameters in functions
      <code>&lt;?php
      function makecoffee($type = "cappuccino")
      {
      return "Making a cup of $type.\n";
      }
      echo makecoffee();
      echo makecoffee(null);
      echo makecoffee("espresso");
      ?&gt;</code>

      The above example will output:

      Making a cup of cappuccino.
      Making a cup of .
      Making a cup of espresso.

      PHP also allows the use of arrays and the special type NULL as default values, for example:

      Example #4 Using non-scalar types as default values
      <code>&lt;?php
      function makecoffee($types = array("cappuccino"), $coffeeMaker = NULL)
      {
      $device = is_null($coffeeMaker) ? "hands" : $coffeeMaker;
      return "Making a cup of ".join(", ", $types)." with $device.\n";
      }
      echo makecoffee();
      echo makecoffee(array("cappuccino", "lavazza"), "teapot");
      ?&gt;</code>

      The default value must be a constant expression, not (for example) a variable, a class member or a function call.

      Note that when using default arguments, any defaults should be on the right side of any non-default arguments; otherwise, things will not work as expected. Consider the following code snippet:

      Example #5 Incorrect usage of default function arguments
      <code>&lt;?php
      function makeyogurt($type = "acidophilus", $flavour)
      {
      return "Making a bowl of $type $flavour.\n";
      }

      echo makeyogurt("raspberry");   // won't work as expected
      ?&gt;</code>

      The above example will output:

      Warning: Missing argument 2 in call to makeyogurt() in
      /usr/local/etc/httpd/htdocs/phptest/functest.html on line 41
      Making a bowl of raspberry .

      Now, compare the above with this:

      Example #6 Correct usage of default function arguments
      <code>&lt;?php
      function makeyogurt($flavour, $type = "acidophilus")
      {
      return "Making a bowl of $type $flavour.\n";
      }

      echo makeyogurt("raspberry");   // works as expected
      ?&gt;</code>

      The above example will output:

      Making a bowl of acidophilus raspberry.

      Note: As of PHP 5, arguments that are passed by reference may have a default value.

      Type declarations ¶

      Note:

      Type declarations were also known as type hints in PHP 5.

      Type declarations allow functions to require that parameters are of a certain type at call time. If the given value is of the incorrect type, then an error is generated: in PHP 5, this will be a recoverable fatal error, while PHP 7 will throw a TypeError exception.

      To specify a type declaration, the type name should be added before the parameter name. The declaration can be made to accept NULL values if the default value of the parameter is set to NULL.
      Valid types ¶
      Type 	Description 	Minimum PHP version
      Class/interface name 	The parameter must be an instanceof the given class or interface name. 	PHP 5.0.0
      self 	The parameter must be an instanceof the same class as the one the method is defined on. This can only be used on class and instance methods. 	PHP 5.0.0
      array 	The parameter must be an array. 	PHP 5.1.0
      callable 	The parameter must be a valid callable. 	PHP 5.4.0
      bool 	The parameter must be a boolean value. 	PHP 7.0.0
      float 	The parameter must be a floating point number. 	PHP 7.0.0
      int 	The parameter must be an integer. 	PHP 7.0.0
      string 	The parameter must be a string. 	PHP 7.0.0
      iterable 	The parameter must be either an array or an instanceof Traversable. 	PHP 7.1.0
      object 	The parameter must be an object. 	PHP 7.2.0
      Warning

      Aliases for the above scalar types are not supported. Instead, they are treated as class or interface names. For example, using boolean as a parameter or return type will require an argument or return value that is an instanceof the class or interface boolean, rather than of type bool:

      <code>&lt;?php
      function test(boolean $param) {}
      test(true);
      ?&gt;</code>

      The above example will output:

      Fatal error: Uncaught TypeError: Argument 1 passed to test() must be an instance of boolean, boolean given, called in - on line 1 and defined in -:1


      Examples ¶

      Example #7 Basic class type declaration
      <code>&lt;?php
      class C {}
      class D extends C {}

      // This doesn't extend C.
      class E {}

      function f(C $c) {
      echo get_class($c)."\n";
      }

      f(new C);
      f(new D);
      f(new E);
      ?&gt;</code>

      The above example will output:

      C
      D

      Fatal error: Uncaught TypeError: Argument 1 passed to f() must be an instance of C, instance of E given, called in - on line 14 and defined in -:8
      Stack trace:
      #0 -(14): f(Object(E))
      #1 {main}
      thrown in - on line 8

      Example #8 Basic interface type declaration
      <code>&lt;?php
      interface I { public function f(); }
      class C implements I { public function f() {} }

      // This doesn't implement I.
      class E {}

      function f(I $i) {
      echo get_class($i)."\n";
      }

      f(new C);
      f(new E);
      ?&gt;</code>

      The above example will output:

      C

      Fatal error: Uncaught TypeError: Argument 1 passed to f() must implement interface I, instance of E given, called in - on line 13 and defined in -:8
      Stack trace:
      #0 -(13): f(Object(E))
      #1 {main}
      thrown in - on line 8

      Example #9 Nullable type declaration
      <code>&lt;?php
      class C {}

      function f(C $c = null) {
      var_dump($c);
      }

      f(new C);
      f(null);
      ?&gt;</code>

      The above example will output:

      object(C)#1 (0) {
      }
      NULL

      Strict typing ¶

      By default, PHP will coerce values of the wrong type into the expected scalar type if possible. For example, a function that is given an integer for a parameter that expects a string will get a variable of type string.

      It is possible to enable strict mode on a per-file basis. In strict mode, only a variable of exact type of the type declaration will be accepted, or a TypeError will be thrown. The only exception to this rule is that an integer may be given to a function expecting a float. Function calls from within internal functions will not be affected by the strict_types declaration.

      To enable strict mode, the declare statement is used with the strict_types declaration:
      Caution

      Enabling strict mode will also affect return type declarations.

      Note:

      Strict typing applies to function calls made from within the file with strict typing enabled, not to the functions declared within that file. If a file without strict typing enabled makes a call to a function that was defined in a file with strict typing, the caller's preference (weak typing) will be respected, and the value will be coerced.

      Note:

      Strict typing is only defined for scalar type declarations, and as such, requires PHP 7.0.0 or later, as scalar type declarations were added in that version.

      Example #10 Strict typing
      <code>&lt;?php
      declare(strict_types=1);

      function sum(int $a, int $b) {
      return $a + $b;
      }

      var_dump(sum(1, 2));
      var_dump(sum(1.5, 2.5));
      ?&gt;</code>

      The above example will output:

      int(3)

      Fatal error: Uncaught TypeError: Argument 1 passed to sum() must be of the type integer, float given, called in - on line 9 and defined in -:4
      Stack trace:
      #0 -(9): sum(1.5, 2.5)
      #1 {main}
      thrown in - on line 4

      Example #11 Weak typing
      <code>&lt;?php
      function sum(int $a, int $b) {
      return $a + $b;
      }

      var_dump(sum(1, 2));

      // These will be coerced to integers: note the output below!
      var_dump(sum(1.5, 2.5));
      ?&gt;</code>

      The above example will output:

      int(3)
      int(3)

      Example #12 Catching TypeError
      <code>&lt;?php
      declare(strict_types=1);

      function sum(int $a, int $b) {
      return $a + $b;
      }

      try {
      var_dump(sum(1, 2));
      var_dump(sum(1.5, 2.5));
      } catch (TypeError $e) {
      echo 'Error: '.$e->getMessage();
      }
      ?&gt;</code>

      The above example will output:

      int(3)
      Error: Argument 1 passed to sum() must be of the type integer, float given, called in - on line 10

      Variable-length argument lists ¶

      PHP has support for variable-length argument lists in user-defined functions. This is implemented using the ... token in PHP 5.6 and later, and using the func_num_args(), func_get_arg(), and func_get_args() functions in PHP 5.5 and earlier.
      ... in PHP 5.6+ ¶

      In PHP 5.6 and later, argument lists may include the ... token to denote that the function accepts a variable number of arguments. The arguments will be passed into the given variable as an array; for example:

      Example #13 Using ... to access variable arguments
      <code>&lt;?php
      function sum(...$numbers) {
      $acc = 0;
      foreach ($numbers as $n) {
      $acc += $n;
      }
      return $acc;
      }

      echo sum(1, 2, 3, 4);
      ?&gt;</code>

      The above example will output:

      10

      You can also use ... when calling functions to unpack an array or Traversable variable or literal into the argument list:

      Example #14 Using ... to provide arguments
      <code>&lt;?php
      function add($a, $b) {
      return $a + $b;
      }

      echo add(...[1, 2])."\n";

      $a = [1, 2];
      echo add(...$a);
      ?&gt;</code>

      The above example will output:

      3
      3

      You may specify normal positional arguments before the ... token. In this case, only the trailing arguments that don't match a positional argument will be added to the array generated by ....

      It is also possible to add a type hint before the ... token. If this is present, then all arguments captured by ... must be objects of the hinted class.

      Example #15 Type hinted variable arguments
      <code>&lt;?php
      function total_intervals($unit, DateInterval ...$intervals) {
      $time = 0;
      foreach ($intervals as $interval) {
      $time += $interval->$unit;
      }
      return $time;
      }

      $a = new DateInterval('P1D');
      $b = new DateInterval('P2D');
      echo total_intervals('d', $a, $b).' days';

      // This will fail, since null isn't a DateInterval object.
      echo total_intervals('d', null);
      ?&gt;</code>

      The above example will output:

      3 days
      Catchable fatal error: Argument 2 passed to total_intervals() must be an instance of DateInterval, null given, called in - on line 14 and defined in - on line 2

      Finally, you may also pass variable arguments by reference by prefixing the ... with an ampersand (&).
      Older versions of PHP ¶

      No special syntax is required to note that a function is variadic; however access to the function's arguments must use func_num_args(), func_get_arg() and func_get_args().

      The first example above would be implemented as follows in PHP 5.5 and earlier:

      Example #16 Accessing variable arguments in PHP 5.5 and earlier
      <code>&lt;?php
      function sum() {
      $acc = 0;
      foreach (func_get_args() as $n) {
      $acc += $n;
      }
      return $acc;
      }

      echo sum(1, 2, 3, 4);
      ?&gt;</code>

      The above example will output:

      10

    </section>


    <section class="main-section" id="Anonymous_functions">
      <header>Anonymous functions</header>

      PHP comes standard with many functions and constructs. There are also functions that require specific PHP extensions compiled in, otherwise fatal "undefined function" errors will appear. For example, to use image functions such as imagecreatetruecolor(), PHP must be compiled with GD support. Or, to use mysqli_connect(), PHP must be compiled with MySQLi support. There are many core functions that are included in every version of PHP, such as the string and variable functions. A call to phpinfo() or get_loaded_extensions() will show which extensions are loaded into PHP. Also note that many extensions are enabled by default and that the PHP manual is split up by extension. See the configuration, installation, and individual extension chapters, for information on how to set up PHP.

      Reading and understanding a function's prototype is explained within the manual section titled how to read a function definition. It's important to realize what a function returns or if a function works directly on a passed in value. For example, str_replace() will return the modified string while usort() works on the actual passed in variable itself. Each manual page also has specific information for each function like information on function parameters, behavior changes, return values for both success and failure, and availability information. Knowing these important (yet often subtle) differences is crucial for writing correct PHP code.

      Note: If the parameters given to a function are not what it expects, such as passing an array where a string is expected, the return value of the function is undefined. In this case it will likely return NULL but this is just a convention, and cannot be relied upon.

      Anonymous functions, also known as closures, allow the creation of functions which have no specified name. They are most useful as the value of callback parameters, but they have many other uses.

      Anonymous functions are implemented using the Closure class.

      Example #1 Anonymous function example
      <code>&lt;?php
      echo preg_replace_callback('~-([a-z])~', function ($match) {
      return strtoupper($match[1]);
      }, 'hello-world');
      // outputs helloWorld
      ?&gt;</code>

      Closures can also be used as the values of variables; PHP automatically converts such expressions into instances of the Closure internal class. Assigning a closure to a variable uses the same syntax as any other assignment, including the trailing semicolon:

      Example #2 Anonymous function variable assignment example
      <code>&lt;?php
      $greet = function($name)
      {
      printf("Hello %s\r\n", $name);
      };

      $greet('World');
      $greet('PHP');
      ?&gt;</code>

      Closures may also inherit variables from the parent scope. Any such variables must be passed to the use language construct. From PHP 7.1, these variables must not include superglobals, $this, or variables with the same name as a parameter.

      Example #3 Inheriting variables from the parent scope
      <code>&lt;?php
      $message = 'hello';

      // No "use"
      $example = function () {
      var_dump($message);
      };
      $example();

      // Inherit $message
      $example = function () use ($message) {
      var_dump($message);
      };
      $example();

      // Inherited variable's value is from when the function
      // is defined, not when called
      $message = 'world';
      $example();

      // Reset message
      $message = 'hello';

      // Inherit by-reference
      $example = function () use (&amp$message) {
      var_dump($message);
      };
      $example();

      // The changed value in the parent scope
      // is reflected inside the function call
      $message = 'world';
      $example();

      // Closures can also accept regular arguments
      $example = function ($arg) use ($message) {
      var_dump($arg . ' ' . $message);
      };
      $example("hello");
      ?&gt;</code>

      The above example will output something similar to:

      Notice: Undefined variable: message in /example.php on line 6
      NULL
      string(5) "hello"
      string(5) "hello"
      string(5) "hello"
      string(5) "world"
      string(11) "hello world"

      Inheriting variables from the parent scope is not the same as using global variables. Global variables exist in the global scope, which is the same no matter what function is executing. The parent scope of a closure is the function in which the closure was declared (not necessarily the function it was called from). See the following example:

      Example #4 Closures and scoping
      <code>&lt;?php
      // A basic shopping cart which contains a list of added products
      // and the quantity of each product. Includes a method which
      // calculates the total price of the items in the cart using a
      // closure as a callback.
      class Cart
      {
      const PRICE_BUTTER  = 1.00;
      const PRICE_MILK    = 3.00;
      const PRICE_EGGS    = 6.95;

      protected $products = array();

      public function add($product, $quantity)
      {
      $this->products[$product] = $quantity;
      }

      public function getQuantity($product)
      {
      return isset($this->products[$product]) ? $this->products[$product] :
             FALSE;
      }

      public function getTotal($tax)
      {
      $total = 0.00;

      $callback =
          function ($quantity, $product) use ($tax, &amp$total)
          {
              $pricePerItem = constant(__CLASS__ . "::PRICE_" .
                  strtoupper($product));
              $total += ($pricePerItem * $quantity) * ($tax + 1.0);
          };

      array_walk($this->products, $callback);
      return round($total, 2);
      }
      }

      $my_cart = new Cart;

      // Add some items to the cart
      $my_cart->add('butter', 1);
      $my_cart->add('milk', 3);
      $my_cart->add('eggs', 6);

      // Print the total with a 5% sales tax.
      print $my_cart->getTotal(0.05) . "\n";
      // The result is 54.29
      ?&gt;</code>

      Example #5 Automatic binding of $this
      <code>&lt;?php

      class Test
      {
      public function testing()
      {
      return function() {
          var_dump($this);
      };
      }
      }

      $object = new Test;
      $function = $object->testing();
      $function();

      ?&gt;</code>

      The above example will output:

      object(Test)#1 (0) {
      }

      Output of the above example in PHP 5.3:

      Notice: Undefined variable: this in script.php on line 8
      NULL

      As of PHP 5.4.0, when declared in the context of a class, the current class is automatically bound to it, making $this available inside of the function's scope. If this automatic binding of the current class is not wanted, then static anonymous functions may be used instead.
      Static anonymous functions ¶

      As of PHP 5.4, anonymous functions may be declared statically. This prevents them from having the current class automatically bound to them. Objects may also not be bound to them at runtime.

      Example #6 Attempting to use $this inside a static anonymous function
      <code>&lt;?php

      class Foo
      {
      function __construct()
      {
      $func = static function() {
          var_dump($this);
      };
      $func();
      }
      };
      new Foo();

      ?&gt;</code>

      The above example will output:

      Notice: Undefined variable: this in %s on line %d
      NULL

      Example #7 Attempting to bind an object to a static anonymous function
      <code>&lt;?php

      $func = static function() {
      // function body
      };
      $func = $func->bindTo(new StdClass);
      $func();

      ?&gt;</code>

      The above example will output:

      Warning: Cannot bind an instance to a static closure in %s on line %d


    </section>


    <h1 id="Classes_And_Objects"> Classes and Objects </h1>
    <section class="main-section" id="Classes_And_Objects_Introduction">
      <header> Classes and Objects Introduction</header>

      Starting with PHP 5, the object model was rewritten to allow for better performance and more features. This was a major change from PHP 4. PHP 5 has a full object model.

      Among the features in PHP 5 are the inclusions of visibility, abstract and final classes and methods, additional magic methods, interfaces, cloning and typehinting.

      PHP treats objects in the same way as references or handles, meaning that each variable contains an object reference rather than a copy of the entire object. See Objects and References

    </section>


    <section class="main-section" id="The_Basics">
      <header>The Basics</header>

      Basic class definitions begin with the keyword class, followed by a class name, followed by a pair of curly braces which enclose the definitions of the properties and methods belonging to the class.

      The class name can be any valid label, provided it is not a PHP reserved word. A valid class name starts with a letter or underscore, followed by any number of letters, numbers, or underscores. As a regular expression, it would be expressed thus: ^[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*$.

      A class may contain its own constants, variables (called "properties"), and functions (called "methods").

      Example #1 Simple Class definition
      <code>&lt;?php
      class SimpleClass
      {
      // property declaration
      public $var = 'a default value';

      // method declaration
      public function displayVar() {
      echo $this->var;
      }
      }
      ?&gt;</code>

      The pseudo-variable $this is available when a method is called from within an object context. $this is a reference to the calling object (usually the object to which the method belongs, but possibly another object, if the method is called statically from the context of a secondary object). As of PHP 7.0.0 calling a non-static method statically from an incompatible context results in $this being undefined inside the method. Calling a non-static method statically from an incompatible context has been deprecated as of PHP 5.6.0. As of PHP 7.0.0 calling a non-static method statically has been generally deprecated (even if called from a compatible context). Before PHP 5.6.0 such calls already triggered a strict notice.

      Example #2 Some examples of the $this pseudo-variable

      We're assuming that error_reporting is disabled for this example; otherwise the following code would trigger deprecated and strict notices, respectively, depending on the PHP version.
      <code>&lt;?php
      class A
      {
      function foo()
      {
      if (isset($this)) {
       echo '$this is defined (';
       echo get_class($this);
       echo ")\n";
      } else {
       echo "\$this is not defined.\n";
      }
      }
      }

      class B
      {
      function bar()
      {
      A::foo();
      }
      }

      $a = new A();
      $a->foo();

      A::foo();

      $b = new B();
      $b->bar();

      B::bar();
      ?&gt;</code>

      Output of the above example in PHP 5:

      $this is defined (A)
      $this is not defined.
      $this is defined (B)
      $this is not defined.

      Output of the above example in PHP 7:

      $this is defined (A)
      $this is not defined.
      $this is not defined.
      $this is not defined.

      new ¶

      To create an instance of a class, the new keyword must be used. An object will always be created unless the object has a constructor defined that throws an exception on error. Classes should be defined before instantiation (and in some cases this is a requirement).

      If a string containing the name of a class is used with new, a new instance of that class will be created. If the class is in a namespace, its fully qualified name must be used when doing this.

      Example #3 Creating an instance
      <code>&lt;?php
      $instance = new SimpleClass();

      // This can also be done with a variable:
      $className = 'SimpleClass';
      $instance = new $className(); // new SimpleClass()
      ?&gt;</code>

      In the class context, it is possible to create a new object by new self and new parent.

      When assigning an already created instance of a class to a new variable, the new variable will access the same instance as the object that was assigned. This behaviour is the same when passing instances to a function. A copy of an already created object can be made by cloning it.

      Example #4 Object Assignment
      <code>&lt;?php

      $instance = new SimpleClass();

      $assigned   =  $instance;
      $reference  =& $instance;

      $instance->var = '$assigned will have this value';

      $instance = null; // $instance and $reference become null

      var_dump($instance);
      var_dump($reference);
      var_dump($assigned);
      ?&gt;</code>

      The above example will output:

      NULL
      NULL
      object(SimpleClass)#1 (1) {
      ["var"]=>
      string(30) "$assigned will have this value"
      }

      PHP 5.3.0 introduced a couple of new ways to create instances of an object:

      Example #5 Creating new objects
      <code>&lt;?php
      class Test
      {
      static public function getNew()
      {
      return new static;
      }
      }

      class Child extends Test
      {}

      $obj1 = new Test();
      $obj2 = new $obj1;
      var_dump($obj1 !== $obj2);

      $obj3 = Test::getNew();
      var_dump($obj3 instanceof Test);

      $obj4 = Child::getNew();
      var_dump($obj4 instanceof Child);
      ?&gt;</code>

      The above example will output:

      bool(true)
      bool(true)
      bool(true)

      PHP 5.4.0 introduced the possibility to access a member of a newly created object in a single expression:

      Example #6 Access member of newly created object
      <code>&lt;?php
      echo (new DateTime())->format('Y');
      ?&gt;</code>

      The above example will output something similar to:

      2016

      Properties and methods ¶

      Class properties and methods live in separate "namespaces", so it is possible to have a property and a method with the same name. Referring to both a property and a method has the same notation, and whether a property will be accessed or a method will be called, solely depends on the context, i.e. whether the usage is a variable access or a function call.

      Example #7 Property access vs. method call
      <code>&lt;?php
      class Foo
      {
      public $bar = 'property';

      public function bar() {
      return 'method';
      }
      }

      $obj = new Foo();
      echo $obj->bar, PHP_EOL, $obj->bar(), PHP_EOL;

      The above example will output:

      property
      method

      That means that calling an anonymous function which has been assigned to a property is not directly possible. Instead the property has to be assigned to a variable first, for instance. As of PHP 7.0.0 it is possible to call such a property directly by enclosing it in parentheses.

      Example #8 Calling an anonymous function stored in a property
      <code>&lt;?php
      class Foo
      {
      public $bar;

      public function __construct() {
      $this->bar = function() {
       return 42;
      };
      }
      }

      $obj = new Foo();

      // as of PHP 5.3.0:
      $func = $obj->bar;
      echo $func(), PHP_EOL;

      // alternatively, as of PHP 7.0.0:
      echo ($obj->bar)(), PHP_EOL;

      The above example will output:

      42

      extends ¶

      A class can inherit the methods and properties of another class by using the keyword extends in the class declaration. It is not possible to extend multiple classes; a class can only inherit from one base class.

      The inherited methods and properties can be overridden by redeclaring them with the same name defined in the parent class. However, if the parent class has defined a method as final, that method may not be overridden. It is possible to access the overridden methods or static properties by referencing them with parent::.

      When overriding methods, the parameter signature should remain the same or PHP will generate an E_STRICT level error. This does not apply to the constructor, which allows overriding with different parameters.

      Example #9 Simple Class Inheritance
      <code>&lt;?php
      class ExtendClass extends SimpleClass
      {
      // Redefine the parent method
      function displayVar()
      {
      echo "Extending class\n";
      parent::displayVar();
      }
      }

      $extended = new ExtendClass();
      $extended->displayVar();
      ?&gt;</code>

      The above example will output:

      Extending class
      a default value

      ::class ¶

      Since PHP 5.5, the class keyword is also used for class name resolution. You can get a string containing the fully qualified name of the ClassName class by using ClassName::class. This is particularly useful with namespaced classes.

      Example #10 Class name resolution
      <code>&lt;?php
      namespace NS {
      class ClassName {
      }

      echo ClassName::class;
      }
      ?&gt;</code>

      The above example will output:

      NS\ClassName

      Note:

      The class name resolution using ::class is a compile time transformation. That means at the time the class name string is created no autoloading has happened yet. As a consequence, class names are expanded even if the class does not exist. No error is issued in that case.


    </section>


    <section class="main-section" id="Properties">
      <header>Properties</header>

      Class member variables are called "properties". You may also see them referred to using other terms such as "attributes" or "fields", but for the purposes of this reference we will use "properties". They are defined by using one of the keywords public, protected, or private, followed by a normal variable declaration. This declaration may include an initialization, but this initialization must be a constant value--that is, it must be able to be evaluated at compile time and must not depend on run-time information in order to be evaluated.

      See Visibility for more information on the meanings of public, protected, and private.

      Note:

      In order to maintain backward compatibility with PHP 4, PHP 5 will still accept the use of the keyword var in property declarations instead of (or in addition to) public, protected, or private. However, var is no longer required. In versions of PHP from 5.0 to 5.1.3, the use of var was considered deprecated and would issue an E_STRICT warning, but since PHP 5.1.3 it is no longer deprecated and does not issue the warning.

      If you declare a property using var instead of one of public, protected, or private, then PHP 5 will treat the property as if it had been declared as public.

      Within class methods non-static properties may be accessed by using -> (Object Operator): $this->property (where property is the name of the property). Static properties are accessed by using the :: (Double Colon): self::$property. See Static Keyword for more information on the difference between static and non-static properties.

      The pseudo-variable $this is available inside any class method when that method is called from within an object context. $this is a reference to the calling object (usually the object to which the method belongs, but possibly another object, if the method is called statically from the context of a secondary object).

      Example #1 property declarations
      <code>&lt;?php
      class SimpleClass
      {
      // valid as of PHP 5.6.0:
      public $var1 = 'hello ' . 'world';
      // valid as of PHP 5.3.0:
      public $var2 = &lt;&lt;&lt;EOD
      hello world
      EOD;
      // valid as of PHP 5.6.0:
      public $var3 = 1+2;
      // invalid property declarations:
      public $var4 = self::myStaticMethod();
      public $var5 = $myVar;

      // valid property declarations:
      public $var6 = myConstant;
      public $var7 = array(true, false);

      // valid as of PHP 5.3.0:
      public $var8 = &lt;&lt;&lt;'EOD'
      hello world
      EOD;
      }
      ?&gt;</code>

      Note:

      There are some nice functions to handle classes and objects. You might want to take a look at the Class/Object Functions.

      As of PHP 5.3.0 heredocs and nowdocs can be used in any static data context, including property declarations.

      Example #2 Example of using a nowdoc to initialize a property
      <code>&lt;?php
      class foo {
      // As of PHP 5.3.0
      public $bar = &lt;&lt;&lt;'EOT'
      bar
      EOT;
      public $baz = &lt;&lt;&lt;EOT
      baz
      EOT;
      }
      ?&gt;</code>


    </section>


    <section class="main-section" id="Class_Constants">
      <header>Class Constants</header>


      It is possible to define constant values on a per-class basis remaining the same and unchangeable. Constants differ from normal variables in that you don't use the $ symbol to declare or use them. The default visibility of class constants is public.

      The value must be a constant expression, not (for example) a variable, a property, or a function call.

      It's also possible for interfaces to have constants. Look at the interface documentation for examples.

      As of PHP 5.3.0, it's possible to reference the class using a variable. The variable's value can not be a keyword (e.g. self, parent and static).

      Note that class constants are allocated once per class, and not for each class instance.

      Example #1 Defining and using a constant
      <code>&lt;?php
      class MyClass
      {
      const CONSTANT = 'constant value';

      function showConstant() {
      echo  self::CONSTANT . "\n";
      }
      }

      echo MyClass::CONSTANT . "\n";

      $classname = "MyClass";
      echo $classname::CONSTANT . "\n"; // As of PHP 5.3.0

      $class = new MyClass();
      $class->showConstant();

      echo $class::CONSTANT."\n"; // As of PHP 5.3.0
      ?&gt;</code>

      Example #2 Static data example
      <code>&lt;?php
      class foo {
      // As of PHP 5.3.0
      const BAR = &lt;&lt;&lt;'EOT'
      bar
      EOT;
      // As of PHP 5.3.0
      const BAZ = &lt;&lt;&lt;EOT
      baz
      EOT;
      }
      ?&gt;</code>

      Note:

      Support for initializing constants with Heredoc and Nowdoc syntax was added in PHP 5.3.0.

      The special ::class constant is available as of PHP 5.5.0, and allows for fully qualified class name resolution at compile time, this is useful for namespaced classes:

      Example #3 Namespaced ::class example
      <code>&lt;?php
      namespace foo {
      class bar {
      }

      echo bar::class; // foo\bar
      }
      ?&gt;</code>

      Example #4 Constant expression example
      <code>&lt;?php
      const ONE = 1;

      class foo {
      // As of PHP 5.6.0
      const TWO = ONE * 2;
      const THREE = ONE + self::TWO;
      const SENTENCE = 'The value of THREE is '.self::THREE;
      }
      ?&gt;</code>

      It is possible to provide a scalar expression involving numeric and string literals and/or constants in context of a class constant.

      Note:

      Constant expression support was added in PHP 5.6.0.

      Example #5 Class constant visibility modifiers
      <code>&lt;?php
      class Foo {
      // As of PHP 7.1.0
      public const BAR = 'bar';
      private const BAZ = 'baz';
      }
      echo Foo::BAR, PHP_EOL;
      echo Foo::BAZ, PHP_EOL;
      ?&gt;</code>

      Output of the above example in PHP 7.1:

      bar

      Fatal error: Uncaught Error: Cannot access private const Foo::BAZ in …


    </section>


    <section class="main-section" id="Autoloading_Classes">
      <header>Autoloading Classes</header>

      Many developers writing object-oriented applications create one PHP source file per class definition. One of the biggest annoyances is having to write a long list of needed includes at the beginning of each script (one for each class).

      In PHP 5, this is no longer necessary. The spl_autoload_register() function registers any number of autoloaders, enabling for classes and interfaces to be automatically loaded if they are currently not defined. By registering autoloaders, PHP is given a last chance to load the class or interface before it fails with an error.
      Tip

      Although the __autoload() function can also be used for autoloading classes and interfaces, it's preferred to use the spl_autoload_register() function. This is because it is a more flexible alternative (enabling for any number of autoloaders to be specified in the application, such as in third party libraries). For this reason, using __autoload() is discouraged and it may be deprecated in the future.

      Note:

      Prior to PHP 5.3, exceptions thrown in the __autoload() function could not be caught in the catch block and would result in a fatal error. From PHP 5.3 and upwards, this is possible provided that if a custom exception is thrown, then the custom exception class is available. The __autoload() function may be used recursively to autoload the custom exception class.

      Note:

      Autoloading is not available if using PHP in CLI interactive mode.

      Note:

      If the class name is used e.g. in call_user_func() then it can contain some dangerous characters such as ../. It is recommended to not use the user-input in such functions or at least verify the input in __autoload().

      Example #1 Autoload example

      This example attempts to load the classes MyClass1 and MyClass2 from the files MyClass1.php and MyClass2.php respectively.
      <code>&lt;?php
      spl_autoload_register(function ($class_name) {
      include $class_name . '.php';
      });

      $obj  = new MyClass1();
      $obj2 = new MyClass2();
      ?&gt;</code>

      Example #2 Autoload other example

      This example attempts to load the interface ITest.
      <code>&lt;?php

      spl_autoload_register(function ($name) {
      var_dump($name);
      });

      class Foo implements ITest {
      }

      /*
      string(5) "ITest"

      Fatal error: Interface 'ITest' not found in ...
      */
      ?&gt;</code>

      Example #3 Autoloading with exception handling for 5.3.0+

      This example throws an exception and demonstrates the try/catch block.
      <code>&lt;?php
      spl_autoload_register(function ($name) {
      echo "Want to load $name.\n";
      throw new Exception("Unable to load $name.");
      });

      try {
      $obj = new NonLoadableClass();
      } catch (Exception $e) {
      echo $e->getMessage(), "\n";
      }
      ?&gt;</code>

      The above example will output:

      Want to load NonLoadableClass.
      Unable to load NonLoadableClass.

      Example #4 Autoloading with exception handling for 5.3.0+ - Missing custom exception

      This example throws an exception for a non-loadable, custom exception.
      <code>&lt;?php
      spl_autoload_register(function ($name) {
      echo "Want to load $name.\n";
      throw new MissingException("Unable to load $name.");
      });

      try {
      $obj = new NonLoadableClass();
      } catch (Exception $e) {
      echo $e->getMessage(), "\n";
      }
      ?&gt;</code>

      The above example will output:

      Want to load NonLoadableClass.
      Want to load MissingException.

      Fatal error: Class 'MissingException' not found in testMissingException.php on line 4

    </section>


    <section class="main-section" id="Constructors_and_Destructors">
      <header>Constructors and Destructors</header>

      void __construct ([ mixed $args = "" [, $... ]] )

      PHP 5 allows developers to declare constructor methods for classes. Classes which have a constructor method call this method on each newly-created object, so it is suitable for any initialization that the object may need before it is used.

      Note: Parent constructors are not called implicitly if the child class defines a constructor. In order to run a parent constructor, a call to parent::__construct() within the child constructor is required. If the child does not define a constructor then it may be inherited from the parent class just like a normal class method (if it was not declared as private).

      Example #1 using new unified constructors
      <code>&lt;?php
      class BaseClass {
      function __construct() {
      print "In BaseClass constructor\n";
      }
      }

      class SubClass extends BaseClass {
      function __construct() {
      parent::__construct();
      print "In SubClass constructor\n";
      }
      }

      class OtherSubClass extends BaseClass {
      // inherits BaseClass's constructor
      }

      // In BaseClass constructor
      $obj = new BaseClass();

      // In BaseClass constructor
      // In SubClass constructor
      $obj = new SubClass();

      // In BaseClass constructor
      $obj = new OtherSubClass();
      ?&gt;</code>

      For backwards compatibility with PHP 3 and 4, if PHP cannot find a __construct() function for a given class, it will search for the old-style constructor function, by the name of the class. Effectively, it means that the only case that would have compatibility issues is if the class had a method named __construct() which was used for different semantics.
      Warning

      Old style constructors are DEPRECATED in PHP 7.0, and will be removed in a future version. You should always use __construct() in new code.

      Unlike with other methods, PHP will not generate an E_STRICT level error message when __construct() is overridden with different parameters than the parent __construct() method has.

      As of PHP 5.3.3, methods with the same name as the last element of a namespaced class name will no longer be treated as constructor. This change doesn't affect non-namespaced classes.

      Example #2 Constructors in namespaced classes
      <code>&lt;?php
      namespace Foo;
      class Bar {
      public function Bar() {
      // treated as constructor in PHP 5.3.0-5.3.2
      // treated as regular method as of PHP 5.3.3
      }
      }
      ?&gt;</code>
      Destructor ¶
      void __destruct ( void )

      PHP 5 introduces a destructor concept similar to that of other object-oriented languages, such as C++. The destructor method will be called as soon as there are no other references to a particular object, or in any order during the shutdown sequence.

      Example #3 Destructor Example
      <code>&lt;?php

      class MyDestructableClass
      {
      function __construct() {
      print "In constructor\n";
      }

      function __destruct() {
      print "Destroying " . __CLASS__ . "\n";
      }
      }

      $obj = new MyDestructableClass();

      Like constructors, parent destructors will not be called implicitly by the engine. In order to run a parent destructor, one would have to explicitly call parent::__destruct() in the destructor body. Also like constructors, a child class may inherit the parent's destructor if it does not implement one itself.

      The destructor will be called even if script execution is stopped using exit(). Calling exit() in a destructor will prevent the remaining shutdown routines from executing.

      Note:

      Destructors called during the script shutdown have HTTP headers already sent. The working directory in the script shutdown phase can be different with some SAPIs (e.g. Apache).

      Note:

      Attempting to throw an exception from a destructor (called in the time of script termination) causes a fatal error.


    </section>


    <section class="main-section" id="Visibility">
      <header>Visibility</header>
      The visibility of a property, a method or (as of PHP 7.1.0) a constant can be defined by prefixing the declaration with the keywords public, protected or private. Class members declared public can be accessed everywhere. Members declared protected can be accessed only within the class itself and by inheriting and parent classes. Members declared as private may only be accessed by the class that defines the member.
      Property Visibility ¶

      Class properties must be defined as public, private, or protected. If declared using var, the property will be defined as public.

      Example #1 Property declaration
      <code>&lt;?php
      /**
      * Define MyClass
      */
      class MyClass
      {
      public $public = 'Public';
      protected $protected = 'Protected';
      private $private = 'Private';

      function printHello()
      {
      echo $this->public;
      echo $this->protected;
      echo $this->private;
      }
      }

      $obj = new MyClass();
      echo $obj->public; // Works
      echo $obj->protected; // Fatal Error
      echo $obj->private; // Fatal Error
      $obj->printHello(); // Shows Public, Protected and Private


      /**
      * Define MyClass2
      */
      class MyClass2 extends MyClass
      {
      // We can redeclare the public and protected properties, but not private
      public $public = 'Public2';
      protected $protected = 'Protected2';

      function printHello()
      {
      echo $this->public;
      echo $this->protected;
      echo $this->private;
      }
      }

      $obj2 = new MyClass2();
      echo $obj2->public; // Works
      echo $obj2->protected; // Fatal Error
      echo $obj2->private; // Undefined
      $obj2->printHello(); // Shows Public2, Protected2, Undefined

      ?&gt;</code>

      Note: The PHP 4 method of declaring a variable with the var keyword is still supported for compatibility reasons (as a synonym for the public keyword). In PHP 5 before 5.1.3, its usage would generate an E_STRICT warning.

      Method Visibility ¶

      Class methods may be defined as public, private, or protected. Methods declared without any explicit visibility keyword are defined as public.

      Example #2 Method Declaration
      <code>&lt;?php
      /**
      * Define MyClass
      */
      class MyClass
      {
      // Declare a public constructor
      public function __construct() { }

      // Declare a public method
      public function MyPublic() { }

      // Declare a protected method
      protected function MyProtected() { }

      // Declare a private method
      private function MyPrivate() { }

      // This is public
      function Foo()
      {
      $this->MyPublic();
      $this->MyProtected();
      $this->MyPrivate();
      }
      }

      $myclass = new MyClass;
      $myclass->MyPublic(); // Works
      $myclass->MyProtected(); // Fatal Error
      $myclass->MyPrivate(); // Fatal Error
      $myclass->Foo(); // Public, Protected and Private work


      /**
      * Define MyClass2
      */
      class MyClass2 extends MyClass
      {
      // This is public
      function Foo2()
      {
      $this->MyPublic();
      $this->MyProtected();
      $this->MyPrivate(); // Fatal Error
      }
      }

      $myclass2 = new MyClass2;
      $myclass2->MyPublic(); // Works
      $myclass2->Foo2(); // Public and Protected work, not Private

      class Bar
      {
      public function test() {
      $this->testPrivate();
      $this->testPublic();
      }

      public function testPublic() {
      echo "Bar::testPublic\n";
      }

      private function testPrivate() {
      echo "Bar::testPrivate\n";
      }
      }

      class Foo extends Bar
      {
      public function testPublic() {
      echo "Foo::testPublic\n";
      }

      private function testPrivate() {
      echo "Foo::testPrivate\n";
      }
      }

      $myFoo = new Foo();
      $myFoo->test(); // Bar::testPrivate
              // Foo::testPublic
      ?&gt;</code>
      Constant Visibility ¶

      As of PHP 7.1.0, class constants may be defined as public, private, or protected. Constants declared without any explicit visibility keyword are defined as public.

      Example #3 Constant Declaration as of PHP 7.1.0
      <code>&lt;?php
      /**
      * Define MyClass
      */
      class MyClass
      {
      // Declare a public constant
      public const MY_PUBLIC = 'public';

      // Declare a protected constant
      protected const MY_PROTECTED = 'protected';

      // Declare a private constant
      private const MY_PRIVATE = 'private';

      public function foo()
      {
      echo self::MY_PUBLIC;
      echo self::MY_PROTECTED;
      echo self::MY_PRIVATE;
      }
      }

      $myclass = new MyClass();
      MyClass::MY_PUBLIC; // Works
      MyClass::MY_PROTECTED; // Fatal Error
      MyClass::MY_PRIVATE; // Fatal Error
      $myclass->foo(); // Public, Protected and Private work


      /**
      * Define MyClass2
      */
      class MyClass2 extends MyClass
      {
      // This is public
      function foo2()
      {
      echo self::MY_PUBLIC;
      echo self::MY_PROTECTED;
      echo self::MY_PRIVATE; // Fatal Error
      }
      }

      $myclass2 = new MyClass2;
      echo MyClass2::MY_PUBLIC; // Works
      $myclass2->foo2(); // Public and Protected work, not Private
      ?&gt;</code>
      Visibility from other objects ¶

      Objects of the same type will have access to each others private and protected members even though they are not the same instances. This is because the implementation specific details are already known when inside those objects.

      Example #4 Accessing private members of the same object type
      <code>&lt;?php
      class Test
      {
      private $foo;

      public function __construct($foo)
      {
      $this->foo = $foo;
      }

      private function bar()
      {
      echo 'Accessed the private method.';
      }

      public function baz(Test $other)
      {
      // We can change the private property:
      $other->foo = 'hello';
      var_dump($other->foo);

      // We can also call the private method:
      $other->bar();
      }
      }

      $test = new Test('test');

      $test->baz(new Test('other'));
      ?&gt;</code>

      The above example will output:

      string(5) "hello"
      Accessed the private method.





    </section>


    <section class="main-section" id="Object_Inheritance">
      <header>Object Inheritance</header>

      Inheritance is a well-established programming principle, and PHP makes use of this principle in its object model. This principle will affect the way many classes and objects relate to one another.

      For example, when you extend a class, the subclass inherits all of the public and protected methods from the parent class. Unless a class overrides those methods, they will retain their original functionality.

      This is useful for defining and abstracting functionality, and permits the implementation of additional functionality in similar objects without the need to reimplement all of the shared functionality.

      Note:

      Unless autoloading is used, then classes must be defined before they are used. If a class extends another, then the parent class must be declared before the child class structure. This rule applies to classes that inherit other classes and interfaces.

      Example #1 Inheritance Example
      <code>&lt;?php

      class Foo
      {
      public function printItem($string)
      {
      echo 'Foo: ' . $string . PHP_EOL;
      }

      public function printPHP()
      {
      echo 'PHP is great.' . PHP_EOL;
      }
      }

      class Bar extends Foo
      {
      public function printItem($string)
      {
      echo 'Bar: ' . $string . PHP_EOL;
      }
      }

      $foo = new Foo();
      $bar = new Bar();
      $foo->printItem('baz'); // Output: 'Foo: baz'
      $foo->printPHP();       // Output: 'PHP is great'
      $bar->printItem('baz'); // Output: 'Bar: baz'
      $bar->printPHP();       // Output: 'PHP is great'

      ?&gt;</code>



    </section>


    <section class="main-section" id="Scope_Resolution_Operator_(::)">
      <header>Scope Resolution Operator (::)</header>

      The Scope Resolution Operator (also called Paamayim Nekudotayim) or in simpler terms, the double colon, is a token that allows access to static, constant, and overridden properties or methods of a class.

      When referencing these items from outside the class definition, use the name of the class.

      As of PHP 5.3.0, it's possible to reference the class using a variable. The variable's value can not be a keyword (e.g. self, parent and static).

      Paamayim Nekudotayim would, at first, seem like a strange choice for naming a double-colon. However, while writing the Zend Engine 0.5 (which powers PHP 3), that's what the Zend team decided to call it. It actually does mean double-colon - in Hebrew!

      Example #1 :: from outside the class definition
      <code>&lt;?php
      class MyClass {
      const CONST_VALUE = 'A constant value';
      }

      $classname = 'MyClass';
      echo $classname::CONST_VALUE; // As of PHP 5.3.0

      echo MyClass::CONST_VALUE;
      ?&gt;</code>

      Three special keywords self, parent and static are used to access properties or methods from inside the class definition.

      Example #2 :: from inside the class definition
      <code>&lt;?php
      class OtherClass extends MyClass
      {
      public static $my_static = 'static var';

      public static function doubleColon() {
      echo parent::CONST_VALUE . "\n";
      echo self::$my_static . "\n";
      }
      }

      $classname = 'OtherClass';
      $classname::doubleColon(); // As of PHP 5.3.0

      OtherClass::doubleColon();
      ?&gt;</code>

      When an extending class overrides the parents definition of a method, PHP will not call the parent's method. It's up to the extended class on whether or not the parent's method is called. This also applies to Constructors and Destructors, Overloading, and Magic method definitions.

      Example #3 Calling a parent's method
      <code>&lt;?php
      class MyClass
      {
      protected function myFunc() {
      echo "MyClass::myFunc()\n";
      }
      }

      class OtherClass extends MyClass
      {
      // Override parent's definition
      public function myFunc()
      {
      // But still call the parent function
      parent::myFunc();
      echo "OtherClass::myFunc()\n";
      }
      }

      $class = new OtherClass();
      $class->myFunc();
      ?&gt;</code>

    </section>


    <section class="main-section" id="Static_Keyword">
      <header>Static Keyword</header>

      This page describes the use of the static keyword to define static methods and properties. static can also be used to define static variables and for late static bindings. Please refer to those pages for information on those meanings of static.

      Declaring class properties or methods as static makes them accessible without needing an instantiation of the class. A property declared as static cannot be accessed with an instantiated class object (though a static method can).

      For compatibility with PHP 4, if no visibility declaration is used, then the property or method will be treated as if it was declared as public.
      Static methods ¶

      Because static methods are callable without an instance of the object created, the pseudo-variable $this is not available inside the method declared as static.
      Caution

      In PHP 5, calling non-static methods statically generates an E_STRICT level warning.
      Warning

      In PHP 7, calling non-static methods statically is deprecated, and will generate an E_DEPRECATED warning. Support for calling non-static methods statically may be removed in the future.

      Example #1 Static method example
      <code>&lt;?php
      class Foo {
      public static function aStaticMethod() {
      // ...
      }
      }

      Foo::aStaticMethod();
      $classname = 'Foo';
      $classname::aStaticMethod(); // As of PHP 5.3.0
      ?&gt;</code>
      Static properties ¶

      Static properties cannot be accessed through the object using the arrow operator ->.

      Like any other PHP static variable, static properties may only be initialized using a literal or constant before PHP 5.6; expressions are not allowed. In PHP 5.6 and later, the same rules apply as const expressions: some limited expressions are possible, provided they can be evaluated at compile time.

      As of PHP 5.3.0, it's possible to reference the class using a variable. The variable's value cannot be a keyword (e.g. self, parent and static).

      Example #2 Static property example
      <code>&lt;?php
      class Foo
      {
      public static $my_static = 'foo';

      public function staticValue() {
      return self::$my_static;
      }
      }

      class Bar extends Foo
      {
      public function fooStatic() {
      return parent::$my_static;
      }
      }


      print Foo::$my_static . "\n";

      $foo = new Foo();
      print $foo->staticValue() . "\n";
      print $foo->my_static . "\n";      // Undefined "Property" my_static

      print $foo::$my_static . "\n";
      $classname = 'Foo';
      print $classname::$my_static . "\n"; // As of PHP 5.3.0

      print Bar::$my_static . "\n";
      $bar = new Bar();
      print $bar->fooStatic() . "\n";
      ?&gt;</code>
    </section>

    <section class="main-section" id="Class_Abstraction">
      <header>Class Abstraction</header>

      PHP 5 introduces abstract classes and methods. Classes defined as abstract may not be instantiated, and any class that contains at least one abstract method must also be abstract. Methods defined as abstract simply declare the method's signature - they cannot define the implementation.

      When inheriting from an abstract class, all methods marked abstract in the parent's class declaration must be defined by the child; additionally, these methods must be defined with the same (or a less restricted) visibility. For example, if the abstract method is defined as protected, the function implementation must be defined as either protected or public, but not private. Furthermore the signatures of the methods must match, i.e. the type hints and the number of required arguments must be the same. For example, if the child class defines an optional argument, where the abstract method's signature does not, there is no conflict in the signature. This also applies to constructors as of PHP 5.4. Before 5.4 constructor signatures could differ.

      Example #1 Abstract class example
      <code>&lt;?php
      abstract class AbstractClass
      {
      // Force Extending class to define this method
      abstract protected function getValue();
      abstract protected function prefixValue($prefix);

      // Common method
      public function printOut() {
      print $this->getValue() . "\n";
      }
      }

      class ConcreteClass1 extends AbstractClass
      {
      protected function getValue() {
      return "ConcreteClass1";
      }

      public function prefixValue($prefix) {
      return "{$prefix}ConcreteClass1";
      }
      }

      class ConcreteClass2 extends AbstractClass
      {
      public function getValue() {
      return "ConcreteClass2";
      }

      public function prefixValue($prefix) {
      return "{$prefix}ConcreteClass2";
      }
      }

      $class1 = new ConcreteClass1;
      $class1->printOut();
      echo $class1->prefixValue('FOO_') ."\n";

      $class2 = new ConcreteClass2;
      $class2->printOut();
      echo $class2->prefixValue('FOO_') ."\n";
      ?&gt;</code>

      The above example will output:

      ConcreteClass1
      FOO_ConcreteClass1
      ConcreteClass2
      FOO_ConcreteClass2

      Example #2 Abstract class example
      <code>&lt;?php
      abstract class AbstractClass
      {
      // Our abstract method only needs to define the required arguments
      abstract protected function prefixName($name);

      }

      class ConcreteClass extends AbstractClass
      {

      // Our child class may define optional arguments not in the parent's signature
      public function prefixName($name, $separator = ".") {
      if ($name == "Pacman") {
       $prefix = "Mr";
      } elseif ($name == "Pacwoman") {
       $prefix = "Mrs";
      } else {
       $prefix = "";
      }
      return "{$prefix}{$separator} {$name}";
      }
      }

      $class = new ConcreteClass;
      echo $class->prefixName("Pacman"), "\n";
      echo $class->prefixName("Pacwoman"), "\n";
      ?&gt;</code>

      The above example will output:

      Mr. Pacman
      Mrs. Pacwoman

      Old code that has no user-defined classes or functions named 'abstract' should run without modifications.


    </section>


    <section class="main-section" id="Object_Interfaces">
      <header>Object Interfaces</header>

      Object interfaces allow you to create code which specifies which methods a class must implement, without having to define how these methods are implemented.

      Interfaces are defined in the same way as a class, but with the interface keyword replacing the class keyword and without any of the methods having their contents defined.

      All methods declared in an interface must be public; this is the nature of an interface.

      Note that it is possible to declare a constructor in an interface, what can be useful in some contexts, e.g. for use by factories.
      implements ¶

      To implement an interface, the implements operator is used. All methods in the interface must be implemented within a class; failure to do so will result in a fatal error. Classes may implement more than one interface if desired by separating each interface with a comma.

      Note:

      Prior to PHP 5.3.9, a class could not implement two interfaces that specified a method with the same name, since it would cause ambiguity. More recent versions of PHP allow this as long as the duplicate methods have the same signature.

      Note:

      Interfaces can be extended like classes using the extends operator.

      Note:

      The class implementing the interface must use the exact same method signatures as are defined in the interface. Not doing so will result in a fatal error.

      Constants ¶

      It's possible for interfaces to have constants. Interface constants work exactly like class constants except they cannot be overridden by a class/interface that inherits them.
      Examples ¶

      Example #1 Interface example
      <code>&lt;?php

      // Declare the interface 'iTemplate'
      interface iTemplate
      {
      public function setVariable($name, $var);
      public function getHtml($template);
      }

      // Implement the interface
      // This will work
      class Template implements iTemplate
      {
      private $vars = array();

      public function setVariable($name, $var)
      {
      $this->vars[$name] = $var;
      }

      public function getHtml($template)
      {
      foreach($this->vars as $name => $value) {
       $template = str_replace('{' . $name . '}', $value, $template);
      }

      return $template;
      }
      }

      // This will not work
      // Fatal error: Class BadTemplate contains 1 abstract methods
      // and must therefore be declared abstract (iTemplate::getHtml)
      class BadTemplate implements iTemplate
      {
      private $vars = array();

      public function setVariable($name, $var)
      {
      $this->vars[$name] = $var;
      }
      }
      ?&gt;</code>

      Example #2 Extendable Interfaces
      <code>&lt;?php
      interface a
      {
      public function foo();
      }

      interface b extends a
      {
      public function baz(Baz $baz);
      }

      // This will work
      class c implements b
      {
      public function foo()
      {
      }

      public function baz(Baz $baz)
      {
      }
      }

      // This will not work and result in a fatal error
      class d implements b
      {
      public function foo()
      {
      }

      public function baz(Foo $foo)
      {
      }
      }
      ?&gt;</code>

      Example #3 Multiple interface inheritance
      <code>&lt;?php
      interface a
      {
      public function foo();
      }

      interface b
      {
      public function bar();
      }

      interface c extends a, b
      {
      public function baz();
      }

      class d implements c
      {
      public function foo()
      {
      }

      public function bar()
      {
      }

      public function baz()
      {
      }
      }
      ?&gt;</code>

      Example #4 Interfaces with constants
      <code>&lt;?php
      interface a
      {
      const b = 'Interface constant';
      }

      // Prints: Interface constant
      echo a::b;


      // This will however not work because it's not allowed to
      // override constants.
      class b implements a
      {
      const b = 'Class constant';
      }
      ?&gt;</code>

      An interface, together with type-hinting, provides a good way to make sure that a particular object contains particular methods. See instanceof operator and type hinting.


    </section>


    <section class="main-section" id="Traits">
      <header>Traits</header>

      As of PHP 5.4.0, PHP implements a method of code reuse called Traits.

      Traits are a mechanism for code reuse in single inheritance languages such as PHP. A Trait is intended to reduce some limitations of single inheritance by enabling a developer to reuse sets of methods freely in several independent classes living in different class hierarchies. The semantics of the combination of Traits and classes is defined in a way which reduces complexity, and avoids the typical problems associated with multiple inheritance and Mixins.

      A Trait is similar to a class, but only intended to group functionality in a fine-grained and consistent way. It is not possible to instantiate a Trait on its own. It is an addition to traditional inheritance and enables horizontal composition of behavior; that is, the application of class members without requiring inheritance.

      Example #1 Trait example
      <code>&lt;?php
      trait ezcReflectionReturnInfo {
      function getReturnType() { /*1*/ }
      function getReturnDescription() { /*2*/ }
      }

      class ezcReflectionMethod extends ReflectionMethod {
      use ezcReflectionReturnInfo;
      /* ... */
      }

      class ezcReflectionFunction extends ReflectionFunction {
      use ezcReflectionReturnInfo;
      /* ... */
      }
      ?&gt;</code>
      Precedence ¶

      An inherited member from a base class is overridden by a member inserted by a Trait. The precedence order is that members from the current class override Trait methods, which in turn override inherited methods.

      Example #2 Precedence Order Example

      An inherited method from a base class is overridden by the method inserted into MyHelloWorld from the SayWorld Trait. The behavior is the same for methods defined in the MyHelloWorld class. The precedence order is that methods from the current class override Trait methods, which in turn override methods from the base class.
      <code>&lt;?php
      class Base {
      public function sayHello() {
      echo 'Hello ';
      }
      }

      trait SayWorld {
      public function sayHello() {
      parent::sayHello();
      echo 'World!';
      }
      }

      class MyHelloWorld extends Base {
      use SayWorld;
      }

      $o = new MyHelloWorld();
      $o->sayHello();
      ?&gt;</code>

      The above example will output:

      Hello World!

      Example #3 Alternate Precedence Order Example
      <code>&lt;?php
      trait HelloWorld {
      public function sayHello() {
      echo 'Hello World!';
      }
      }

      class TheWorldIsNotEnough {
      use HelloWorld;
      public function sayHello() {
      echo 'Hello Universe!';
      }
      }

      $o = new TheWorldIsNotEnough();
      $o->sayHello();
      ?&gt;</code>

      The above example will output:

      Hello Universe!

      Multiple Traits ¶

      Multiple Traits can be inserted into a class by listing them in the use statement, separated by commas.

      Example #4 Multiple Traits Usage
      <code>&lt;?php
      trait Hello {
      public function sayHello() {
      echo 'Hello ';
      }
      }

      trait World {
      public function sayWorld() {
      echo 'World';
      }
      }

      class MyHelloWorld {
      use Hello, World;
      public function sayExclamationMark() {
      echo '!';
      }
      }

      $o = new MyHelloWorld();
      $o->sayHello();
      $o->sayWorld();
      $o->sayExclamationMark();
      ?&gt;</code>

      The above example will output:

      Hello World!

      Conflict Resolution ¶

      If two Traits insert a method with the same name, a fatal error is produced, if the conflict is not explicitly resolved.

      To resolve naming conflicts between Traits used in the same class, the insteadof operator needs to be used to choose exactly one of the conflicting methods.

      Since this only allows one to exclude methods, the as operator can be used to add an alias to one of the methods. Note the as operator does not rename the method and it does not affect any other method either.

      Example #5 Conflict Resolution

      In this example, Talker uses the traits A and B. Since A and B have conflicting methods, it defines to use the variant of smallTalk from trait B, and the variant of bigTalk from trait A.

      The Aliased_Talker makes use of the as operator to be able to use B's bigTalk implementation under an additional alias talk.
      <code>&lt;?php
      trait A {
      public function smallTalk() {
      echo 'a';
      }
      public function bigTalk() {
      echo 'A';
      }
      }

      trait B {
      public function smallTalk() {
      echo 'b';
      }
      public function bigTalk() {
      echo 'B';
      }
      }

      class Talker {
      use A, B {
      B::smallTalk insteadof A;
      A::bigTalk insteadof B;
      }
      }

      class Aliased_Talker {
      use A, B {
      B::smallTalk insteadof A;
      A::bigTalk insteadof B;
      B::bigTalk as talk;
      }
      }
      ?&gt;</code>

      Note:

      Prior to PHP 7.0, defining a property in a class with the same name as in a trait would throw an E_STRICT if the class definition was compatible (same visibility and initial value).

      Changing Method Visibility ¶

      Using the as syntax, one can also adjust the visibility of the method in the exhibiting class.

      Example #6 Changing Method Visibility
      <code>&lt;?php
      trait HelloWorld {
      public function sayHello() {
      echo 'Hello World!';
      }
      }

      // Change visibility of sayHello
      class MyClass1 {
      use HelloWorld { sayHello as protected; }
      }

      // Alias method with changed visibility
      // sayHello visibility not changed
      class MyClass2 {
      use HelloWorld { sayHello as private myPrivateHello; }
      }
      ?&gt;</code>
      Traits Composed from Traits ¶

      Just as classes can make use of traits, so can other traits. By using one or more traits in a trait definition, it can be composed partially or entirely of the members defined in those other traits.

      Example #7 Traits Composed from Traits
      <code>&lt;?php
      trait Hello {
      public function sayHello() {
      echo 'Hello ';
      }
      }

      trait World {
      public function sayWorld() {
      echo 'World!';
      }
      }

      trait HelloWorld {
      use Hello, World;
      }

      class MyHelloWorld {
      use HelloWorld;
      }

      $o = new MyHelloWorld();
      $o->sayHello();
      $o->sayWorld();
      ?&gt;</code>

      The above example will output:

      Hello World!

      Abstract Trait Members ¶

      Traits support the use of abstract methods in order to impose requirements upon the exhibiting class.

      Example #8 Express Requirements by Abstract Methods
      <code>&lt;?php
      trait Hello {
      public function sayHelloWorld() {
      echo 'Hello'.$this->getWorld();
      }
      abstract public function getWorld();
      }

      class MyHelloWorld {
      private $world;
      use Hello;
      public function getWorld() {
      return $this->world;
      }
      public function setWorld($val) {
      $this->world = $val;
      }
      }
      ?&gt;</code>
      Static Trait Members ¶

      Traits can define both static members and static methods.

      Example #9 Static Variables
      <code>&lt;?php
      trait Counter {
      public function inc() {
      static $c = 0;
      $c = $c + 1;
      echo "$c\n";
      }
      }

      class C1 {
      use Counter;
      }

      class C2 {
      use Counter;
      }

      $o = new C1(); $o->inc(); // echo 1
      $p = new C2(); $p->inc(); // echo 1
      ?&gt;</code>

      Example #10 Static Methods
      <code>&lt;?php
      trait StaticExample {
      public static function doSomething() {
      return 'Doing something';
      }
      }

      class Example {
      use StaticExample;
      }

      Example::doSomething();
      ?&gt;</code>
      Properties ¶

      Traits can also define properties.

      Example #11 Defining Properties
      <code>&lt;?php
      trait PropertiesTrait {
      public $x = 1;
      }

      class PropertiesExample {
      use PropertiesTrait;
      }

      $example = new PropertiesExample;
      $example->x;
      ?&gt;</code>

      If a trait defines a property then a class can not define a property with the same name unless it is compatible (same visibility and initial value), otherwise a fatal error is issued. Before PHP 7.0.0, defining a property in the class with the same visibility and initial value as in the trait, raised an E_STRICT notice.

      Example #12 Conflict Resolution
      <code>&lt;?php
      trait PropertiesTrait {
      public $same = true;
      public $different = false;
      }

      class PropertiesExample {
      use PropertiesTrait;
      public $same = true; // Allowed as of PHP 7.0.0; E_STRICT notice formerly
      public $different = true; // Fatal error
      }
      ?&gt;</code>

    </section>


    <section class="main-section" id="Anonymous_classes">
      <header>Anonymous classes</header>

      Support for anonymous classes was added in PHP 7. Anonymous classes are useful when simple, one-off objects need to be created.
      <code>&lt;?php

      // Pre PHP 7 code
      class Logger
      {
      public function log($msg)
      {
      echo $msg;
      }
      }

      $util->setLogger(new Logger());

      // PHP 7+ code
      $util->setLogger(new class {
      public function log($msg)
      {
      echo $msg;
      }
      });

      They can pass arguments through to their constructors, extend other classes, implement interfaces, and use traits just like a normal class can:
      <code>&lt;?php

      class SomeClass {}
      interface SomeInterface {}
      trait SomeTrait {}

      var_dump(new class(10) extends SomeClass implements SomeInterface {
      private $num;

      public function __construct($num)
      {
      $this->num = $num;
      }

      use SomeTrait;
      });

      The above example will output:

      object(class@anonymous)#1 (1) {
      ["Command line code0x104c5b612":"class@anonymous":private]=>
      int(10)
      }

      Nesting an anonymous class within another class does not give it access to any private or protected methods or properties of that outer class. In order to use the outer class' protected properties or methods, the anonymous class can extend the outer class. To use the private properties of the outer class in the anonymous class, they must be passed through its constructor:
      <code>&lt;?php

      class Outer
      {
      private $prop = 1;
      protected $prop2 = 2;

      protected function func1()
      {
      return 3;
      }

      public function func2()
      {
      return new class($this->prop) extends Outer {
       private $prop3;

       public function __construct($prop)
       {
           $this->prop3 = $prop;
       }

       public function func3()
       {
           return $this->prop2 + $this->prop3 + $this->func1();
       }
      };
      }
      }

      echo (new Outer)->func2()->func3();

      The above example will output:

      6

      All objects created by the same anonymous class declaration are instances of that very class.
      <code>&lt;?php
      function anonymous_class()
      {
      return new class {};
      }

      if (get_class(anonymous_class()) === get_class(anonymous_class())) {
      echo 'same class';
      } else {
      echo 'different class';
      }

      The above example will output:

      same class

      Note:

      Note that anonymous classes are assigned a name by the engine, as demonstrated in the following example. This name has to be regarded an implementation detail, which should not be relied upon.
      <code>&lt;?php
      echo get_class(new class {});

      The above example will output something similar to:

      class@anonymous/in/oNi1A0x7f8636ad2021



    </section>


    <section class="main-section" id="Overloading">
      <header>Overloading</header>

      Overloading in PHP provides means to dynamically "create" properties and methods. These dynamic entities are processed via magic methods one can establish in a class for various action types.

      The overloading methods are invoked when interacting with properties or methods that have not been declared or are not visible in the current scope. The rest of this section will use the terms "inaccessible properties" and "inaccessible methods" to refer to this combination of declaration and visibility.

      All overloading methods must be defined as public.

      Note:

      None of the arguments of these magic methods can be passed by reference.

      Note:

      PHP's interpretation of "overloading" is different than most object oriented languages. Overloading traditionally provides the ability to have multiple methods with the same name but different quantities and types of arguments.

      Changelog ¶

      Version 	Description
      5.3.0 	Added __callStatic(). Added warning to enforce public visibility and non-static declaration.
      5.1.0 	Added __isset() and __unset(). Added support for __get() for overloading of private properties.
      5.0.0 	Added __get().
      Property overloading ¶
      public void __set ( string $name , mixed $value )
      public mixed __get ( string $name )
      public bool __isset ( string $name )
      public void __unset ( string $name )

      __set() is run when writing data to inaccessible properties.

      __get() is utilized for reading data from inaccessible properties.

      __isset() is triggered by calling isset() or empty() on inaccessible properties.

      __unset() is invoked when unset() is used on inaccessible properties.

      The $name argument is the name of the property being interacted with. The __set() method's $value argument specifies the value the $name'ed property should be set to.

      Property overloading only works in object context. These magic methods will not be triggered in static context. Therefore these methods should not be declared static. As of PHP 5.3.0, a warning is issued if one of the magic overloading methods is declared static.

      Note:

      The return value of __set() is ignored because of the way PHP processes the assignment operator. Similarly, __get() is never called when chaining assignments together like this:

      $a = $obj->b = 8;

      Example #1 Overloading properties via the __get(), __set(), __isset() and __unset() methods
      <code>&lt;?php
      class PropertyTest
      {
      /**  Location for overloaded data.  */
      private $data = array();

      /**  Overloading not used on declared properties.  */
      public $declared = 1;

      /**  Overloading only used on this when accessed outside the class.  */
      private $hidden = 2;

      public function __set($name, $value)
      {
      echo "Setting '$name' to '$value'\n";
      $this->data[$name] = $value;
      }

      public function __get($name)
      {
      echo "Getting '$name'\n";
      if (array_key_exists($name, $this->data)) {
          return $this->data[$name];
      }

      $trace = debug_backtrace();
      trigger_error(
          'Undefined property via __get(): ' . $name .
          ' in ' . $trace[0]['file'] .
          ' on line ' . $trace[0]['line'],
          E_USER_NOTICE);
      return null;
      }

      /**  As of PHP 5.1.0  */
      public function __isset($name)
      {
      echo "Is '$name' set?\n";
      return isset($this->data[$name]);
      }

      /**  As of PHP 5.1.0  */
      public function __unset($name)
      {
      echo "Unsetting '$name'\n";
      unset($this->data[$name]);
      }

      /**  Not a magic method, just here for example.  */
      public function getHidden()
      {
      return $this->hidden;
      }
      }


      echo "<pre>\n";

      $obj = new PropertyTest;

      $obj->a = 1;
      echo $obj->a . "\n\n";

      var_dump(isset($obj->a));
      unset($obj->a);
      var_dump(isset($obj->a));
      echo "\n";

      echo $obj->declared . "\n\n";

      echo "Let's experiment with the private property named 'hidden':\n";
      echo "Privates are visible inside the class, so __get() not used...\n";
      echo $obj->getHidden() . "\n";
      echo "Privates not visible outside of class, so __get() is used...\n";
      echo $obj->hidden . "\n";
      ?&gt;</code>

      The above example will output:

      Setting 'a' to '1'
      Getting 'a'
      1

      Is 'a' set?
      bool(true)
      Unsetting 'a'
      Is 'a' set?
      bool(false)

      1

      Let's experiment with the private property named 'hidden':
      Privates are visible inside the class, so __get() not used...
      2
      Privates not visible outside of class, so __get() is used...
      Getting 'hidden'


      Notice:  Undefined property via __get(): hidden in <file> on line 70 in <file> on line 29

      Method overloading ¶
      public mixed __call ( string $name , array $arguments )
      public static mixed __callStatic ( string $name , array $arguments )

      __call() is triggered when invoking inaccessible methods in an object context.

      __callStatic() is triggered when invoking inaccessible methods in a static context.

      The $name argument is the name of the method being called. The $arguments argument is an enumerated array containing the parameters passed to the $name'ed method.

      Example #2 Overloading methods via the __call() and __callStatic() methods
      <code>&lt;?php
      class MethodTest
      {
      public function __call($name, $arguments)
      {
      // Note: value of $name is case sensitive.
      echo "Calling object method '$name' "
           . implode(', ', $arguments). "\n";
      }

      /**  As of PHP 5.3.0  */
      public static function __callStatic($name, $arguments)
      {
      // Note: value of $name is case sensitive.
      echo "Calling static method '$name' "
           . implode(', ', $arguments). "\n";
      }
      }

      $obj = new MethodTest;
      $obj->runTest('in object context');

      MethodTest::runTest('in static context');  // As of PHP 5.3.0
      ?&gt;</code>

      The above example will output:

      Calling object method 'runTest' in object context
      Calling static method 'runTest' in static context

    </section>


    <section class="main-section" id="Object_Iteration">
      <header>Object Iteration</header>

      PHP 5 provides a way for objects to be defined so it is possible to iterate through a list of items, with, for example a foreach statement. By default, all visible properties will be used for the iteration.

      Example #1 Simple Object Iteration
      <code>&lt;?php
      class MyClass
      {
      public $var1 = 'value 1';
      public $var2 = 'value 2';
      public $var3 = 'value 3';

      protected $protected = 'protected var';
      private   $private   = 'private var';

      function iterateVisible() {
      echo "MyClass::iterateVisible:\n";
      foreach ($this as $key => $value) {
        print "$key => $value\n";
      }
      }
      }

      $class = new MyClass();

      foreach($class as $key => $value) {
      print "$key => $value\n";
      }
      echo "\n";


      $class->iterateVisible();

      ?&gt;</code>

      The above example will output:

      var1 => value 1
      var2 => value 2
      var3 => value 3

      MyClass::iterateVisible:
      var1 => value 1
      var2 => value 2
      var3 => value 3
      protected => protected var
      private => private var

      As the output shows, the foreach iterated through all of the visible properties that could be accessed.

      To take it a step further, the Iterator interface may be implemented. This allows the object to dictate how it will be iterated and what values will be available on each iteration.

      Example #2 Object Iteration implementing Iterator
      <code>&lt;?php
      class MyIterator implements Iterator
      {
      private $var = array();

      public function __construct($array)
      {
      if (is_array($array)) {
         $this->var = $array;
      }
      }

      public function rewind()
      {
      echo "rewinding\n";
      reset($this->var);
      }

      public function current()
      {
      $var = current($this->var);
      echo "current: $var\n";
      return $var;
      }

      public function key()
      {
      $var = key($this->var);
      echo "key: $var\n";
      return $var;
      }

      public function next()
      {
      $var = next($this->var);
      echo "next: $var\n";
      return $var;
      }

      public function valid()
      {
      $key = key($this->var);
      $var = ($key !== NULL && $key !== FALSE);
      echo "valid: $var\n";
      return $var;
      }

      }

      $values = array(1,2,3);
      $it = new MyIterator($values);

      foreach ($it as $a => $b) {
      print "$a: $b\n";
      }
      ?&gt;</code>

      The above example will output:

      rewinding
      valid: 1
      current: 1
      key: 0
      0: 1
      next: 2
      valid: 1
      current: 2
      key: 1
      1: 2
      next: 3
      valid: 1
      current: 3
      key: 2
      2: 3
      next:
      valid:

      The IteratorAggregate interface can be used as an alternative to implementing all of the Iterator methods. IteratorAggregate only requires the implementation of a single method, IteratorAggregate::getIterator(), which should return an instance of a class implementing Iterator.

      Example #3 Object Iteration implementing IteratorAggregate
      <code>&lt;?php
      class MyCollection implements IteratorAggregate
      {
      private $items = array();
      private $count = 0;

      // Required definition of interface IteratorAggregate
      public function getIterator() {
      return new MyIterator($this->items);
      }

      public function add($value) {
      $this->items[$this->count++] = $value;
      }
      }

      $coll = new MyCollection();
      $coll->add('value 1');
      $coll->add('value 2');
      $coll->add('value 3');

      foreach ($coll as $key => $val) {
      echo "key/value: [$key -> $val]\n\n";
      }
      ?&gt;</code>

      The above example will output:

      rewinding
      current: value 1
      valid: 1
      current: value 1
      key: 0
      key/value: [0 -> value 1]

      next: value 2
      current: value 2
      valid: 1
      current: value 2
      key: 1
      key/value: [1 -> value 2]

      next: value 3
      current: value 3
      valid: 1
      current: value 3
      key: 2
      key/value: [2 -> value 3]

      next:
      current:
      valid:

    </section>


    <section class="main-section" id="Magic_Methods">
      <header>Magic Methods</header>

      he function names __construct(), __destruct(), __call(), __callStatic(), __get(), __set(), __isset(), __unset(), __sleep(), __wakeup(), __toString(), __invoke(), __set_state(), __clone() and __debugInfo() are magical in PHP classes. You cannot have functions with these names in any of your classes unless you want the magic functionality associated with them.
      Caution

      PHP reserves all function names starting with __ as magical. It is recommended that you do not use function names with __ in PHP unless you want some documented magic functionality.
      __sleep() and __wakeup() ¶
      public array __sleep ( void )
      void __wakeup ( void )

      serialize() checks if your class has a function with the magic name __sleep(). If so, that function is executed prior to any serialization. It can clean up the object and is supposed to return an array with the names of all variables of that object that should be serialized. If the method doesn't return anything then NULL is serialized and E_NOTICE is issued.

      Note:

      It is not possible for __sleep() to return names of private properties in parent classes. Doing this will result in an E_NOTICE level error. Instead you may use the Serializable interface.

      The intended use of __sleep() is to commit pending data or perform similar cleanup tasks. Also, the function is useful if you have very large objects which do not need to be saved completely.

      Conversely, unserialize() checks for the presence of a function with the magic name __wakeup(). If present, this function can reconstruct any resources that the object may have.

      The intended use of __wakeup() is to reestablish any database connections that may have been lost during serialization and perform other reinitialization tasks.

      Example #1 Sleep and wakeup
      <code>&lt;?php
      class Connection
      {
      protected $link;
      private $dsn, $username, $password;

      public function __construct($dsn, $username, $password)
      {
      $this->dsn = $dsn;
      $this->username = $username;
      $this->password = $password;
      $this->connect();
      }

      private function connect()
      {
      $this->link = new PDO($this->dsn, $this->username, $this->password);
      }

      public function __sleep()
      {
      return array('dsn', 'username', 'password');
      }

      public function __wakeup()
      {
      $this->connect();
      }
      }?&gt;</code>
      __toString() ¶
      public string __toString ( void )

      The __toString() method allows a class to decide how it will react when it is treated like a string. For example, what echo $obj; will print. This method must return a string, as otherwise a fatal E_RECOVERABLE_ERROR level error is emitted.
      Warning

      You cannot throw an exception from within a __toString() method. Doing so will result in a fatal error.

      Example #2 Simple example
      <code>&lt;?php
      // Declare a simple class
      class TestClass
      {
      public $foo;

      public function __construct($foo)
      {
      $this->foo = $foo;
      }

      public function __toString()
      {
      return $this->foo;
      }
      }

      $class = new TestClass('Hello');
      echo $class;
      ?&gt;</code>

      The above example will output:

      Hello

      It is worth noting that before PHP 5.2.0 the __toString() method was only called when it was directly combined with echo or print. Since PHP 5.2.0, it is called in any string context (e.g. in printf() with %s modifier) but not in other types contexts (e.g. with %d modifier). Since PHP 5.2.0, converting objects without __toString() method to string would cause E_RECOVERABLE_ERROR.
      __invoke() ¶
      mixed __invoke ([ $... ] )

      The __invoke() method is called when a script tries to call an object as a function.

      Note:

      This feature is available since PHP 5.3.0.

      Example #3 Using __invoke()
      <code>&lt;?php
      class CallableClass
      {
      public function __invoke($x)
      {
      var_dump($x);
      }
      }
      $obj = new CallableClass;
      $obj(5);
      var_dump(is_callable($obj));
      ?&gt;</code>

      The above example will output:

      int(5)
      bool(true)

      __set_state() ¶
      static object __set_state ( array $properties )

      This static method is called for classes exported by var_export() since PHP 5.1.0.

      The only parameter of this method is an array containing exported properties in the form array('property' => value, ...).

      Example #4 Using __set_state() (since PHP 5.1.0)
      <code>&lt;?php

      class A
      {
      public $var1;
      public $var2;

      public static function __set_state($an_array) // As of PHP 5.1.0
      {
      $obj = new A;
      $obj->var1 = $an_array['var1'];
      $obj->var2 = $an_array['var2'];
      return $obj;
      }
      }

      $a = new A;
      $a->var1 = 5;
      $a->var2 = 'foo';

      eval('$b = ' . var_export($a, true) . ';'); // $b = A::__set_state(array(
                                         //    'var1' => 5,
                                         //    'var2' => 'foo',
                                         // ));
      var_dump($b);

      ?&gt;</code>

      The above example will output:

      object(A)#2 (2) {
      ["var1"]=>
      int(5)
      ["var2"]=>
      string(3) "foo"
      }

      Note: When exporting an object, var_export() does not check whether __set_state() is implemented by the object's class, so re-importing such objects will fail, if __set_state() is not implemented. Particularly, this affects some internal classes. It is the responsibility of the programmer to verify that only objects will be re-imported, whose class implements __set_state().

      __debugInfo() ¶
      array __debugInfo ( void )

      This method is called by var_dump() when dumping an object to get the properties that should be shown. If the method isn't defined on an object, then all public, protected and private properties will be shown.

      This feature was added in PHP 5.6.0.

      Example #5 Using __debugInfo()
      <code>&lt;?php
      class C {
      private $prop;

      public function __construct($val) {
      $this->prop = $val;
      }

      public function __debugInfo() {
      return [
         'propSquared' => $this->prop ** 2,
      ];
      }
      }

      var_dump(new C(42));
      ?&gt;</code>

      The above example will output:

      object(C)#1 (1) {
      ["propSquared"]=>
      int(1764)
      }

    </section>


    <section class="main-section" id="Final_Keyword">
      <header>Final Keyword</header>

      PHP 5 introduces the final keyword, which prevents child classes from overriding a method by prefixing the definition with final. If the class itself is being defined final then it cannot be extended.

      Example #1 Final methods example
      <code>&lt;?php
      class BaseClass {
      public function test() {
      echo "BaseClass::test() called\n";
      }

      final public function moreTesting() {
      echo "BaseClass::moreTesting() called\n";
      }
      }

      class ChildClass extends BaseClass {
      public function moreTesting() {
      echo "ChildClass::moreTesting() called\n";
      }
      }
      // Results in Fatal error: Cannot override final method BaseClass::moreTesting()
      ?&gt;</code>

      Example #2 Final class example
      <code>&lt;?php
      final class BaseClass {
      public function test() {
      echo "BaseClass::test() called\n";
      }

      // Here it doesn't matter if you specify the function as final or not
      final public function moreTesting() {
      echo "BaseClass::moreTesting() called\n";
      }
      }

      class ChildClass extends BaseClass {
      }
      // Results in Fatal error: Class ChildClass may not inherit from final class (BaseClass)
      ?&gt;</code>

      Note: Properties cannot be declared final, only classes and methods may be declared as final.



    </section>


    <section class="main-section" id="Object_Cloning">
      <header>Object Cloning</header>

      Creating a copy of an object with fully replicated properties is not always the wanted behavior. A good example of the need for copy constructors, is if you have an object which represents a GTK window and the object holds the resource of this GTK window, when you create a duplicate you might want to create a new window with the same properties and have the new object hold the resource of the new window. Another example is if your object holds a reference to another object which it uses and when you replicate the parent object you want to create a new instance of this other object so that the replica has its own separate copy.

      An object copy is created by using the clone keyword (which calls the object's __clone() method if possible). An object's __clone() method cannot be called directly.

      $copy_of_object = clone $object;

      When an object is cloned, PHP 5 will perform a shallow copy of all of the object's properties. Any properties that are references to other variables will remain references.
      void __clone ( void )

      Once the cloning is complete, if a __clone() method is defined, then the newly created object's __clone() method will be called, to allow any necessary properties that need to be changed.

      Example #1 Cloning an object
      <code>&lt;?php
      class SubObject
      {
      static $instances = 0;
      public $instance;

      public function __construct() {
      $this->instance = ++self::$instances;
      }

      public function __clone() {
      $this->instance = ++self::$instances;
      }
      }

      class MyCloneable
      {
      public $object1;
      public $object2;

      function __clone()
      {
      // Force a copy of this->object, otherwise
      // it will point to same object.
      $this->object1 = clone $this->object1;
      }
      }

      $obj = new MyCloneable();

      $obj->object1 = new SubObject();
      $obj->object2 = new SubObject();

      $obj2 = clone $obj;


      print("Original Object:\n");
      print_r($obj);

      print("Cloned Object:\n");
      print_r($obj2);

      ?&gt;</code>

      The above example will output:

      Original Object:
      MyCloneable Object
      (
      [object1] => SubObject Object
      (
       [instance] => 1
      )

      [object2] => SubObject Object
      (
       [instance] => 2
      )

      )
      Cloned Object:
      MyCloneable Object
      (
      [object1] => SubObject Object
      (
       [instance] => 3
      )

      [object2] => SubObject Object
      (
       [instance] => 2
      )

      )

      PHP 7.0.0 introduced the possibility to access a member of a freshly cloned object in a single expression:

      Example #2 Access member of freshly cloned object
      <code>&lt;?php
      $dateTime = new DateTime();
      echo (clone $dateTime)->format('Y');
      ?&gt;</code>

      The above example will output something similar to:

      2016

    </section>


    <section class="main-section" id="Comparing_Objects">
      <header>Comparing Objects</header>

      When using the comparison operator (==), object variables are compared in a simple manner, namely: Two object instances are equal if they have the same attributes and values (values are compared with ==), and are instances of the same class.

      When using the identity operator (===), object variables are identical if and only if they refer to the same instance of the same class.

      An example will clarify these rules.

      Example #1 Example of object comparison in PHP 5
      <code>&lt;?php
      function bool2str($bool)
      {
      if ($bool === false) {
      return 'FALSE';
      } else {
      return 'TRUE';
      }
      }

      function compareObjects(&amp$o1, &amp$o2)
      {
      echo 'o1 == o2 : ' . bool2str($o1 == $o2) . "\n";
      echo 'o1 != o2 : ' . bool2str($o1 != $o2) . "\n";
      echo 'o1 === o2 : ' . bool2str($o1 === $o2) . "\n";
      echo 'o1 !== o2 : ' . bool2str($o1 !== $o2) . "\n";
      }

      class Flag
      {
      public $flag;

      function __construct($flag = true) {
      $this->flag = $flag;
      }
      }

      class OtherFlag
      {
      public $flag;

      function __construct($flag = true) {
      $this->flag = $flag;
      }
      }

      $o = new Flag();
      $p = new Flag();
      $q = $o;
      $r = new OtherFlag();

      echo "Two instances of the same class\n";
      compareObjects($o, $p);

      echo "\nTwo references to the same instance\n";
      compareObjects($o, $q);

      echo "\nInstances of two different classes\n";
      compareObjects($o, $r);
      ?&gt;</code>

      The above example will output:

      Two instances of the same class
      o1 == o2 : TRUE
      o1 != o2 : FALSE
      o1 === o2 : FALSE
      o1 !== o2 : TRUE

      Two references to the same instance
      o1 == o2 : TRUE
      o1 != o2 : FALSE
      o1 === o2 : TRUE
      o1 !== o2 : FALSE

      Instances of two different classes
      o1 == o2 : FALSE
      o1 != o2 : TRUE
      o1 === o2 : FALSE
      o1 !== o2 : TRUE

      Note:

      Extensions can define own rules for their objects comparison (==).

    </section>


    <section class="main-section" id="Type_Hinting">
      <header>Type Hinting</header>

      Type declarations allow functions to require that parameters are of a certain type at call time. If the given value is of the incorrect type, then an error is generated: in PHP 5, this will be a recoverable fatal error, while PHP 7 will throw a TypeError exception.

      To specify a type declaration, the type name should be added before the parameter name. The declaration can be made to accept NULL values if the default value of the parameter is set to NULL.
      Valid types ¶
      Type 	Description 	Minimum PHP version
      Class/interface name 	The parameter must be an instanceof the given class or interface name. 	PHP 5.0.0
      self 	The parameter must be an instanceof the same class as the one the method is defined on. This can only be used on class and instance methods. 	PHP 5.0.0
      array 	The parameter must be an array. 	PHP 5.1.0
      callable 	The parameter must be a valid callable. 	PHP 5.4.0
      bool 	The parameter must be a boolean value. 	PHP 7.0.0
      float 	The parameter must be a floating point number. 	PHP 7.0.0
      int 	The parameter must be an integer. 	PHP 7.0.0
      string 	The parameter must be a string. 	PHP 7.0.0
      iterable 	The parameter must be either an array or an instanceof Traversable. 	PHP 7.1.0
      object 	The parameter must be an object. 	PHP 7.2.0
      Warning

      Aliases for the above scalar types are not supported. Instead, they are treated as class or interface names. For example, using boolean as a parameter or return type will require an argument or return value that is an instanceof the class or interface boolean, rather than of type bool:

      <code>&lt;?php
      function test(boolean $param) {}
      test(true);
      ?&gt;</code>

      The above example will output:

      Fatal error: Uncaught TypeError: Argument 1 passed to test() must be an instance of boolean, boolean given, called in - on line 1 and defined in -:1





    </section>


    <section class="main-section" id="Late_Static_Bindings">
      <header>Late Static Bindings</header>

      As of PHP 5.3.0, PHP implements a feature called late static bindings which can be used to reference the called class in a context of static inheritance.

      More precisely, late static bindings work by storing the class named in the last "non-forwarding call". In case of static method calls, this is the class explicitly named (usually the one on the left of the :: operator); in case of non static method calls, it is the class of the object. A "forwarding call" is a static one that is introduced by self::, parent::, static::, or, if going up in the class hierarchy, forward_static_call(). The function get_called_class() can be used to retrieve a string with the name of the called class and static:: introduces its scope.

      This feature was named "late static bindings" with an internal perspective in mind. "Late binding" comes from the fact that static:: will not be resolved using the class where the method is defined but it will rather be computed using runtime information. It was also called a "static binding" as it can be used for (but is not limited to) static method calls.
      Limitations of self:: ¶

      Static references to the current class like self:: or __CLASS__ are resolved using the class in which the function belongs, as in where it was defined:

      Example #1 self:: usage
      <code>&lt;?php
      class A {
      public static function who() {
      echo __CLASS__;
      }
      public static function test() {
      self::who();
      }
      }

      class B extends A {
      public static function who() {
      echo __CLASS__;
      }
      }

      B::test();
      ?&gt;</code>

      The above example will output:

      A

      Late Static Bindings' usage ¶

      Late static bindings tries to solve that limitation by introducing a keyword that references the class that was initially called at runtime. Basically, a keyword that would allow you to reference B from test() in the previous example. It was decided not to introduce a new keyword but rather use static that was already reserved.

      Example #2 static:: simple usage
      <code>&lt;?php
      class A {
      public static function who() {
      echo __CLASS__;
      }
      public static function test() {
      static::who(); // Here comes Late Static Bindings
      }
      }

      class B extends A {
      public static function who() {
      echo __CLASS__;
      }
      }

      B::test();
      ?&gt;</code>

      The above example will output:

      B

      Note:

      In non-static contexts, the called class will be the class of the object instance. Since $this-> will try to call private methods from the same scope, using static:: may give different results. Another difference is that static:: can only refer to static properties.

      Example #3 static:: usage in a non-static context
      <code>&lt;?php
      class A {
      private function foo() {
      echo "success!\n";
      }
      public function test() {
      $this->foo();
      static::foo();
      }
      }

      class B extends A {
      /* foo() will be copied to B, hence its scope will still be A and
      * the call be successful */
      }

      class C extends A {
      private function foo() {
      /* original method is replaced; the scope of the new one is C */
      }
      }

      $b = new B();
      $b->test();
      $c = new C();
      $c->test();   //fails
      ?&gt;</code>

      The above example will output:

      success!
      success!
      success!


      Fatal error:  Call to private method C::foo() from context 'A' in /tmp/test.php on line 9

      Note:

      Late static bindings' resolution will stop at a fully resolved static call with no fallback. On the other hand, static calls using keywords like parent:: or self:: will forward the calling information.

      Example #4 Forwarding and non-forwarding calls
      <code>&lt;?php
      class A {
      public static function foo() {
          static::who();
      }

      public static function who() {
          echo __CLASS__."\n";
      }
      }

      class B extends A {
      public static function test() {
          A::foo();
          parent::foo();
          self::foo();
      }

      public static function who() {
          echo __CLASS__."\n";
      }
      }
      class C extends B {
      public static function who() {
          echo __CLASS__."\n";
      }
      }

      C::test();
      ?&gt;</code>

      The above example will output:

      A
      C
      C



    </section>


    <section class="main-section" id="Objects_and_references">
      <header>Objects and references</header>


      One of the key-points of PHP 5 OOP that is often mentioned is that "objects are passed by references by default". This is not completely true. This section rectifies that general thought using some examples.

      A PHP reference is an alias, which allows two different variables to write to the same value. As of PHP 5, an object variable doesn't contain the object itself as value anymore. It only contains an object identifier which allows object accessors to find the actual object. When an object is sent by argument, returned or assigned to another variable, the different variables are not aliases: they hold a copy of the identifier, which points to the same object.

      Example #1 References and Objects
      <code>&lt;?php
      class A {
      public $foo = 1;
      }

      $a = new A;
      $b = $a;     // $a and $b are copies of the same identifier
              // ($a) = ($b) = <id>
      $b->foo = 2;
      echo $a->foo."\n";


      $c = new A;
      $d = &amp$c;    // $c and $d are references
              // ($c,$d) = <id>

      $d->foo = 2;
      echo $c->foo."\n";


      $e = new A;

      function foo($obj) {
      // ($obj) = ($e) = <id>
      $obj->foo = 2;
      }

      foo($e);
      echo $e->foo."\n";

      ?&gt;</code>

      The above example will output:

      2
      2
      2










    </section>



    <section class="main-section" id="Object_Serialization">
      <header>Object Serialization</header>


      serialize() returns a string containing a byte-stream representation of any value that can be stored in PHP. unserialize() can use this string to recreate the original variable values. Using serialize to save an object will save all variables in an object. The methods in an object will not be saved, only the name of the class.

      In order to be able to unserialize() an object, the class of that object needs to be defined. That is, if you have an object of class A and serialize this, you'll get a string that refers to class A and contains all values of variables contained in it. If you want to be able to unserialize this in another file, an object of class A, the definition of class A must be present in that file first. This can be done for example by storing the class definition of class A in an include file and including this file or making use of the spl_autoload_register() function.
      <code>&lt;?php
      // classa.inc:

      class A {
      public $one = 1;

      public function show_one() {
          echo $this->one;
      }
      }

      // page1.php:

      include("classa.inc");

      $a = new A;
      $s = serialize($a);
      // store $s somewhere where page2.php can find it.
      file_put_contents('store', $s);

      // page2.php:

      // this is needed for the unserialize to work properly.
      include("classa.inc");

      $s = file_get_contents('store');
      $a = unserialize($s);

      // now use the function show_one() of the $a object.
      $a->show_one();
      ?&gt;</code>

      If an application is using sessions and uses session_register() to register objects, these objects are serialized automatically at the end of each PHP page, and are unserialized automatically on each of the following pages. This means that these objects can show up on any of the application's pages once they become part of the session. However, the session_register() is removed since PHP 5.4.0.

      It is strongly recommended that if an application serializes objects, for use later in the application, that the application includes the class definition for that object throughout the application. Not doing so might result in an object being unserialized without a class definition, which will result in PHP giving the object a class of __PHP_Incomplete_Class_Name, which has no methods and would render the object useless.

      So if in the example above $a became part of a session by running session_register("a"), you should include the file classa.inc on all of your pages, not only page1.php and page2.php.

      Beyond the above advice, note that you can also hook into the serialization and unserialization events on an object using the __sleep() and __wakeup() methods. Using __sleep() also allows you to only serialize a subset of the object's properties.





    </section>


    <section class="main-section" id="OOP_Changelog">
      <header>OOP Changelog</header>

      Changes to the PHP 5 OOP model are logged here. Descriptions and other notes regarding these features are documented within the OOP 5 documentation.

      Version 	Description
      7.0.0 	Defining (compatible) properties in two used traits no longer triggers an error.
      5.6.0 	Added: The __debugInfo() method.
      5.5.0 	Added: The ::class magic constant.
      5.5.0 	Added: finally to handle exceptions.
      5.4.0 	Added: traits.
      5.4.0 	Changed: If an abstract class defines a signature for the constructor it will now be enforced.
      5.3.3 	Changed: Methods with the same name as the last element of a namespaced class name will no longer be treated as constructor. This change doesn't affect non-namespaced classes.
      5.3.0 	Changed: Classes that implement interfaces with methods that have default values in the prototype are no longer required to match the interface's default value.
      5.3.0 	Changed: It's now possible to reference the class using a variable (e.g., echo $classname::constant;). The variable's value can not be a keyword (e.g., self, parent or static).
      5.3.0 	Changed: An E_WARNING level error is issued if the magic overloading methods are declared static. It also enforces the public visibility requirement.
      5.3.0 	Changed: Prior to 5.3.0, exceptions thrown in the __autoload() function could not be caught in the catch block, and would result in a fatal error. Exceptions now thrown in the __autoload function can be caught in the catch block, with one provison. If throwing a custom exception, then the custom exception class must be available. The __autoload function may be used recursively to autoload the custom exception class.
      5.3.0 	Added: The __callStatic method.
      5.3.0 	Added: heredoc and nowdoc support for class const and property definitions. Note: heredoc values must follow the same rules as double-quoted strings, (e.g., no variables within).
      5.3.0 	Added: Late Static Bindings.
      5.3.0 	Added: The __invoke() method.
      5.2.0 	Changed: The __toString() method was only called when it was directly combined with echo or print. But now, it is called in any string context (e.g. in printf() with %s modifier) but not in other types contexts (e.g. with %d modifier). Since PHP 5.2.0, converting objects without a __toString method to string emits a E_RECOVERABLE_ERROR level error.
      5.1.3 	Changed: In previous versions of PHP 5, the use of var was considered deprecated and would issue an E_STRICT level error. It's no longer deprecated, therefore does not emit the error.
      5.1.0 	Changed: The __set_state() static method is now called for classes exported by var_export().
      5.1.0 	Added: The __isset() and __unset() methods.





    </section>




    <h1 id="Namespaces"> Namespaces </h1>
    <section class="main-section" id="Namespaces_overview">
      <header>Namespaces overview</header>

      What are namespaces? In the broadest definition namespaces are a way of encapsulating items. This can be seen as an abstract concept in many places. For example, in any operating system directories serve to group related files, and act as a namespace for the files within them. As a concrete example, the file foo.txt can exist in both directory /home/greg and in /home/other, but two copies of foo.txt cannot co-exist in the same directory. In addition, to access the foo.txt file outside of the /home/greg directory, we must prepend the directory name to the file name using the directory separator to get /home/greg/foo.txt. This same principle extends to namespaces in the programming world.

      Version 	Description
      7.0.0 	Added Group use Declarations.

      In the PHP world, namespaces are designed to solve two problems that authors of libraries and applications encounter when creating re-usable code elements such as classes or functions:

      Name collisions between code you create, and internal PHP classes/functions/constants or third-party classes/functions/constants.
      Ability to alias (or shorten) Extra_Long_Names designed to alleviate the first problem, improving readability of source code.

      PHP Namespaces provide a way in which to group related classes, interfaces, functions and constants. Here is an example of namespace syntax in PHP:

      Example #1 Namespace syntax example
      <code>&lt;?php
      namespace my\name; // see "Defining Namespaces" section

      class MyClass {}
      function myfunction() {}
      const MYCONST = 1;

      $a = new MyClass;
      $c = new \my\name\MyClass; // see "Global Space" section

      $a = strlen('hi'); // see "Using namespaces: fallback to global
              // function/constant" section

      $d = namespace\MYCONST; // see "namespace operator and __NAMESPACE__
                   // constant" section
      $d = __NAMESPACE__ . '\MYCONST';
      echo constant($d); // see "Namespaces and dynamic language features" section
      ?&gt;</code>

      Note: Namespace names are case-insensitive.

      Note:

      The Namespace name PHP, and compound names starting with this name (like PHP\Classes) are reserved for internal language use and should not be used in the userspace code.


    </section>


    <section class="main-section" id="Defining_namespaces">
      <header>Defining namespaces</header>

      Although any valid PHP code can be contained within a namespace, only the following types of code are affected by namespaces: classes (including abstracts and traits), interfaces, functions and constants.

      Namespaces are declared using the namespace keyword. A file containing a namespace must declare the namespace at the top of the file before any other code - with one exception: the declare keyword.

      Example #1 Declaring a single namespace
      <code>&lt;?php
      namespace MyProject;

      const CONNECT_OK = 1;
      class Connection { /* ... */ }
      function connect() { /* ... */ }

      ?&gt;</code>
      The only code construct allowed before a namespace declaration is the declare statement, for defining encoding of a source file. In addition, no non-PHP code may precede a namespace declaration, including extra whitespace:

      Example #2 Declaring a single namespace
      <html>
      <code>&lt;?php
      namespace MyProject; // fatal error - namespace must be the first statement in the script
      ?&gt;</code>

      In addition, unlike any other PHP construct, the same namespace may be defined in multiple files, allowing splitting up of a namespace's contents across the filesystem.

    </section>


    <section class="main-section" id="Declaring_sub">
      <header>Declaring sub-namespaces</header>

      Much like directories and files, PHP namespaces also contain the ability to specify a hierarchy of namespace names. Thus, a namespace name can be defined with sub-levels:

      Example #1 Declaring a single namespace with hierarchy
      <code>&lt;?php
      namespace MyProject\Sub\Level;

      const CONNECT_OK = 1;
      class Connection { /* ... */ }
      function connect() { /* ... */  }

      ?&gt;</code>
      The above example creates constant MyProject\Sub\Level\CONNECT_OK, class MyProject\Sub\Level\Connection and function MyProject\Sub\Level\connect.

    </section>


    <section class="main-section" id="Defining_multiple">
      <header>Defining multiple namespaces in the same file</header>

      Multiple namespaces may also be declared in the same file. There are two allowed syntaxes.

      Example #1 Declaring multiple namespaces, simple combination syntax
      <code>&lt;?php
      namespace MyProject;

      const CONNECT_OK = 1;
      class Connection { /* ... */ }
      function connect() { /* ... */  }

      namespace AnotherProject;

      const CONNECT_OK = 1;
      class Connection { /* ... */ }
      function connect() { /* ... */  }
      ?&gt;</code>

      This syntax is not recommended for combining namespaces into a single file. Instead it is recommended to use the alternate bracketed syntax.

      Example #2 Declaring multiple namespaces, bracketed syntax
      <code>&lt;?php
      namespace MyProject {

      const CONNECT_OK = 1;
      class Connection { /* ... */ }
      function connect() { /* ... */  }
      }

      namespace AnotherProject {

      const CONNECT_OK = 1;
      class Connection { /* ... */ }
      function connect() { /* ... */  }
      }
      ?&gt;</code>

      It is strongly discouraged as a coding practice to combine multiple namespaces into the same file. The primary use case is to combine multiple PHP scripts into the same file.

      To combine global non-namespaced code with namespaced code, only bracketed syntax is supported. Global code should be encased in a namespace statement with no namespace name as in:

      Example #3 Declaring multiple namespaces and unnamespaced code
      <code>&lt;?php
      namespace MyProject {

      const CONNECT_OK = 1;
      class Connection { /* ... */ }
      function connect() { /* ... */  }
      }

      namespace { // global code
      session_start();
      $a = MyProject\connect();
      echo MyProject\Connection::start();
      }
      ?&gt;</code>

      No PHP code may exist outside of the namespace brackets except for an opening declare statement.

      Example #4 Declaring multiple namespaces and unnamespaced code
      <code>&lt;?php
      declare(encoding='UTF-8');
      namespace MyProject {

      const CONNECT_OK = 1;
      class Connection { /* ... */ }
      function connect() { /* ... */  }
      }

      namespace { // global code
      session_start();
      $a = MyProject\connect();
      echo MyProject\Connection::start();
      }
      ?&gt;</code>


    </section>


    <section class="main-section" id="Using_namespaces:_Basics">
      <header>Using namespaces: Basics</header>

      Before discussing the use of namespaces, it is important to understand how PHP knows which namespaced element your code is requesting. A simple analogy can be made between PHP namespaces and a filesystem. There are three ways to access a file in a file system:

      Relative file name like foo.txt. This resolves to currentdirectory/foo.txt where currentdirectory is the directory currently occupied. So if the current directory is /home/foo, the name resolves to /home/foo/foo.txt.
      Relative path name like subdirectory/foo.txt. This resolves to currentdirectory/subdirectory/foo.txt.
      Absolute path name like /main/foo.txt. This resolves to /main/foo.txt.

      The same principle can be applied to namespaced elements in PHP. For example, a class name can be referred to in three ways:

      Unqualified name, or an unprefixed class name like $a = new foo(); or foo::staticmethod();. If the current namespace is currentnamespace, this resolves to currentnamespace\foo. If the code is global, non-namespaced code, this resolves to foo. One caveat: unqualified names for functions and constants will resolve to global functions and constants if the namespaced function or constant is not defined. See Using namespaces: fallback to global function/constant for details.
      Qualified name, or a prefixed class name like $a = new subnamespace\foo(); or subnamespace\foo::staticmethod();. If the current namespace is currentnamespace, this resolves to currentnamespace\subnamespace\foo. If the code is global, non-namespaced code, this resolves to subnamespace\foo.
      Fully qualified name, or a prefixed name with global prefix operator like $a = new \currentnamespace\foo(); or \currentnamespace\foo::staticmethod();. This always resolves to the literal name specified in the code, currentnamespace\foo.

      Here is an example of the three kinds of syntax in actual code:

      file1.php
      <code>&lt;?php
      namespace Foo\Bar\subnamespace;

      const FOO = 1;
      function foo() {}
      class foo
      {
      static function staticmethod() {}
      }
      ?&gt;</code>

      file2.php
      <code>&lt;?php
      namespace Foo\Bar;
      include 'file1.php';

      const FOO = 2;
      function foo() {}
      class foo
      {
      static function staticmethod() {}
      }

      /* Unqualified name */
      foo(); // resolves to function Foo\Bar\foo
      foo::staticmethod(); // resolves to class Foo\Bar\foo, method staticmethod
      echo FOO; // resolves to constant Foo\Bar\FOO

      /* Qualified name */
      subnamespace\foo(); // resolves to function Foo\Bar\subnamespace\foo
      subnamespace\foo::staticmethod(); // resolves to class Foo\Bar\subnamespace\foo,
                             // method staticmethod
      echo subnamespace\FOO; // resolves to constant Foo\Bar\subnamespace\FOO

      /* Fully qualified name */
      \Foo\Bar\foo(); // resolves to function Foo\Bar\foo
      \Foo\Bar\foo::staticmethod(); // resolves to class Foo\Bar\foo, method staticmethod
      echo \Foo\Bar\FOO; // resolves to constant Foo\Bar\FOO
      ?&gt;</code>

      Note that to access any global class, function or constant, a fully qualified name can be used, such as \strlen() or \Exception or \INI_ALL.

      Example #1 Accessing global classes, functions and constants from within a namespace
      <code>&lt;?php
      namespace Foo;

      function strlen() {}
      const INI_ALL = 3;
      class Exception {}

      $a = \strlen('hi'); // calls global function strlen
      $b = \INI_ALL; // accesses global constant INI_ALL
      $c = new \Exception('error'); // instantiates global class Exception
      ?&gt;</code>

    </section>


    <section class="main-section" id="Namespaces_and_dynamic_language_features">
      <header>Namespaces and dynamic language features</header>
      PHP's implementation of namespaces is influenced by its dynamic nature as a programming language. Thus, to convert code like the following example into namespaced code:

      Example #1 Dynamically accessing elements

      example1.php:
      <code>&lt;?php
      class classname
      {
      function __construct()
      {
      echo __METHOD__,"\n";
      }
      }
      function funcname()
      {
      echo __FUNCTION__,"\n";
      }
      const constname = "global";

      $a = 'classname';
      $obj = new $a; // prints classname::__construct
      $b = 'funcname';
      $b(); // prints funcname
      echo constant('constname'), "\n"; // prints global
      ?&gt;</code>
      One must use the fully qualified name (class name with namespace prefix). Note that because there is no difference between a qualified and a fully qualified Name inside a dynamic class name, function name, or constant name, the leading backslash is not necessary.

      Example #2 Dynamically accessing namespaced elements
      <code>&lt;?php
      namespace namespacename;
      class classname
      {
      function __construct()
      {
      echo __METHOD__,"\n";
      }
      }
      function funcname()
      {
      echo __FUNCTION__,"\n";
      }
      const constname = "namespaced";

      /* note that if using double quotes, "\\namespacename\\classname" must be used */
      $a = '\namespacename\classname';
      $obj = new $a; // prints namespacename\classname::__construct
      $a = 'namespacename\classname';
      $obj = new $a; // also prints namespacename\classname::__construct
      $b = 'namespacename\funcname';
      $b(); // prints namespacename\funcname
      $b = '\namespacename\funcname';
      $b(); // also prints namespacename\funcname
      echo constant('\namespacename\constname'), "\n"; // prints namespaced
      echo constant('namespacename\constname'), "\n"; // also prints namespaced
      ?&gt;</code>

      Be sure to read the note about escaping namespace names in strings.




    </section>


    <section class="main-section" id="namespace_keyword">
      <header>namespace keyword and __NAMESPACE__ constant</header>

      PHP supports two ways of abstractly accessing elements within the current namespace, the __NAMESPACE__ magic constant, and the namespace keyword.

      The value of __NAMESPACE__ is a string that contains the current namespace name. In global, un-namespaced code, it contains an empty string.

      Example #1 __NAMESPACE__ example, namespaced code
      <code>&lt;?php
      namespace MyProject;

      echo '"', __NAMESPACE__, '"'; // outputs "MyProject"
      ?&gt;</code>

      Example #2 __NAMESPACE__ example, global code
      <code>&lt;?php

      echo '"', __NAMESPACE__, '"'; // outputs ""
      ?&gt;</code>
      The __NAMESPACE__ constant is useful for dynamically constructing names, for instance:

      Example #3 using __NAMESPACE__ for dynamic name construction
      <code>&lt;?php
      namespace MyProject;

      function get($classname)
      {
      $a = __NAMESPACE__ . '\\' . $classname;
      return new $a;
      }
      ?&gt;</code>

      The namespace keyword can be used to explicitly request an element from the current namespace or a sub-namespace. It is the namespace equivalent of the self operator for classes.

      Example #4 the namespace operator, inside a namespace
      <code>&lt;?php
      namespace MyProject;

      use blah\blah as mine; // see "Using namespaces: Aliasing/Importing"

      blah\mine(); // calls function MyProject\blah\mine()
      namespace\blah\mine(); // calls function MyProject\blah\mine()

      namespace\func(); // calls function MyProject\func()
      namespace\sub\func(); // calls function MyProject\sub\func()
      namespace\cname::method(); // calls static method "method" of class MyProject\cname
      $a = new namespace\sub\cname(); // instantiates object of class MyProject\sub\cname
      $b = namespace\CONSTANT; // assigns value of constant MyProject\CONSTANT to $b
      ?&gt;</code>

      Example #5 the namespace operator, in global code
      <code>&lt;?php

      namespace\func(); // calls function func()
      namespace\sub\func(); // calls function sub\func()
      namespace\cname::method(); // calls static method "method" of class cname
      $a = new namespace\sub\cname(); // instantiates object of class sub\cname
      $b = namespace\CONSTANT; // assigns value of constant CONSTANT to $b
      ?&gt;</code>


    </section>


    <section class="main-section" id="Using_namespaces:_Aliasing/Importing">
      <header>Using namespaces: Aliasing/Importing</header>

      The ability to refer to an external fully qualified name with an alias, or importing, is an important feature of namespaces. This is similar to the ability of unix-based filesystems to create symbolic links to a file or to a directory.

      All versions of PHP that support namespaces support three kinds of aliasing or importing: aliasing a class name, aliasing an interface name, and aliasing a namespace name. PHP 5.6+ also allows aliasing or importing function and constant names.

      In PHP, aliasing is accomplished with the use operator. Here is an example showing all 5 kinds of importing:

      Example #1 importing/aliasing with the use operator
      <code>&lt;?php
      namespace foo;
      use My\Full\Classname as Another;

      // this is the same as use My\Full\NSname as NSname
      use My\Full\NSname;

      // importing a global class
      use ArrayObject;

      // importing a function (PHP 5.6+)
      use function My\Full\functionName;

      // aliasing a function (PHP 5.6+)
      use function My\Full\functionName as func;

      // importing a constant (PHP 5.6+)
      use const My\Full\CONSTANT;

      $obj = new namespace\Another; // instantiates object of class foo\Another
      $obj = new Another; // instantiates object of class My\Full\Classname
      NSname\subns\func(); // calls function My\Full\NSname\subns\func
      $a = new ArrayObject(array(1)); // instantiates object of class ArrayObject
      // without the "use ArrayObject" we would instantiate an object of class foo\ArrayObject
      func(); // calls function My\Full\functionName
      echo CONSTANT; // echoes the value of My\Full\CONSTANT
      ?&gt;</code>
      Note that for namespaced names (fully qualified namespace names containing namespace separator, such as Foo\Bar as opposed to global names that do not, such as FooBar), the leading backslash is unnecessary and not recommended, as import names must be fully qualified, and are not processed relative to the current namespace.

      PHP additionally supports a convenience shortcut to place multiple use statements on the same line

      Example #2 importing/aliasing with the use operator, multiple use statements combined
      <code>&lt;?php
      use My\Full\Classname as Another, My\Full\NSname;

      $obj = new Another; // instantiates object of class My\Full\Classname
      NSname\subns\func(); // calls function My\Full\NSname\subns\func
      ?&gt;</code>

      Importing is performed at compile-time, and so does not affect dynamic class, function or constant names.

      Example #3 Importing and dynamic names
      <code>&lt;?php
      use My\Full\Classname as Another, My\Full\NSname;

      $obj = new Another; // instantiates object of class My\Full\Classname
      $a = 'Another';
      $obj = new $a;      // instantiates object of class Another
      ?&gt;</code>

      In addition, importing only affects unqualified and qualified names. Fully qualified names are absolute, and unaffected by imports.

      Example #4 Importing and fully qualified names
      <code>&lt;?php
      use My\Full\Classname as Another, My\Full\NSname;

      $obj = new Another; // instantiates object of class My\Full\Classname
      $obj = new \Another; // instantiates object of class Another
      $obj = new Another\thing; // instantiates object of class My\Full\Classname\thing
      $obj = new \Another\thing; // instantiates object of class Another\thing
      ?&gt;</code>
      Scoping rules for importing ¶

      The use keyword must be declared in the outermost scope of a file (the global scope) or inside namespace declarations. This is because the importing is done at compile time and not runtime, so it cannot be block scoped. The following example will show an illegal use of the use keyword:

      Example #5 Illegal importing rule
      <code>&lt;?php
      namespace Languages;

      function toGreenlandic()
      {
      use Languages\Danish;

      // ...
      }
      ?&gt;</code>

      Note:

      Importing rules are per file basis, meaning included files will NOT inherit the parent file's importing rules.

      Group use declarations ¶

      From PHP 7.0 onwards, classes, functions and constants being imported from the same namespace can be grouped together in a single use statement.
      <code>&lt;?php

      // Pre PHP 7 code
      use some\namespace\ClassA;
      use some\namespace\ClassB;
      use some\namespace\ClassC as C;

      use function some\namespace\fn_a;
      use function some\namespace\fn_b;
      use function some\namespace\fn_c;

      use const some\namespace\ConstA;
      use const some\namespace\ConstB;
      use const some\namespace\ConstC;

      // PHP 7+ code
      use some\namespace\{ClassA, ClassB, ClassC as C};
      use function some\namespace\{fn_a, fn_b, fn_c};
      use const some\namespace\{ConstA, ConstB, ConstC};








    </section>


    <section class="main-section" id="Global_space">
      <header>Global space</header>


      Without any namespace definition, all class and function definitions are placed into the global space - as it was in PHP before namespaces were supported. Prefixing a name with \ will specify that the name is required from the global space even in the context of the namespace.

      Example #1 Using global space specification
      <code>&lt;?php
      namespace A\B\C;

      /* This function is A\B\C\fopen */
      function fopen() {
      /* ... */
      $f = \fopen(...); // call global fopen
      return $f;
      }
      ?&gt;</code>
    </section>


    <section class="main-section" id="Using_namespaces:_fallback_to_global_function/constant<">
      <header>Using namespaces: fallback to global function/constant</header>

      The ability to refer to an external fully qualified name with an alias, or importing, is an important feature of namespaces. This is similar to the ability of unix-based filesystems to create symbolic links to a file or to a directory.

      All versions of PHP that support namespaces support three kinds of aliasing or importing: aliasing a class name, aliasing an interface name, and aliasing a namespace name. PHP 5.6+ also allows aliasing or importing function and constant names.

      In PHP, aliasing is accomplished with the use operator. Here is an example showing all 5 kinds of importing:

      Example #1 importing/aliasing with the use operator
      <code>&lt;?php
      namespace foo;
      use My\Full\Classname as Another;

      // this is the same as use My\Full\NSname as NSname
      use My\Full\NSname;

      // importing a global class
      use ArrayObject;

      // importing a function (PHP 5.6+)
      use function My\Full\functionName;

      // aliasing a function (PHP 5.6+)
      use function My\Full\functionName as func;

      // importing a constant (PHP 5.6+)
      use const My\Full\CONSTANT;

      $obj = new namespace\Another; // instantiates object of class foo\Another
      $obj = new Another; // instantiates object of class My\Full\Classname
      NSname\subns\func(); // calls function My\Full\NSname\subns\func
      $a = new ArrayObject(array(1)); // instantiates object of class ArrayObject
      // without the "use ArrayObject" we would instantiate an object of class foo\ArrayObject
      func(); // calls function My\Full\functionName
      echo CONSTANT; // echoes the value of My\Full\CONSTANT
      ?&gt;</code>
      Note that for namespaced names (fully qualified namespace names containing namespace separator, such as Foo\Bar as opposed to global names that do not, such as FooBar), the leading backslash is unnecessary and not recommended, as import names must be fully qualified, and are not processed relative to the current namespace.

      PHP additionally supports a convenience shortcut to place multiple use statements on the same line

      Example #2 importing/aliasing with the use operator, multiple use statements combined
      <code>&lt;?php
      use My\Full\Classname as Another, My\Full\NSname;

      $obj = new Another; // instantiates object of class My\Full\Classname
      NSname\subns\func(); // calls function My\Full\NSname\subns\func
      ?&gt;</code>

      Importing is performed at compile-time, and so does not affect dynamic class, function or constant names.

      Example #3 Importing and dynamic names
      <code>&lt;?php
      use My\Full\Classname as Another, My\Full\NSname;

      $obj = new Another; // instantiates object of class My\Full\Classname
      $a = 'Another';
      $obj = new $a;      // instantiates object of class Another
      ?&gt;</code>

      In addition, importing only affects unqualified and qualified names. Fully qualified names are absolute, and unaffected by imports.

      Example #4 Importing and fully qualified names
      <code>&lt;?php
      use My\Full\Classname as Another, My\Full\NSname;

      $obj = new Another; // instantiates object of class My\Full\Classname
      $obj = new \Another; // instantiates object of class Another
      $obj = new Another\thing; // instantiates object of class My\Full\Classname\thing
      $obj = new \Another\thing; // instantiates object of class Another\thing
      ?&gt;</code>
      Scoping rules for importing ¶

      The use keyword must be declared in the outermost scope of a file (the global scope) or inside namespace declarations. This is because the importing is done at compile time and not runtime, so it cannot be block scoped. The following example will show an illegal use of the use keyword:

      Example #5 Illegal importing rule
      <code>&lt;?php
      namespace Languages;

      function toGreenlandic()
      {
      use Languages\Danish;

      // ...
      }
      ?&gt;</code>

      Note:

      Importing rules are per file basis, meaning included files will NOT inherit the parent file's importing rules.

      Group use declarations ¶

      From PHP 7.0 onwards, classes, functions and constants being imported from the same namespace can be grouped together in a single use statement.
      <code>&lt;?php

      // Pre PHP 7 code
      use some\namespace\ClassA;
      use some\namespace\ClassB;
      use some\namespace\ClassC as C;

      use function some\namespace\fn_a;
      use function some\namespace\fn_b;
      use function some\namespace\fn_c;

      use const some\namespace\ConstA;
      use const some\namespace\ConstB;
      use const some\namespace\ConstC;

      // PHP 7+ code
      use some\namespace\{ClassA, ClassB, ClassC as C};
      use function some\namespace\{fn_a, fn_b, fn_c};
      use const some\namespace\{ConstA, ConstB, ConstC};


      Inside a namespace, when PHP encounters an unqualified Name in a class name, function or constant context, it resolves these with different priorities. Class names always resolve to the current namespace name. Thus to access internal or non-namespaced user classes, one must refer to them with their fully qualified Name as in:

      Example #1 Accessing global classes inside a namespace
      <code>&lt;?php
      namespace A\B\C;
      class Exception extends \Exception {}

      $a = new Exception('hi'); // $a is an object of class A\B\C\Exception
      $b = new \Exception('hi'); // $b is an object of class Exception

      $c = new ArrayObject; // fatal error, class A\B\C\ArrayObject not found
      ?&gt;</code>

      For functions and constants, PHP will fall back to global functions or constants if a namespaced function or constant does not exist.

      Example #2 global functions/constants fallback inside a namespace
      <code>&lt;?php
      namespace A\B\C;

      const E_ERROR = 45;
      function strlen($str)
      {
      return \strlen($str) - 1;
      }

      echo E_ERROR, "\n"; // prints "45"
      echo INI_ALL, "\n"; // prints "7" - falls back to global INI_ALL

      echo strlen('hi'), "\n"; // prints "1"
      if (is_array('hi')) { // prints "is not array"
      echo "is array\n";
      } else {
      echo "is not array\n";
      }
      ?&gt;</code>

    </section>


    <section class="main-section" id="Name_resolution">
      <header>Name resolution rules</header>

      For the purposes of these resolution rules, here are some important definitions:

      Namespace name definitions
      Unqualified name

      This is an identifier without a namespace separator, such as Foo
      Qualified name

      This is an identifier with a namespace separator, such as Foo\Bar
      Fully qualified name

      This is an identifier with a namespace separator that begins with a namespace separator, such as \Foo\Bar. The namespace \Foo is also a fully qualified name.
      Relative name

      This is an identifier starting with namespace, such as namespace\Foo\Bar.

      Names are resolved following these resolution rules:

      Fully qualified names always resolve to the name without leading namespace separator. For instance \A\B resolves to A\B.
      Relative names always resolve to the name with namespace replaced by the current namespace. If the name occurs in the global namespace, the namespace\ prefix is stripped. For example namespace\A inside namespace X\Y resolves to X\Y\A. The same name inside the global namespace resolves to A.
      For qualified names the first segment of the name is translated according to the current class/namespace import table. For example, if the namespace A\B\C is imported as C, the name C\D\E is translated to A\B\C\D\E.
      For qualified names, if no import rule applies, the current namespace is prepended to the name. For example, the name C\D\E inside namespace A\B, resolves to A\B\C\D\E.
      For unqualified names, the name is translated according to the current import table for the respective symbol type. This means that class-like names are translated according to the class/namespace import table, function names according to the function import table and constants according to the constant import table. For example, after use A\B\C; a usage such as new C() resolves to the name A\B\C(). Similarly, after use function A\B\fn; a usage such as fn() resolves to the name A\B\fn.
      For unqualified names, if no import rule applies and the name refers to a class-like symbol, the current namespace is prepended. For example new C() inside namespace A\B resolves to name A\B\C.
      For unqualified names, if no import rule applies and the name refers to a function or constant and the code is outside the global namespace, the name is resolved at runtime. Assuming the code is in namespace A\B, here is how a call to function foo() is resolved:
      It looks for a function from the current namespace: A\B\foo().
      It tries to find and call the global function foo().

      Example #1 Name resolutions illustrated
      <code>&lt;?php
      namespace A;
      use B\D, C\E as F;

      // function calls

      foo();      // first tries to call "foo" defined in namespace "A"
       // then calls global function "foo"

      \foo();     // calls function "foo" defined in global scope

      my\foo();   // calls function "foo" defined in namespace "A\my"

      F();        // first tries to call "F" defined in namespace "A"
       // then calls global function "F"

      // class references

      new B();    // creates object of class "B" defined in namespace "A"
       // if not found, it tries to autoload class "A\B"

      new D();    // using import rules, creates object of class "D" defined in namespace "B"
       // if not found, it tries to autoload class "B\D"

      new F();    // using import rules, creates object of class "E" defined in namespace "C"
       // if not found, it tries to autoload class "C\E"

      new \B();   // creates object of class "B" defined in global scope
       // if not found, it tries to autoload class "B"

      new \D();   // creates object of class "D" defined in global scope
       // if not found, it tries to autoload class "D"

      new \F();   // creates object of class "F" defined in global scope
       // if not found, it tries to autoload class "F"

      // static methods/namespace functions from another namespace

      B\foo();    // calls function "foo" from namespace "A\B"

      B::foo();   // calls method "foo" of class "B" defined in namespace "A"
       // if class "A\B" not found, it tries to autoload class "A\B"

      D::foo();   // using import rules, calls method "foo" of class "D" defined in namespace "B"
       // if class "B\D" not found, it tries to autoload class "B\D"

      \B\foo();   // calls function "foo" from namespace "B"

      \B::foo();  // calls method "foo" of class "B" from global scope
       // if class "B" not found, it tries to autoload class "B"

      // static methods/namespace functions of current namespace

      A\B::foo();   // calls method "foo" of class "B" from namespace "A\A"
         // if class "A\A\B" not found, it tries to autoload class "A\A\B"

      \A\B::foo();  // calls method "foo" of class "B" from namespace "A"
         // if class "A\B" not found, it tries to autoload class "A\B"
      ?&gt;</code>


    </section>


    <section class="main-section" id="FAQ">
      <header>FAQ: things you need to know about namespaces</header>

      If I don't use namespaces, should I care about any of this? ¶

      No. Namespaces do not affect any existing code in any way, or any as-yet-to-be-written code that does not contain namespaces. You can write this code if you wish:

      Example #1 Accessing global classes outside a namespace
      <code>&lt;?php
      $a = new \stdClass;
      ?&gt;</code>

      This is functionally equivalent to:

      Example #2 Accessing global classes outside a namespace
      <code>&lt;?php
      $a = new stdClass;
      ?&gt;</code>
      How do I use internal or global classes in a namespace? ¶

      Example #3 Accessing internal classes in namespaces
      <code>&lt;?php
      namespace foo;
      $a = new \stdClass;

      function test(\ArrayObject $typehintexample = null) {}

      $a = \DirectoryIterator::CURRENT_AS_FILEINFO;

      // extending an internal or global class
      class MyException extends \Exception {}
      ?&gt;</code>
      How do I use namespaces classes, functions, or constants in their own namespace? ¶

      Example #4 Accessing internal classes, functions or constants in namespaces
      <code>&lt;?php
      namespace foo;

      class MyClass {}

      // using a class from the current namespace as a type hint
      function test(MyClass $typehintexample = null) {}
      // another way to use a class from the current namespace as a type hint
      function test(\foo\MyClass $typehintexample = null) {}

      // extending a class from the current namespace
      class Extended extends MyClass {}

      // accessing a global function
      $a = \globalfunc();

      // accessing a global constant
      $b = \INI_ALL;
      ?&gt;</code>
      How does a name like \my\name or \name resolve? ¶

      Names that begin with a \ always resolve to what they look like, so \my\name is in fact my\name, and \Exception is Exception.

      Example #5 Fully Qualified names
      <code>&lt;?php
      namespace foo;
      $a = new \my\name(); // instantiates "my\name" class
      echo \strlen('hi'); // calls function "strlen"
      $a = \INI_ALL; // $a is set to the value of constant "INI_ALL"
      ?&gt;</code>
      How does a name like my\name resolve? ¶

      Names that contain a backslash but do not begin with a backslash like my\name can be resolved in 2 different ways.

      If there is an import statement that aliases another name to my, then the import alias is applied to the my in my\name.

      Otherwise, the current namespace name is prepended to my\name.

      Example #6 Qualified names
      <code>&lt;?php
      namespace foo;
      use blah\blah as foo;

      $a = new my\name(); // instantiates "foo\my\name" class
      foo\bar::name(); // calls static method "name" in class "blah\blah\bar"
      my\bar(); // calls function "foo\my\bar"
      $a = my\BAR; // sets $a to the value of constant "foo\my\BAR"
      ?&gt;</code>
      How does an unqualified class name like name resolve? ¶

      Class names that do not contain a backslash like name can be resolved in 2 different ways.

      If there is an import statement that aliases another name to name, then the import alias is applied.

      Otherwise, the current namespace name is prepended to name.

      Example #7 Unqualified class names
      <code>&lt;?php
      namespace foo;
      use blah\blah as foo;

      $a = new name(); // instantiates "foo\name" class
      foo::name(); // calls static method "name" in class "blah\blah"
      ?&gt;</code>
      How does an unqualified function name or unqualified constant name like name resolve? ¶

      Function or constant names that do not contain a backslash like name can be resolved in 2 different ways.

      First, the current namespace name is prepended to name.

      Finally, if the constant or function name does not exist in the current namespace, a global constant or function name is used if it exists.

      Example #8 Unqualified function or constant names
      <code>&lt;?php
      namespace foo;
      use blah\blah as foo;

      const FOO = 1;

      function my() {}
      function foo() {}
      function sort(&amp$a)
      {
      \sort($a); // calls the global function "sort"
      $a = array_flip($a);
      return $a;
      }

      my(); // calls "foo\my"
      $a = strlen('hi'); // calls global function "strlen" because "foo\strlen" does not exist
      $arr = array(1,3,2);
      $b = sort($arr); // calls function "foo\sort"
      $c = foo(); // calls function "foo\foo" - import is not applied

      $a = FOO; // sets $a to value of constant "foo\FOO" - import is not applied
      $b = INI_ALL; // sets $b to value of global constant "INI_ALL"
      ?&gt;</code>
      Import names cannot conflict with classes defined in the same file. ¶

      The following script combinations are legal:

      file1.php
      <code>&lt;?php
      namespace my\stuff;
      class MyClass {}
      ?&gt;</code>

      another.php
      <code>&lt;?php
      namespace another;
      class thing {}
      ?&gt;</code>

      file2.php
      <code>&lt;?php
      namespace my\stuff;
      include 'file1.php';
      include 'another.php';

      use another\thing as MyClass;
      $a = new MyClass; // instantiates class "thing" from namespace another
      ?&gt;</code>

      There is no name conflict, even though the class MyClass exists within the my\stuff namespace, because the MyClass definition is in a separate file. However, the next example causes a fatal error on name conflict because MyClass is defined in the same file as the use statement.
      <code>&lt;?php
      namespace my\stuff;
      use another\thing as MyClass;
      class MyClass {} // fatal error: MyClass conflicts with import statement
      $a = new MyClass;
      ?&gt;</code>
      Nested namespaces are not allowed. ¶

      PHP does not allow nesting namespaces
      <code>&lt;?php
      namespace my\stuff {
      namespace nested {
      class foo {}
      }
      }
      ?&gt;</code>
      However, it is easy to simulate nested namespaces like so:
      <code>&lt;?php
      namespace my\stuff\nested {
      class foo {}
      }
      ?&gt;</code>
      Before PHP 5.6 neither functions nor constants can be imported via the use statement. ¶

      Before PHP 5.6 the only elements that are affected by use statements are namespaces and class names. In order to shorten a long constant or function, import its containing namespace.
      <code>&lt;?php
      namespace mine;
      use ultra\long\ns\name;

      $a = name\CONSTANT;
      name\func();
      ?&gt;</code>
      As of PHP 5.6 aliasing or importing function and constant names is allowed.
      Dynamic namespace names (quoted identifiers) should escape backslash ¶

      It is very important to realize that because the backslash is used as an escape character within strings, it should always be doubled when used inside a string. Otherwise there is a risk of unintended consequences:

      Example #9 Dangers of using namespaced names inside a double-quoted string
      <code>&lt;?php
      $a = "dangerous\name"; // \n is a newline inside double quoted strings!
      $obj = new $a;

      $a = 'not\at\all\dangerous'; // no problems here.
      $obj = new $a;
      ?&gt;</code>
      Inside a single-quoted string, the backslash escape sequence is much safer to use, but it is still recommended practice to escape backslashes in all strings as a best practice.
      Undefined Constants referenced using any backslash die with fatal error ¶

      Any undefined constant that is unqualified like FOO will produce a notice explaining that PHP assumed FOO was the value of the constant. Any constant, qualified or fully qualified, that contains a backslash will produce a fatal error if not found.

      Example #10 Undefined constants
      <code>&lt;?php
      namespace bar;
      $a = FOO; // produces notice - undefined constants "FOO" assumed "FOO";
      $a = \FOO; // fatal error, undefined namespace constant FOO
      $a = Bar\FOO; // fatal error, undefined namespace constant bar\Bar\FOO
      $a = \Bar\FOO; // fatal error, undefined namespace constant Bar\FOO
      ?&gt;</code>
      Cannot override special constants NULL, TRUE, FALSE, ZEND_THREAD_SAFE or ZEND_DEBUG_BUILD ¶

      Any attempt to define a namespaced constant that is a special, built-in constant results in a fatal error

      Example #11 Undefined constants
      <code>&lt;?php
      namespace bar;
      const NULL = 0; // fatal error;
      const true = 'stupid'; // also fatal error;
      // etc.
      ?&gt;</code>

    </section>




    <h1 id="Errors"> Errors </h1>
    <section class="main-section" id="Errors_Basics">

      <header>Errors Basics</header>

      PHP reports errors in response to a number of internal error conditions. These may be used to signal a number of different conditions, and can be displayed and/or logged as required.

      Every error that PHP generates includes a type. A list of these types is available, along with a short description of their behaviour and how they can be caused.
      Handling errors with PHP ¶

      If no error handler is set, then PHP will handle any errors that occur according to its configuration. Which errors are reported and which are ignored is controlled by the error_reporting php.ini directive, or at runtime by calling error_reporting(). It is strongly recommended that the configuration directive be set, however, as some errors can occur before execution of your script begins.

      In a development environment, you should always set error_reporting to E_ALL, as you need to be aware of and fix the issues raised by PHP. In production, you may wish to set this to a less verbose level such as E_ALL & ~E_NOTICE & ~E_STRICT & ~E_DEPRECATED, but in many cases E_ALL is also appropriate, as it may provide early warning of potential issues.

      What PHP does with these errors depends on two further php.ini directives. display_errors controls whether the error is shown as part of the script's output. This should always be disabled in a production environment, as it can include confidential information such as database passwords, but is often useful to enable in development, as it ensures immediate reporting of issues.

      In addition to displaying errors, PHP can log errors when the log_errors directive is enabled. This will log any errors to the file or syslog defined by error_log. This can be extremely useful in a production environment, as you can log errors that occur and then generate reports based on those errors.
      User error handlers ¶

      If PHP's default error handling is inadequate, you can also handle many types of error with your own custom error handler by installing it with set_error_handler(). While some error types cannot be handled this way, those that can be handled can then be handled in the way that your script sees fit: for example, this can be used to show a custom error page to the user and then report more directly than via a log, such as by sending an e-mail.


    </section>


    <section class="main-section" id="Errors_in_PHP_7">
      <header>Errors in PHP 7</header>

      PHP 7 changes how most errors are reported by PHP. Instead of reporting errors through the traditional error reporting mechanism used by PHP 5, most errors are now reported by throwing Error exceptions.

      As with normal exceptions, these Error exceptions will bubble up until they reach the first matching catch block. If there are no matching blocks, then any default exception handler installed with set_exception_handler() will be called, and if there is no default exception handler, then the exception will be converted to a fatal error and will be handled like a traditional error.

      As the Error hierarchy does not inherit from Exception, code that uses catch (Exception $e) { ... } blocks to handle uncaught exceptions in PHP 5 will find that these Errors are not caught by these blocks. Either a catch (Error $e) { ... } block or a set_exception_handler() handler is required.

    </section>




    <h1 id="Exceptions"> Exceptions </h1>
    <section class="main-section" id="Extending_Exceptions">
      <header>Extending Exceptions</header>



      A User defined Exception class can be defined by extending the built-in Exception class. The members and properties below, show what is accessible within the child class that derives from the built-in Exception class.

      Example #1 The Built in Exception class
      <code>&lt;?php
      class Exception extends Throwable
      {
      protected $message = 'Unknown exception';   // exception message
      private   $string;                          // __toString cache
      protected $code = 0;                        // user defined exception code
      protected $file;                            // source filename of exception
      protected $line;                            // source line of exception
      private   $trace;                           // backtrace
      private   $previous;                        // previous exception if nested exception

      public function __construct($message = null, $code = 0, Exception $previous = null);

      final private function __clone();           // Inhibits cloning of exceptions.

      final public  function getMessage();        // message of exception
      final public  function getCode();           // code of exception
      final public  function getFile();           // source filename
      final public  function getLine();           // source line
      final public  function getTrace();          // an array of the backtrace()
      final public  function getPrevious();       // previous exception
      final public  function getTraceAsString();  // formatted string of trace

      // Overrideable
      public function __toString();               // formatted string for display
      }
      ?&gt;</code>

      If a class extends the built-in Exception class and re-defines the constructor, it is highly recommended that it also call parent::__construct() to ensure all available data has been properly assigned. The __toString() method can be overridden to provide a custom output when the object is presented as a string.

      Note:

      Exceptions cannot be cloned. Attempting to clone an Exception will result in a fatal E_ERROR error.

      Example #2 Extending the Exception class (PHP 5.3.0+)
      <code>&lt;?php
      /**
      * Define a custom exception class
      */
      class MyException extends Exception
      {
      // Redefine the exception so message isn't optional
      public function __construct($message, $code = 0, Exception $previous = null) {
      // some code

      // make sure everything is assigned properly
      parent::__construct($message, $code, $previous);
      }

      // custom string representation of object
      public function __toString() {
      return __CLASS__ . ": [{$this->code}]: {$this->message}\n";
      }

      public function customFunction() {
      echo "A custom function for this type of exception\n";
      }
      }


      /**
      * Create a class to test the exception
      */
      class TestException
      {
      public $var;

      const THROW_NONE    = 0;
      const THROW_CUSTOM  = 1;
      const THROW_DEFAULT = 2;

      function __construct($avalue = self::THROW_NONE) {

      switch ($avalue) {
       case self::THROW_CUSTOM:
           // throw custom exception
           throw new MyException('1 is an invalid parameter', 5);
           break;

       case self::THROW_DEFAULT:
           // throw default one.
           throw new Exception('2 is not allowed as a parameter', 6);
           break;

       default:
           // No exception, object will be created.
           $this->var = $avalue;
           break;
      }
      }
      }


      // Example 1
      try {
      $o = new TestException(TestException::THROW_CUSTOM);
      } catch (MyException $e) {      // Will be caught
      echo "Caught my exception\n", $e;
      $e->customFunction();
      } catch (Exception $e) {        // Skipped
      echo "Caught Default Exception\n", $e;
      }

      // Continue execution
      var_dump($o); // Null
      echo "\n\n";


      // Example 2
      try {
      $o = new TestException(TestException::THROW_DEFAULT);
      } catch (MyException $e) {      // Doesn't match this type
      echo "Caught my exception\n", $e;
      $e->customFunction();
      } catch (Exception $e) {        // Will be caught
      echo "Caught Default Exception\n", $e;
      }

      // Continue execution
      var_dump($o); // Null
      echo "\n\n";


      // Example 3
      try {
      $o = new TestException(TestException::THROW_CUSTOM);
      } catch (Exception $e) {        // Will be caught
      echo "Default Exception caught\n", $e;
      }

      // Continue execution
      var_dump($o); // Null
      echo "\n\n";


      // Example 4
      try {
      $o = new TestException();
      } catch (Exception $e) {        // Skipped, no exception
      echo "Default Exception caught\n", $e;
      }

      // Continue execution
      var_dump($o); // TestException
      echo "\n\n";
      ?&gt;</code>

      Note:

      Versions of PHP 5, prior to PHP 5.3.0 do not support nesting of exceptions. The following code fragment can be used as a replacement MyException class if you wish to run this example.
      <code>&lt;?php
      /**
      * Define a custom exception class
      */
      class MyException extends Exception
      {
      // Redefine the exception so message isn't optional
      public function __construct($message, $code = 0) {
       // some code

       // make sure everything is assigned properly
       parent::__construct($message, $code);
      }

      // custom string representation of object
      public function __toString() {
       return __CLASS__ . ": [{$this->code}]: {$this->message}\n";
      }

      public function customFunction() {
       echo "A custom function for this type of exception\n";
      }
      }
      ?&gt;</code>

    </section>



    <h1 id="Generators"> Generators </h1>

    Generators provide an easy way to implement simple iterators without the overhead or complexity of implementing a class that implements the Iterator interface.

    A generator allows you to write code that uses foreach to iterate over a set of data without needing to build an array in memory, which may cause you to exceed a memory limit, or require a considerable amount of processing time to generate. Instead, you can write a generator function, which is the same as a normal function, except that instead of returning once, a generator can yield as many times as it needs to in order to provide the values to be iterated over.

    A simple example of this is to reimplement the range() function as a generator. The standard range() function has to generate an array with every value in it and return it, which can result in large arrays: for example, calling range(0, 1000000) will result in well over 100 MB of memory being used.

    As an alternative, we can implement an xrange() generator, which will only ever need enough memory to create an Iterator object and track the current state of the generator internally, which turns out to be less than 1 kilobyte.

    Example #1 Implementing range() as a generator
    <code>&lt;?php
    function xrange($start, $limit, $step = 1) {
    if ($start < $limit) {
    if ($step <= 0) {
        throw new LogicException('Step must be +ve');
    }

    for ($i = $start; $i <= $limit; $i += $step) {
        yield $i;
    }
    } else {
    if ($step >= 0) {
        throw new LogicException('Step must be -ve');
    }

    for ($i = $start; $i >= $limit; $i -= $step) {
        yield $i;
    }
    }
    }

    /*
    * Note that both range() and xrange() result in the same
    * output below.
    */

    echo 'Single digit odd numbers from range():  ';
    foreach (range(1, 9, 2) as $number) {
    echo "$number ";
    }
    echo "\n";

    echo 'Single digit odd numbers from xrange(): ';
    foreach (xrange(1, 9, 2) as $number) {
    echo "$number ";
    }
    ?&gt;</code>

    The above example will output:

    Single digit odd numbers from range():  1 3 5 7 9
    Single digit odd numbers from xrange(): 1 3 5 7 9

    Generator objects ¶

    When a generator function is called, a new object of the internal Generator class is returned. This object implements the Iterator interface in much the same way as a forward-only iterator object would, and provides methods that can be called to manipulate the state of the generator, including sending values to and returning values from it.



    <section class="main-section" id="Generators_overview">
      <header>Generators overview</header>



      A generator function looks just like a normal function, except that instead of returning a value, a generator yields as many values as it needs to.

      When a generator function is called, it returns an object that can be iterated over. When you iterate over that object (for instance, via a foreach loop), PHP will call the object's iteration methods each time it needs a value, then saves the state of the generator when the generator yields a value so that it can be resumed when the next value is required.

      Once there are no more values to be yielded, then the generator can simply exit, and the calling code continues just as if an array has run out of values.

      Note:

      In PHP 5, a generator could not return a value: doing so would result in a compile error. An empty return statement was valid syntax within a generator and it would terminate the generator. Since PHP 7.0, a generator can return values, which can be retrieved using Generator::getReturn().

      yield keyword ¶

      The heart of a generator function is the yield keyword. In its simplest form, a yield statement looks much like a return statement, except that instead of stopping execution of the function and returning, yield instead provides a value to the code looping over the generator and pauses execution of the generator function.

      Example #1 A simple example of yielding values
      <code>&lt;?php
      function gen_one_to_three() {
      for ($i = 1; $i <= 3; $i++) {
      // Note that $i is preserved between yields.
      yield $i;
      }
      }

      $generator = gen_one_to_three();
      foreach ($generator as $value) {
      echo "$value\n";
      }
      ?&gt;</code>

      The above example will output:

      1
      2
      3

      Note:

      Internally, sequential integer keys will be paired with the yielded values, just as with a non-associative array.

      Caution

      If you use yield in an expression context (for example, on the right hand side of an assignment), you must surround the yield statement with parentheses in PHP 5. For example, this is valid:
      $data = (yield $value);

      But this is not, and will result in a parse error in PHP 5:
      $data = yield $value;

      The parenthetical restrictions do not apply in PHP 7.

      The value that will be assigned to $data is the value passed to Generator::send(), or NULL if Generator::next() is called instead.
      Yielding values with keys ¶

      PHP also supports associative arrays, and generators are no different. In addition to yielding simple values, as shown above, you can also yield a key at the same time.

      The syntax for yielding a key/value pair is very similar to that used to define an associative array, as shown below.

      Example #2 Yielding a key/value pair
      <code>&lt;?php
      /*
      * The input is semi-colon separated fields, with the first
      * field being an ID to use as a key.
      */

      $input = &lt;&lt;&lt;'EOF'
      1;PHP;Likes dollar signs
      2;Python;Likes whitespace
      3;Ruby;Likes blocks
      EOF;

      function input_parser($input) {
      foreach (explode("\n", $input) as $line) {
      $fields = explode(';', $line);
      $id = array_shift($fields);

      yield $id => $fields;
      }
      }

      foreach (input_parser($input) as $id => $fields) {
      echo "$id:\n";
      echo "    $fields[0]\n";
      echo "    $fields[1]\n";
      }
      ?&gt;</code>

      The above example will output:

      1:
      PHP
      Likes dollar signs
      2:
      Python
      Likes whitespace
      3:
      Ruby
      Likes blocks

      Caution

      As with the simple value yields shown earlier, yielding a key/value pair in an expression context requires the yield statement to be parenthesised:
      $data = (yield $key => $value);
      Yielding null values ¶

      Yield can be called without an argument to yield a NULL value with an automatic key.

      Example #3 Yielding NULLs
      <code>&lt;?php
      function gen_three_nulls() {
      foreach (range(1, 3) as $i) {
      yield;
      }
      }

      var_dump(iterator_to_array(gen_three_nulls()));
      ?&gt;</code>

      The above example will output:

      array(3) {
      [0]=>
      NULL
      [1]=>
      NULL
      [2]=>
      NULL
      }

      Yielding by reference ¶

      Generator functions are able to yield values by reference as well as by value. This is done in the same way as returning references from functions: by prepending an ampersand to the function name.

      Example #4 Yielding values by reference
      <code>&lt;?php
      function &gen_reference() {
      $value = 3;

      while ($value > 0) {
      yield $value;
      }
      }

      /*
      * Note that we can change $number within the loop, and
      * because the generator is yielding references, $value
      * within gen_reference() changes.
      */
      foreach (gen_reference() as &amp$number) {
      echo (--$number).'... ';
      }
      ?&gt;</code>

      The above example will output:

      2... 1... 0...

      Generator delegation via yield from ¶

      In PHP 7, generator delegation allows you to yield values from another generator, Traversable object, or array by using the yield from keyword. The outer generator will then yield all values from the inner generator, object, or array until that is no longer valid, after which execution will continue in the outer generator.

      If a generator is used with yield from, the yield from expression will also return any value returned by the inner generator.
      Caution
      Storing into an array (e.g. with iterator_to_array())

      yield from does not reset the keys. It preserves the keys returned by the Traversable object, or array. Thus some values may share a common key with another yield or yield from, which, upon insertion into an array, will overwrite former values with that key.

      A common case where this matters is iterator_to_array() returning a keyed array by default, leading to possibly unexpected results. iterator_to_array() has a second parameter use_keys which can be set to FALSE to collect all the values while ignoring the keys returned by the Generator.

      Example #5 yield from with iterator_to_array()
      <code>&lt;?php
      function from() {
      yield 1; // key 0
      yield 2; // key 1
      yield 3; // key 2
      }
      function gen() {
      yield 0; // key 0
      yield from from(); // keys 0-2
      yield 4; // key 1
      }
      // pass false as second parameter to get an array [0, 1, 2, 3, 4]
      var_dump(iterator_to_array(gen()));
      ?&gt;</code>

      The above example will output:

      array(3) {
      [0]=>
      int(1)
      [1]=>
      int(4)
      [2]=>
      int(3)
      }

      Example #6 Basic use of yield from
      <code>&lt;?php
      function count_to_ten() {
      yield 1;
      yield 2;
      yield from [3, 4];
      yield from new ArrayIterator([5, 6]);
      yield from seven_eight();
      yield 9;
      yield 10;
      }

      function seven_eight() {
      yield 7;
      yield from eight();
      }

      function eight() {
      yield 8;
      }

      foreach (count_to_ten() as $num) {
      echo "$num ";
      }
      ?&gt;</code>

      The above example will output:

      1 2 3 4 5 6 7 8 9 10

      Example #7 yield from and return values
      <code>&lt;?php
      function count_to_ten() {
      yield 1;
      yield 2;
      yield from [3, 4];
      yield from new ArrayIterator([5, 6]);
      yield from seven_eight();
      return yield from nine_ten();
      }

      function seven_eight() {
      yield 7;
      yield from eight();
      }

      function eight() {
      yield 8;
      }

      function nine_ten() {
      yield 9;
      return 10;
      }

      $gen = count_to_ten();
      foreach ($gen as $num) {
      echo "$num ";
      }
      echo $gen->getReturn();
      ?&gt;</code>

      The above example will output:

      1 2 3 4 5 6 7 8 9 10

    </section>


    <section class="main-section" id="Generator_syntax">
      <header>Generator syntax</header>






      The primary advantage of generators is their simplicity. Much less boilerplate code has to be written compared to implementing an Iterator class, and the code is generally much more readable. For example, the following function and class are equivalent:
      <code>&lt;?php
      function getLinesFromFile($fileName) {
      if (!$fileHandle = fopen($fileName, 'r')) {
      return;
      }

      while (false !== $line = fgets($fileHandle)) {
      yield $line;
      }

      fclose($fileHandle);
      }

      // versus...

      class LineIterator implements Iterator {
      protected $fileHandle;

      protected $line;
      protected $i;

      public function __construct($fileName) {
      if (!$this->fileHandle = fopen($fileName, 'r')) {
        throw new RuntimeException('Couldn\'t open file "' . $fileName . '"');
      }
      }

      public function rewind() {
      fseek($this->fileHandle, 0);
      $this->line = fgets($this->fileHandle);
      $this->i = 0;
      }

      public function valid() {
      return false !== $this->line;
      }

      public function current() {
      return $this->line;
      }

      public function key() {
      return $this->i;
      }

      public function next() {
      if (false !== $this->line) {
        $this->line = fgets($this->fileHandle);
        $this->i++;
      }
      }

      public function __destruct() {
      fclose($this->fileHandle);
      }
      }
      ?&gt;</code>

      This flexibility does come at a cost, however: generators are forward-only iterators, and cannot be rewound once iteration has started. This also means that the same generator can't be iterated over multiple times: the generator will need to be rebuilt by calling the generator function again.

    </section>


    <section class="main-section" id="Comparing_generators_with_Iterator_objects">
      <header>Comparing generators with Iterator objects</header>

    </section>






    <h1 id="References_Explained"> References Explained </h1>
    <section class="main-section" id="What_References_Are">
      <header>What References Are</header>

      References in PHP are a means to access the same variable content by different names. They are not like C pointers; for instance, you cannot perform pointer arithmetic using them, they are not actual memory addresses, and so on. See What References Are Not for more information. Instead, they are symbol table aliases. Note that in PHP, variable name and variable content are different, so the same content can have different names. The closest analogy is with Unix filenames and files - variable names are directory entries, while variable content is the file itself. References can be likened to hardlinking in Unix filesystem.

    </section>


    <section class="main-section" id="What_References_Do">
      <header>What References Do</header>
      There are three basic operations performed using references: assigning by reference, passing by reference, and returning by reference. This section will give an introduction to these operations, with links for further reading.
      Assign By Reference ¶

      In the first of these, PHP references allow you to make two variables refer to the same content. Meaning, when you do:
      <code>&lt;?php
      $a =& $b;
      ?&gt;</code>
      it means that $a and $b point to the same content.

      Note:

      $a and $b are completely equal here. $a is not pointing to $b or vice versa. $a and $b are pointing to the same place.

      Note:

      If you assign, pass, or return an undefined variable by reference, it will get created.

      Example #1 Using references with undefined variables
      <code>&lt;?php
      function foo(&amp$var) { }

      foo($a); // $a is "created" and assigned to null

      $b = array();
      foo($b['b']);
      var_dump(array_key_exists('b', $b)); // bool(true)

      $c = new StdClass;
      foo($c->d);
      var_dump(property_exists($c, 'd')); // bool(true)
      ?&gt;</code>

      The same syntax can be used with functions that return references:
      <code>&lt;?php
      $foo =& find_var($bar);
      ?&gt;</code>
      Since PHP 5, new returns a reference automatically, so using =& in this context is deprecated and produces an E_DEPRECATED message in PHP 5.3 and later, and an E_STRICT message in earlier versions. As of PHP 7.0 it is syntactically invalid. (Technically, the difference is that, in PHP 5, object variables, much like resources, are a mere pointer to the actual object data, so these object references are not "references" in the same sense used before (aliases). For more information, see Objects and references.)
      Warning

      If you assign a reference to a variable declared global inside a function, the reference will be visible only inside the function. You can avoid this by using the $GLOBALS array.

      Example #2 Referencing global variables inside functions
      <code>&lt;?php
      $var1 = "Example variable";
      $var2 = "";

      function global_references($use_globals)
      {
      global $var1, $var2;
      if (!$use_globals) {
      $var2 =& $var1; // visible only inside the function
      } else {
      $GLOBALS["var2"] =& $var1; // visible also in global context
      }
      }

      global_references(false);
      echo "var2 is set to '$var2'\n"; // var2 is set to ''
      global_references(true);
      echo "var2 is set to '$var2'\n"; // var2 is set to 'Example variable'
      ?&gt;</code>
      Think about global $var; as a shortcut to $var =& $GLOBALS['var'];. Thus assigning another reference to $var only changes the local variable's reference.

      Note:

      If you assign a value to a variable with references in a foreach statement, the references are modified too.

      Example #3 References and foreach statement
      <code>&lt;?php
      $ref = 0;
      $row =& $ref;
      foreach (array(1, 2, 3) as $row) {
      // do something
      }
      echo $ref; // 3 - last element of the iterated array
      ?&gt;</code>

      While not being strictly an assignment by reference, expressions created with the language construct array() can also behave as such by prefixing & to the array element to add. Example:
      <code>&lt;?php
      $a = 1;
      $b = array(2, 3);
      $arr = array(&amp$a, &amp$b[0], &amp$b[1]);
      $arr[0]++; $arr[1]++; $arr[2]++;
      /* $a == 2, $b == array(3, 4); */
      ?&gt;</code>

      Note, however, that references inside arrays are potentially dangerous. Doing a normal (not by reference) assignment with a reference on the right side does not turn the left side into a reference, but references inside arrays are preserved in these normal assignments. This also applies to function calls where the array is passed by value. Example:
      <code>&lt;?php
      /* Assignment of scalar variables */
      $a = 1;
      $b =& $a;
      $c = $b;
      $c = 7; //$c is not a reference; no change to $a or $b

      /* Assignment of array variables */
      $arr = array(1);
      $a =& $arr[0]; //$a and $arr[0] are in the same reference set
      $arr2 = $arr; //not an assignment-by-reference!
      $arr2[0]++;
      /* $a == 2, $arr == array(2) */
      /* The contents of $arr are changed even though it's not a reference! */
      ?&gt;</code>
      In other words, the reference behavior of arrays is defined in an element-by-element basis; the reference behavior of individual elements is dissociated from the reference status of the array container.
      Pass By Reference ¶

      The second thing references do is to pass variables by reference. This is done by making a local variable in a function and a variable in the calling scope referencing the same content. Example:
      <code>&lt;?php
      function foo(&amp$var)
      {
      $var++;
      }

      $a=5;
      foo($a);
      ?&gt;</code>
      will make $a to be 6. This happens because in the function foo the variable $var refers to the same content as $a. For more information on this, read the passing by reference section.


    </section>


    <section class="main-section" id="What_References_Are_Not">
      <header>What References Are Not</header>




      As said before, references are not pointers. That means, the following construct won't do what you expect:
      <code>&lt;?php
      function foo(&amp$var)
      {
      $var =& $GLOBALS["baz"];
      }
      foo($bar);
      ?&gt;</code>

      What happens is that $var in foo will be bound with $bar in the caller, but then re-bound with $GLOBALS["baz"]. There's no way to bind $bar in the calling scope to something else using the reference mechanism, since $bar is not available in the function foo (it is represented by $var, but $var has only variable contents and not name-to-value binding in the calling symbol table). You can use returning references to reference variables selected by the function.

    </section>


    <section class="main-section" id="Passing_by_Reference">
      <header>Passing by Reference</header>


      You can pass a variable by reference to a function so the function can modify the variable. The syntax is as follows:
      <code>&lt;?php
      function foo(&amp$var)
      {
      $var++;
      }

      $a=5;
      foo($a);
      // $a is 6 here
      ?&gt;</code>

      Note: There is no reference sign on a function call - only on function definitions. Function definitions alone are enough to correctly pass the argument by reference. As of PHP 5.3.0, you will get a warning saying that "call-time pass-by-reference" is deprecated when you use & in foo(&amp$a);. And as of PHP 5.4.0, call-time pass-by-reference was removed, so using it will raise a fatal error.

      The following things can be passed by reference:

      Variables, i.e. foo($a)

      References returned from functions, i.e.:
      <code>&lt;?php
      function foo(&amp$var)
      {
      $var++;
      }
      function &bar()
      {
      $a = 5;
      return $a;
      }
      foo(bar());
      ?&gt;</code>
      See more about returning by reference.

      No other expressions should be passed by reference, as the result is undefined. For example, the following examples of passing by reference are invalid:
      <code>&lt;?php
      function foo(&amp$var)
      {
      $var++;
      }
      function bar() // Note the missing &
      {
      $a = 5;
      return $a;
      }
      foo(bar()); // Produces fatal error as of PHP 5.0.5, strict standards notice
       // as of PHP 5.1.1, and notice as of PHP 7.0.0

      foo($a = 5); // Expression, not variable
      foo(5); // Produces fatal error

      class Foobar
      {
      }

      foo(new Foobar()) // Produces a notice as of PHP 7.0.7
             // Notice: Only variables should be passed by reference
      ?&gt;</code>

    </section>


    <section class="main-section" id="Returning_References">
      <header>Returning References</header>


      Returning by reference is useful when you want to use a function to find to which variable a reference should be bound. Do not use return-by-reference to increase performance. The engine will automatically optimize this on its own. Only return references when you have a valid technical reason to do so. To return references, use this syntax:
      <code>&lt;?php
      class foo {
      public $value = 42;

      public function &getValue() {
      return $this->value;
      }
      }

      $obj = new foo;
      $myValue = &amp$obj->getValue(); // $myValue is a reference to $obj->value, which is 42.
      $obj->value = 2;
      echo $myValue;                // prints the new value of $obj->value, i.e. 2.
      ?&gt;</code>
      In this example, the property of the object returned by the getValue function would be set, not the copy, as it would be without using reference syntax.

      Note: Unlike parameter passing, here you have to use & in both places - to indicate that you want to return by reference, not a copy, and to indicate that reference binding, rather than usual assignment, should be done for $myValue.

      Note: If you try to return a reference from a function with the syntax: return ($this->value); this will not work as you are attempting to return the result of an expression, and not a variable, by reference. You can only return variables by reference from a function - nothing else. Since PHP 5.1.0, an E_NOTICE error is issued if the code tries to return a dynamic expression or a result of the new operator.

      To use the returned reference, you must use reference assigment:
      <code>&lt;?php
      function &collector() {
      static $collection = array();
      return $collection;
      }
      $collection = &collector();
      $collection[] = 'foo';
      ?&gt;</code>
      To pass the returned reference to another function expecting a reference you can use this syntax:
      <code>&lt;?php
      function &collector() {
      static $collection = array();
      return $collection;
      }
      array_push(collector(), 'foo');
      ?&gt;</code>

      Note: Note that array_push(&collector(), 'foo'); will not work, it results in a fatal error.


    </section>


    <section class="main-section" id="Unsetting_References">
      <header>Unsetting References</header>


      When you unset the reference, you just break the binding between variable name and variable content. This does not mean that variable content will be destroyed. For example:
      <code>&lt;?php
      $a = 1;
      $b =& $a;
      unset($a);
      ?&gt;</code>
      won't unset $b, just $a.

      Again, it might be useful to think about this as analogous to the Unix unlink call.


    </section>


    <section class="main-section" id="Spotting_References">
      <header>Spotting References</header>
      Many syntax constructs in PHP are implemented via referencing mechanisms, so everything mentioned herein about reference binding also applies to these constructs. Some constructs, like passing and returning by reference, are mentioned above. Other constructs that use references are:
      global References ¶

      When you declare a variable as global $var you are in fact creating reference to a global variable. That means, this is the same as:
      <code>&lt;?php
      $var =& $GLOBALS["var"];
      ?&gt;</code>

      This also means that unsetting $var won't unset the global variable.
      $this ¶

      In an object method, $this is always a reference to the called object.


    </section>



    <h1 id="Predefined_Variables"> Predefined Variables </h1>
    <section class="main-section" id="Superglobals_—_Superglobals_are_built-in_variables_that_are_always_available_in_all_scopes">
      <header>Superglobals — Superglobals are built-in variables that are always available in all scopes</header>
      Superglobals — Superglobals are built-in variables that are always available in all scopes
      Description ¶

      Several predefined variables in PHP are "superglobals", which means they are available in all scopes throughout a script. There is no need to do global $variable; to access them within functions or methods.

      These superglobal variables are:

      $GLOBALS
      $_SERVER
      $_GET
      $_POST
      $_FILES
      $_COOKIE
      $_SESSION
      $_REQUEST
      $_ENV
    </section>


    <section class="main-section" id="$GLOBALS_—_References_all_variables_available_in_global_scope">
      <header>$GLOBALS — References all variables available in global scope</header>

      $GLOBALS — References all variables available in global scope
      Description ¶

      An associative array containing references to all variables which are currently defined in the global scope of the script. The variable names are the keys of the array.
      Examples ¶

      Example #1 $GLOBALS example
      <code>&lt;?php
      function test() {
      $foo = "local variable";

      echo '$foo in global scope: ' . $GLOBALS["foo"] . "\n";
      echo '$foo in current scope: ' . $foo . "\n";
      }

      $foo = "Example content";
      test();
      ?&gt;</code>

      The above example will output something similar to:

      $foo in global scope: Example content
      $foo in current scope: local variable


    </section>


    <section class="main-section" id="$_SERVER_—_Server_and_execution_environment_information">
      <header>$_SERVER — Server and execution environment information</header>


      $_SERVER -- $HTTP_SERVER_VARS [removed] — Server and execution environment information
      Description ¶

      $_SERVER is an array containing information such as headers, paths, and script locations. The entries in this array are created by the web server. There is no guarantee that every web server will provide any of these; servers may omit some, or provide others not listed here. That said, a large number of these variables are accounted for in the » CGI/1.1 specification, so you should be able to expect those.

      Note: Prior to PHP 5.4.0, $HTTP_SERVER_VARS contained the same initial information, but was not a superglobal. (Note that $HTTP_SERVER_VARS and $_SERVER were different variables and that PHP handled them as such.)

      Indices ¶

      You may or may not find any of the following elements in $_SERVER. Note that few, if any, of these will be available (or indeed have any meaning) if running PHP on the command line.

      'PHP_SELF'
      The filename of the currently executing script, relative to the document root. For instance, $_SERVER['PHP_SELF'] in a script at the address http://example.com/foo/bar.php would be /foo/bar.php. The __FILE__ constant contains the full path and filename of the current (i.e. included) file. If PHP is running as a command-line processor this variable contains the script name since PHP 4.3.0. Previously it was not available.
      'argv'
      Array of arguments passed to the script. When the script is run on the command line, this gives C-style access to the command line parameters. When called via the GET method, this will contain the query string.
      'argc'
      Contains the number of command line parameters passed to the script (if run on the command line).
      'GATEWAY_INTERFACE'
      What revision of the CGI specification the server is using; i.e. 'CGI/1.1'.
      'SERVER_ADDR'
      The IP address of the server under which the current script is executing.
      'SERVER_NAME'
      The name of the server host under which the current script is executing. If the script is running on a virtual host, this will be the value defined for that virtual host.

         Note: Under Apache 2, you must set UseCanonicalName = On and ServerName. Otherwise, this value reflects the hostname supplied by the client, which can be spoofed. It is not safe to rely on this value in security-dependent contexts.

      'SERVER_SOFTWARE'
      Server identification string, given in the headers when responding to requests.
      'SERVER_PROTOCOL'
      Name and revision of the information protocol via which the page was requested; i.e. 'HTTP/1.0';
      'REQUEST_METHOD'
      Which request method was used to access the page; i.e. 'GET', 'HEAD', 'POST', 'PUT'.

         Note:

         PHP script is terminated after sending headers (it means after producing any output without output buffering) if the request method was HEAD.

      'REQUEST_TIME'
      The timestamp of the start of the request. Available since PHP 5.1.0.
      'REQUEST_TIME_FLOAT'
      The timestamp of the start of the request, with microsecond precision. Available since PHP 5.4.0.
      'QUERY_STRING'
      The query string, if any, via which the page was accessed.
      'DOCUMENT_ROOT'
      The document root directory under which the current script is executing, as defined in the server's configuration file.
      'HTTP_ACCEPT'
      Contents of the Accept: header from the current request, if there is one.
      'HTTP_ACCEPT_CHARSET'
      Contents of the Accept-Charset: header from the current request, if there is one. Example: 'iso-8859-1,*,utf-8'.
      'HTTP_ACCEPT_ENCODING'
      Contents of the Accept-Encoding: header from the current request, if there is one. Example: 'gzip'.
      'HTTP_ACCEPT_LANGUAGE'
      Contents of the Accept-Language: header from the current request, if there is one. Example: 'en'.
      'HTTP_CONNECTION'
      Contents of the Connection: header from the current request, if there is one. Example: 'Keep-Alive'.
      'HTTP_HOST'
      Contents of the Host: header from the current request, if there is one.
      'HTTP_REFERER'
      The address of the page (if any) which referred the user agent to the current page. This is set by the user agent. Not all user agents will set this, and some provide the ability to modify HTTP_REFERER as a feature. In short, it cannot really be trusted.
      'HTTP_USER_AGENT'
      Contents of the User-Agent: header from the current request, if there is one. This is a string denoting the user agent being which is accessing the page. A typical example is: Mozilla/4.5 [en] (X11; U; Linux 2.2.9 i586). Among other things, you can use this value with get_browser() to tailor your page's output to the capabilities of the user agent.
      'HTTPS'
      Set to a non-empty value if the script was queried through the HTTPS protocol.

         Note: Note that when using ISAPI with IIS, the value will be off if the request was not made through the HTTPS protocol.

      'REMOTE_ADDR'
      The IP address from which the user is viewing the current page.
      'REMOTE_HOST'
      The Host name from which the user is viewing the current page. The reverse dns lookup is based on the REMOTE_ADDR of the user.

         Note: Your web server must be configured to create this variable. For example in Apache you'll need HostnameLookups On inside httpd.conf for it to exist. See also gethostbyaddr().

      'REMOTE_PORT'
      The port being used on the user's machine to communicate with the web server.
      'REMOTE_USER'
      The authenticated user.
      'REDIRECT_REMOTE_USER'
      The authenticated user if the request is internally redirected.
      'SCRIPT_FILENAME'

      The absolute pathname of the currently executing script.

         Note:

         If a script is executed with the CLI, as a relative path, such as file.php or ../file.php, $_SERVER['SCRIPT_FILENAME'] will contain the relative path specified by the user.

      'SERVER_ADMIN'
      The value given to the SERVER_ADMIN (for Apache) directive in the web server configuration file. If the script is running on a virtual host, this will be the value defined for that virtual host.
      'SERVER_PORT'
      The port on the server machine being used by the web server for communication. For default setups, this will be '80'; using SSL, for instance, will change this to whatever your defined secure HTTP port is.

         Note: Under the Apache 2, you must set UseCanonicalName = On, as well as UseCanonicalPhysicalPort = On in order to get the physical (real) port, otherwise, this value can be spoofed and it may or may not return the physical port value. It is not safe to rely on this value in security-dependent contexts.

      'SERVER_SIGNATURE'
      String containing the server version and virtual host name which are added to server-generated pages, if enabled.
      'PATH_TRANSLATED'
      Filesystem- (not document root-) based path to the current script, after the server has done any virtual-to-real mapping.

         Note: As of PHP 4.3.2, PATH_TRANSLATED is no longer set implicitly under the Apache 2 SAPI in contrast to the situation in Apache 1, where it's set to the same value as the SCRIPT_FILENAME server variable when it's not populated by Apache. This change was made to comply with the CGI specification that PATH_TRANSLATED should only exist if PATH_INFO is defined. Apache 2 users may use AcceptPathInfo = On inside httpd.conf to define PATH_INFO.

      'SCRIPT_NAME'
      Contains the current script's path. This is useful for pages which need to point to themselves. The __FILE__ constant contains the full path and filename of the current (i.e. included) file.
      'REQUEST_URI'
      The URI which was given in order to access this page; for instance, '/index.html'.
      'PHP_AUTH_DIGEST'
      When doing Digest HTTP authentication this variable is set to the 'Authorization' header sent by the client (which you should then use to make the appropriate validation).
      'PHP_AUTH_USER'
      When doing HTTP authentication this variable is set to the username provided by the user.
      'PHP_AUTH_PW'
      When doing HTTP authentication this variable is set to the password provided by the user.
      'AUTH_TYPE'
      When doing HTTP authentication this variable is set to the authentication type.
      'PATH_INFO'
      Contains any client-provided pathname information trailing the actual script filename but preceding the query string, if available. For instance, if the current script was accessed via the URL http://www.example.com/php/path_info.php/some/stuff?foo=bar, then $_SERVER['PATH_INFO'] would contain /some/stuff.
      'ORIG_PATH_INFO'
      Original version of 'PATH_INFO' before processed by PHP.


      Examples ¶

      Example #1 $_SERVER example
      <code>&lt;?php
      echo $_SERVER['SERVER_NAME'];
      ?&gt;</code>

      The above example will output something similar to:

      www.example.com

    </section>


    <section class="main-section" id="$_GET_—_HTTP_GET_variables">
      <header>$_GET — HTTP GET variables</header>
      $_GET -- $HTTP_GET_VARS [deprecated] — HTTP GET variables
      Description ¶

      An associative array of variables passed to the current script via the URL parameters (aka. query string). Note that the array is not only populated for GET requests, but rather for all requests with a query string.

      $HTTP_GET_VARS contains the same initial information, but is not a superglobal. (Note that $HTTP_GET_VARS and $_GET are different variables and that PHP handles them as such)
      Changelog ¶
      Version 	Description
      4.1.0 	Introduced $_GET that deprecated $HTTP_GET_VARS.
      Examples ¶

      Example #1 $_GET example
      <code>&lt;?php
      echo 'Hello ' . htmlspecialchars($_GET["name"]) . '!';
      ?&gt;</code>

      Assuming the user entered http://example.com/?name=Hannes

      The above example will output something similar to:

      Hello Hannes!





    </section>


    <section class="main-section" id="$_POST_—_HTTP_POST_variables">
      <header>$_POST — HTTP POST variables</header>
      $_POST -- $HTTP_POST_VARS [deprecated] — HTTP POST variables
      Description ¶

      An associative array of variables passed to the current script via the HTTP POST method when using application/x-www-form-urlencoded or multipart/form-data as the HTTP Content-Type in the request.

      $HTTP_POST_VARS contains the same initial information, but is not a superglobal. (Note that $HTTP_POST_VARS and $_POST are different variables and that PHP handles them as such)
      Examples ¶

      Example #1 $_POST example
      <code>&lt;?php
      echo 'Hello ' . htmlspecialchars($_POST["name"]) . '!';
      ?&gt;</code>

      Assuming the user POSTed name=Hannes

      The above example will output something similar to:

      Hello Hannes!


    </section>


    <section class="main-section" id="$_FILES_—_HTTP_File_Upload_variables">
      <header>$_FILES — HTTP File Upload variables</header>

      $_FILES -- $HTTP_POST_FILES [deprecated] — HTTP File Upload variables
      Description ¶

      An associative array of items uploaded to the current script via the HTTP POST method. The structure of this array is outlined in the POST method uploads section.

      $HTTP_POST_FILES contains the same initial information, but is not a superglobal. (Note that $HTTP_POST_FILES and $_FILES are different variables and that PHP handles them as such)

    </section>


    <section class="main-section" id="$_REQUEST_—_HTTP_Request_variables">
      <header>$_REQUEST — HTTP Request variables</header>

      $_REQUEST — HTTP Request variables
      Description ¶

      An associative array that by default contains the contents of $_GET, $_POST and $_COOKIE.


    </section>


    <section class="main-section" id="$_SESSION_—_Session_variables">
      <header>$_SESSION — Session variables</header>

      $_SESSION -- $HTTP_SESSION_VARS [deprecated] — Session variables
      Description ¶

      An associative array containing session variables available to the current script. See the Session functions documentation for more information on how this is used.

      $HTTP_SESSION_VARS contains the same initial information, but is not a superglobal. (Note that $HTTP_SESSION_VARS and $_SESSION are different variables and that PHP handles them as such)

    </section>


    <section class="main-section" id="$_ENV_—_Environment_variables">
      <header>$_ENV — Environment variables</header>
      _ENV -- $HTTP_ENV_VARS [deprecated] — Environment variables
      Description ¶

      An associative array of variables passed to the current script via the environment method.

      These variables are imported into PHP's global namespace from the environment under which the PHP parser is running. Many are provided by the shell under which PHP is running and different systems are likely running different kinds of shells, a definitive list is impossible. Please see your shell's documentation for a list of defined environment variables.

      Other environment variables include the CGI variables, placed there regardless of whether PHP is running as a server module or CGI processor.

      $HTTP_ENV_VARS contains the same initial information, but is not a superglobal. (Note that $HTTP_ENV_VARS and $_ENV are different variables and that PHP handles them as such)



      Examples ¶

      Example #1 $_ENV example
      <code>&lt;?php
      echo 'My username is ' .$_ENV["USER"] . '!';
      ?&gt;</code>

      Assuming "bjori" executes this script

      The above example will output something similar to:

      My username is bjori!
    </section>


    <section class="main-section" id="$_COOKIE_—_HTTP_Cookies">
      <header>$_COOKIE — HTTP Cookies</header>
      $_COOKIE -- $HTTP_COOKIE_VARS [deprecated] — HTTP Cookies
      Description ¶

      An associative array of variables passed to the current script via HTTP Cookies.

      $HTTP_COOKIE_VARS contains the same initial information, but is not a superglobal. (Note that $HTTP_COOKIE_VARS and $_COOKIE are different variables and that PHP handles them as such)





      Examples ¶

      Example #1 $_COOKIE example
      <code>&lt;?php
      echo 'Hello ' . htmlspecialchars($_COOKIE["name"]) . '!';
      ?&gt;</code>

      Assuming the "name" cookie has been set earlier

      The above example will output something similar to:

      Hello Hannes!
    </section>


    <section class="main-section" id="$php_errormsg_—_The_previous_error_message">
      <header>$php_errormsg — The previous error message</header>






      $php_errormsg — The previous error message
      Warning

      This feature has been DEPRECATED as of PHP 7.2.0. Relying on this feature is highly discouraged.

      Example #1 $php_errormsg example
      <code>&lt;?php
      @strpos();
      echo $php_errormsg;
      ?&gt;</code>
      The above example will output something similar to:

      Wrong parameter count for strpos()


    </section>


    <section class="main-section" id="$HTTP_RAW_POST_DATA_—_Raw_POST_data">
      <header>$HTTP_RAW_POST_DATA — Raw POST data</header>



      $HTTP_RAW_POST_DATA — Raw POST data
      Description ¶
      Warning

      This feature was DEPRECATED in PHP 5.6.0, and REMOVED as of PHP 7.0.0.

      $HTTP_RAW_POST_DATA contains the raw POST data. See always_populate_raw_post_data.

      In general, php://input should be used instead of $HTTP_RAW_POST_DATA.


    </section>


    <section class="main-section" id="$http_response_header_—_HTTP_response_headers">
      <header>$http_response_header — HTTP response headers</header>

      $http_response_header — HTTP response headers
      Description ¶

      The $http_response_header array is similar to the get_headers() function. When using the HTTP wrapper, $http_response_header will be populated with the HTTP response headers. $http_response_header will be created in the local scope.
      Examples ¶

      Example #1 $http_response_header example
      <code>&lt;?php
      function get_contents() {
      file_get_contents("http://example.com");
      var_dump($http_response_header);
      }
      get_contents();
      var_dump($http_response_header);
      ?&gt;</code>

      The above example will output something similar to:

      array(9) {
      [0]=>
      string(15) "HTTP/1.1 200 OK"
      [1]=>
      string(35) "Date: Sat, 12 Apr 2008 17:30:38 GMT"
      [2]=>
      string(29) "Server: Apache/2.2.3 (CentOS)"
      [3]=>
      string(44) "Last-Modified: Tue, 15 Nov 2005 13:24:10 GMT"
      [4]=>
      string(27) "ETag: "280100-1b6-80bfd280""
      [5]=>
      string(20) "Accept-Ranges: bytes"
      [6]=>
      string(19) "Content-Length: 438"
      [7]=>
      string(17) "Connection: close"
      [8]=>
      string(38) "Content-Type: text/html; charset=UTF-8"
      }
      NULL

    </section>


    <section class="main-section" id="$argc_—_The_number_of_arguments_passed_to_script">
      <header>$argc — The number of arguments passed to script</header>
      $argc — The number of arguments passed to script
      Description ¶

      Contains the number of arguments passed to the current script when running from the command line.

      Note: The script's filename is always passed as an argument to the script, therefore the minimum value of $argc is 1.

      Note: This variable is not available when register_argc_argv is disabled.

      Examples ¶

      Example #1 $argc example
      <code>&lt;?php
      var_dump($argc);
      ?&gt;</code>

      When executing the example with: php script.php arg1 arg2 arg3

      The above example will output something similar to:

      int(4)
    </section>


    <section class="main-section" id="$argv_—_Array_of_arguments_passed_to_script">
      <header>$argv — Array of arguments passed to script</header>

      $argv — Array of arguments passed to script
      Description ¶

      Contains an array of all the arguments passed to the script when running from the command line.

      Note: The first argument $argv[0] is always the name that was used to run the script.

      Note: This variable is not available when register_argc_argv is disabled.

      Examples ¶

      Example #1 $argv example
      <code>&lt;?php
      var_dump($argv);
      ?&gt;</code>

      When executing the example with: php script.php arg1 arg2 arg3

      The above example will output something similar to:

      array(4) {
      [0]=>
      string(10) "script.php"
      [1]=>
      string(4) "arg1"
      [2]=>
      string(4) "arg2"
      [3]=>
      string(4) "arg3"
      }

      Notes ¶

      Note:

      This is also available as $_SERVER['argv'].
    </section>





    <h1 id="Predefined_Exceptions"> Predefined Exceptions </h1>
    <section class="main-section" id="Exception">
      <header>Exception</header>
      Exception is the base class for all Exceptions in PHP 5, and the base class for all user exceptions in PHP 7.

      Before PHP 7, Exception did not implement the Throwable interface.
      Class synopsis ¶
      Exception implements Throwable {
      /* Properties */
      protected string $message ;
      protected int $code ;
      protected string $file ;
      protected int $line ;
      /* Methods */
      public __construct ([ string $message = "" [, int $code = 0 [, Throwable $previous = NULL ]]] )
      final public string getMessage ( void )
      final public Throwable getPrevious ( void )
      final public mixed getCode ( void )
      final public string getFile ( void )
      final public int getLine ( void )
      final public array getTrace ( void )
      final public string getTraceAsString ( void )
      public string __toString ( void )
      final private void __clone ( void )
      }
      Properties ¶

      message

      The exception message
      code

      The exception code
      file

      The filename where the exception was created
      line

      The line where the exception was created


      Table of Contents ¶

       Exception::__construct — Construct the exception
       Exception::getMessage — Gets the Exception message
       Exception::getPrevious — Returns previous Exception
       Exception::getCode — Gets the Exception code
       Exception::getFile — Gets the file in which the exception was created
       Exception::getLine — Gets the line in which the exception was created
       Exception::getTrace — Gets the stack trace
       Exception::getTraceAsString — Gets the stack trace as a string
       Exception::__toString — String representation of the exception
       Exception::__clone — Clone the exception

    </section>


    <section class="main-section" id="ErrorException">
      <header>ErrorException</header>



       An Error Exception.
      Class synopsis ¶
      ErrorException extends Exception {
      /* Properties */
      protected int $severity ;
      /* Inherited properties */
      protected string $message ;
      protected int $code ;
      protected string $file ;
      protected int $line ;
      /* Methods */
      public __construct ([ string $message = "" [, int $code = 0 [, int $severity = E_ERROR [, string $filename = __FILE__ [, int $lineno = __LINE__ [, Exception $previous = NULL ]]]]]] )
      final public int getSeverity ( void )
      /* Inherited methods */
      final public string Exception::getMessage ( void )
      final public Throwable Exception::getPrevious ( void )
      final public mixed Exception::getCode ( void )
      final public string Exception::getFile ( void )
      final public int Exception::getLine ( void )
      final public array Exception::getTrace ( void )
      final public string Exception::getTraceAsString ( void )
      public string Exception::__toString ( void )
      final private void Exception::__clone ( void )
      }
      Properties ¶

      severity

          The severity of the exception

      Examples ¶

      Example #1 Use set_error_handler() to change error messages into ErrorException.
      <code>&lt;?php
      function exception_error_handler($severity, $message, $file, $line) {
          if (!(error_reporting() & $severity)) {
              // This error code is not included in error_reporting
              return;
          }
          throw new ErrorException($message, 0, $severity, $file, $line);
      }
      set_error_handler("exception_error_handler");

      /* Trigger exception */
      strpos();
      ?&gt;</code>

      The above example will output something similar to:

      Fatal error: Uncaught exception 'ErrorException' with message 'strpos() expects at least 2 parameters, 0 given' in /home/bjori/tmp/ex.php:12
      Stack trace:
      #0 [internal function]: exception_error_handler(2, 'strpos() expect...', '/home/bjori/php...', 12, Array)
      #1 /home/bjori/php/cleandocs/test.php(12): strpos()
      #2 {main}
        thrown in /home/bjori/tmp/ex.php on line 12

    </section>


    <section class="main-section" id="Error">
      <header>Error</header>
      Error is the base class for all internal PHP errors.
      Class synopsis ¶
      Error implements Throwable {
      /* Properties */
      protected string $message ;
      protected int $code ;
      protected string $file ;
      protected int $line ;
      /* Methods */
      public __construct ([ string $message = "" [, int $code = 0 [, Throwable $previous = NULL ]]] )
      final public string getMessage ( void )
      final public Throwable getPrevious ( void )
      final public mixed getCode ( void )
      final public string getFile ( void )
      final public int getLine ( void )
      final public array getTrace ( void )
      final public string getTraceAsString ( void )
      public string __toString ( void )
      final private void __clone ( void )
      }
      Properties ¶

      message

         The error message
      code

         The error code
      file

         The filename where the error happened
      line

         The line where the error happened

    </section>



    <section class="main-section" id="ArgumentCountError">
      <header>ArgumentCountError</header>


           ArgumentCountError is thrown when too few arguments are passed to a user-defined function or method.
          Class synopsis ¶
          ArgumentCountError extends TypeError {
          /* Inherited properties */
          protected string $message ;
          protected int $code ;
          protected string $file ;
          protected int $line ;
          /* Inherited methods */
          final public string Error::getMessage ( void )
          final public Throwable Error::getPrevious ( void )
          final public mixed Error::getCode ( void )
          final public string Error::getFile ( void )
          final public int Error::getLine ( void )
          final public array Error::getTrace ( void )
          final public string Error::getTraceAsString ( void )
          public string Error::__toString ( void )
          final private void Error::__clone ( void )
          }
    </section>


    <section class="main-section" id="ArithmeticError">
      <header>ArithmeticError</header>

          ArithmeticError is thrown when an error occurs while performing mathematical operations. In PHP 7.0, these errors include attempting to perform a bitshift by a negative amount, and any call to intdiv() that would result in a value outside the possible bounds of an integer.
         Class synopsis ¶
         ArithmeticError extends Error {
         /* Inherited properties */
         protected string $message ;
         protected int $code ;
         protected string $file ;
         protected int $line ;
         /* Inherited methods */
         final public string Error::getMessage ( void )
         final public Throwable Error::getPrevious ( void )
         final public mixed Error::getCode ( void )
         final public string Error::getFile ( void )
         final public int Error::getLine ( void )
         final public array Error::getTrace ( void )
         final public string Error::getTraceAsString ( void )
         public string Error::__toString ( void )
         final private void Error::__clone ( void )
         }
    </section>


    <section class="main-section" id="AssertionError">
      <header>AssertionError</header>
      AssertionError extends Error {
     /* Inherited properties */
     protected string $message ;
     protected int $code ;
     protected string $file ;
     protected int $line ;
     /* Inherited methods */
     final public string Error::getMessage ( void )
     final public Throwable Error::getPrevious ( void )
     final public mixed Error::getCode ( void )
     final public string Error::getFile ( void )
     final public int Error::getLine ( void )
     final public array Error::getTrace ( void )
     final public string Error::getTraceAsString ( void )
     public string Error::__toString ( void )
     final private void Error::__clone ( void )
     }

    </section>


    <section class="main-section" id="DivisionByZeroError">
      <header>DivisionByZeroError</header>
      DivisionByZeroError is thrown when an attempt is made to divide a number by zero.
    Class synopsis ¶
    DivisionByZeroError extends ArithmeticError {
    /* Inherited properties */
    protected string $message ;
    protected int $code ;
    protected string $file ;
    protected int $line ;
    /* Inherited methods */
    final public string Error::getMessage ( void )
    final public Throwable Error::getPrevious ( void )
    final public mixed Error::getCode ( void )
    final public string Error::getFile ( void )
    final public int Error::getLine ( void )
    final public array Error::getTrace ( void )
    final public string Error::getTraceAsString ( void )
    public string Error::__toString ( void )
    final private void Error::__clone ( void )
    }
    </section>


    <section class="main-section" id="CompileError">
      <header>CompileError</header>
      CompileError is thrown for some compilation errors, which formerly issued a fatal error.
      Class synopsis ¶
      CompileError extends Error {
        /* Inherited properties */
        protected string $message ;
        protected int $code ;
        protected string $file ;
        protected int $line ;
        /* Inherited methods */
        final public string Error::getMessage ( void )
        final public Throwable Error::getPrevious ( void )
        final public mixed Error::getCode ( void )
        final public string Error::getFile ( void )
        final public int Error::getLine ( void )
        final public array Error::getTrace ( void )
        final public string Error::getTraceAsString ( void )
        public string Error::__toString ( void )
        final private void Error::__clone ( void )
      }


    </section>


    <section class="main-section" id="ParseError">
      <header>ParseError</header>
      ParseError is thrown when an error occurs while parsing PHP code, such as when eval() is called.

      Note: ParseError extends CompileError as of PHP 7.3.0. Formerly, it extended Error.

      Class synopsis ¶
      ParseError extends CompileError {
        /* Inherited properties */
        protected string $message ;
        protected int $code ;
        protected string $file ;
        protected int $line ;
        /* Inherited methods */
        final public string Error::getMessage ( void )
        final public Throwable Error::getPrevious ( void )
        final public mixed Error::getCode ( void )
        final public string Error::getFile ( void )
        final public int Error::getLine ( void )
        final public array Error::getTrace ( void )
        final public string Error::getTraceAsString ( void )
        public string Error::__toString ( void )
        final private void Error::__clone ( void )
      }


    </section>


    <section class="main-section" id="TypeError">
      <header>TypeError</header>


      There are three scenarios where a TypeError may be thrown. The first is where the argument type being passed to a function does not match its corresponding declared parameter type. The second is where a value being returned from a function does not match the declared function return type. The third is where an invalid number of arguments are passed to a built-in PHP function (strict mode only).
      Class synopsis ¶
      TypeError extends Error {
        /* Inherited properties */
        protected string $message ;
        protected int $code ;
        protected string $file ;
        protected int $line ;
        /* Inherited methods */
        final public string Error::getMessage ( void )
        final public Throwable Error::getPrevious ( void )
        final public mixed Error::getCode ( void )
        final public string Error::getFile ( void )
        final public int Error::getLine ( void )
        final public array Error::getTrace ( void )
        final public string Error::getTraceAsString ( void )
        public string Error::__toString ( void )
        final private void Error::__clone ( void )
      }

    </section>




    <h1 id="Predefined_Interfaces_and_Classes"> Predefined Interfaces and Classes </h1>
    Interface to detect if a class is traversable using foreach.

    Abstract base interface that cannot be implemented alone. Instead it must be implemented by either IteratorAggregate or Iterator.

    Note:

    Internal (built-in) classes that implement this interface can be used in a foreach construct and do not need to implement IteratorAggregate or Iterator.

    Note:

    This is an internal engine interface which cannot be implemented in PHP scripts. Either IteratorAggregate or Iterator must be used instead. When implementing an interface which extends Traversable, make sure to list IteratorAggregate or Iterator before its name in the implements clause.

    Interface synopsis ¶
    Traversable {
    }

    This interface has no methods, its only purpose is to be the base interface for all traversable classes.
    <section class="main-section" id="Traversable_—_The_Traversable_interface">
      <header>Traversable — The Traversable interface</header>


      Introduction ¶

      Interface for external iterators or objects that can be iterated themselves internally.
      Interface synopsis ¶
      Iterator extends Traversable {
      /* Methods */
      abstract public mixed current ( void )
      abstract public scalar key ( void )
      abstract public void next ( void )
      abstract public void rewind ( void )
      abstract public bool valid ( void )
      }
      Predefined iterators ¶

      PHP already provides a number of iterators for many day to day tasks. See SPL iterators for a list.
      Examples ¶

      Example #1 Basic usage

      This example demonstrates in which order methods are called when using foreach with an iterator.
      <code>&lt;?php
      class myIterator implements Iterator {
      private $position = 0;
      private $array = array(
      "firstelement",
      "secondelement",
      "lastelement",
      );

      public function __construct() {
      $this->position = 0;
      }

      public function rewind() {
      var_dump(__METHOD__);
      $this->position = 0;
      }

      public function current() {
      var_dump(__METHOD__);
      return $this->array[$this->position];
      }

      public function key() {
      var_dump(__METHOD__);
      return $this->position;
      }

      public function next() {
      var_dump(__METHOD__);
      ++$this->position;
      }

      public function valid() {
      var_dump(__METHOD__);
      return isset($this->array[$this->position]);
      }
      }

      $it = new myIterator;

      foreach($it as $key => $value) {
      var_dump($key, $value);
      echo "\n";
      }
      ?&gt;</code>

      The above example will output something similar to:

      string(18) "myIterator::rewind"
      string(17) "myIterator::valid"
      string(19) "myIterator::current"
      string(15) "myIterator::key"
      int(0)
      string(12) "firstelement"

      string(16) "myIterator::next"
      string(17) "myIterator::valid"
      string(19) "myIterator::current"
      string(15) "myIterator::key"
      int(1)
      string(13) "secondelement"

      string(16) "myIterator::next"
      string(17) "myIterator::valid"
      string(19) "myIterator::current"
      string(15) "myIterator::key"
      int(2)
      string(11) "lastelement"

      string(16) "myIterator::next"
      string(17) "myIterator::valid"


    </section>


    <section class="main-section" id="Iterator_—_The_Iterator_interface">
      <header>Iterator — The Iterator interface</header>

    </section>


    <section class="main-section" id="IteratorAggregate_—_The_IteratorAggregate_interface">
      <header>IteratorAggregate — The IteratorAggregate interface</header>


      Interface to create an external Iterator.
      Interface synopsis ¶
      IteratorAggregate extends Traversable {
      /* Methods */
      abstract public Traversable getIterator ( void )
      }

      Example #1 Basic usage
      <code>&lt;?php
      class myData implements IteratorAggregate {
      public $property1 = "Public property one";
      public $property2 = "Public property two";
      public $property3 = "Public property three";

      public function __construct() {
      $this->property4 = "last property";
      }

      public function getIterator() {
      return new ArrayIterator($this);
      }
      }

      $obj = new myData;

      foreach($obj as $key => $value) {
      var_dump($key, $value);
      echo "\n";
      }
      ?&gt;</code>

      The above example will output something similar to:

      string(9) "property1"
      string(19) "Public property one"

      string(9) "property2"
      string(19) "Public property two"

      string(9) "property3"
      string(21) "Public property three"

      string(9) "property4"
      string(13) "last property"



    </section>


    <section class="main-section" id="Throwable">
      <header>Throwable</header>



      Throwable is the base interface for any object that can be thrown via a throw statement in PHP 7, including Error and Exception.

      Note:

      PHP classes cannot implement the Throwable interface directly, and must instead extend Exception.

      Interface synopsis ¶
      Throwable {
      /* Methods */
      abstract public string getMessage ( void )
      abstract public int getCode ( void )
      abstract public string getFile ( void )
      abstract public int getLine ( void )
      abstract public array getTrace ( void )
      abstract public string getTraceAsString ( void )
      abstract public Throwable getPrevious ( void )
      abstract public string __toString ( void )
      }
    </section>


    <section class="main-section" id="ArrayAccess_—_The_ArrayAccess_interface">
      <header>AsrrayAccess — The ArrayAccess interface</header>

      Interface to provide accessing objects as arrays.
      Interface synopsis ¶
      ArrayAccess {
      /* Methods */
      abstract public bool offsetExists ( mixed $offset )
      abstract public mixed offsetGet ( mixed $offset )
      abstract public void offsetSet ( mixed $offset , mixed $value )
      abstract public void offsetUnset ( mixed $offset )
      }

      Example #1 Basic usage
      <code>&lt;?php
      class obj implements ArrayAccess {
      private $container = array();

      public function __construct() {
      $this->container = array(
      "one"   => 1,
      "two"   => 2,
      "three" => 3,
      );
      }

      public function offsetSet($offset, $value) {
      if (is_null($offset)) {
      $this->container[] = $value;
      } else {
      $this->container[$offset] = $value;
      }
      }

      public function offsetExists($offset) {
      return isset($this->container[$offset]);
      }

      public function offsetUnset($offset) {
      unset($this->container[$offset]);
      }

      public function offsetGet($offset) {
      return isset($this->container[$offset]) ? $this->container[$offset] : null;
      }
      }

      $obj = new obj;

      var_dump(isset($obj["two"]));
      var_dump($obj["two"]);
      unset($obj["two"]);
      var_dump(isset($obj["two"]));
      $obj["two"] = "A value";
      var_dump($obj["two"]);
      $obj[] = 'Append 1';
      $obj[] = 'Append 2';
      $obj[] = 'Append 3';
      print_r($obj);
      ?&gt;</code>

      The above example will output something similar to:

      bool(true)
      int(2)
      bool(false)
      string(7) "A value"
      obj Object
      (
      [container:obj:private] => Array
      (
      [one] => 1
      [three] => 3
      [two] => A value
      [0] => Append 1
      [1] => Append 2
      [2] => Append 3
      )

      )
    </section>


    <section class="main-section" id="Serializable_—_The_Serializable_interface">
      <header>Serializable — The Serializable interface</header>

      Interface for customized serializing.

      Classes that implement this interface no longer support __sleep() and __wakeup(). The method serialize is called whenever an instance needs to be serialized. This does not invoke __destruct() or have any other side effect unless programmed inside the method. When the data is unserialized the class is known and the appropriate unserialize() method is called as a constructor instead of calling __construct(). If you need to execute the standard constructor you may do so in the method.
      Interface synopsis ¶
      Serializable {
      /* Methods */
      abstract public string serialize ( void )
      abstract public void unserialize ( string $serialized )
      }

      Example #1 Basic usage
      <code>&lt;?php
      class obj implements Serializable {
      private $data;
      public function __construct() {
      $this->data = "My private data";
      }
      public function serialize() {
      return serialize($this->data);
      }
      public function unserialize($data) {
      $this->data = unserialize($data);
      }
      public function getData() {
      return $this->data;
      }
      }

      $obj = new obj;
      $ser = serialize($obj);

      var_dump($ser);

      $newobj = unserialize($ser);

      var_dump($newobj->getData());
      ?&gt;</code>

      The above example will output something similar to:

      string(38) "C:3:"obj":23:{s:15:"My private data";}"
      string(15) "My private data"


    </section>


    <section class="main-section" id="Closure_—_The_Closure_class">
      <header>Closure — The Closure class</header>
      Class used to represent anonymous functions.

      Anonymous functions, implemented in PHP 5.3, yield objects of this type. This fact used to be considered an implementation detail, but it can now be relied upon. Starting with PHP 5.4, this class has methods that allow further control of the anonymous function after it has been created.

      Besides the methods listed here, this class also has an __invoke method. This is for consistency with other classes that implement calling magic, as this method is not used for calling the function.
      Class synopsis ¶
      Closure {
      /* Methods */
      private __construct ( void )
      public static Closure bind ( Closure $closure , object $newthis [, mixed $newscope = "static" ] )
      public Closure bindTo ( object $newthis [, mixed $newscope = "static" ] )
      public mixed call ( object $newthis [, mixed $... ] )
      public static Closure fromCallable ( callable $callable )
      }

    </section>


    <section class="main-section" id="Generator_—_The_Generator_class">
      <header>Generator — The Generator class</header>
      Generator objects are returned from generators.
      Caution

      Generator objects cannot be instantiated via new.
      Class synopsis ¶
      Generator implements Iterator {
      /* Methods */
      public mixed current ( void )
      public mixed getReturn ( void )
      public mixed key ( void )
      public void next ( void )
      public void rewind ( void )
      public mixed send ( mixed $value )
      public mixed throw ( Throwable $exception )
      public bool valid ( void )
      public void __wakeup ( void )
      }

    </section>



    <h1 id="Context_options_and_parameters"> Context options and parameters </h1>
    <section class="main-section" id="Socket_context_options_—_Socket_context_option_listing">
      <header>Socket context options — Socket context option listing</header>
      Socket context options — Socket context option listing
      Description ¶

      Socket context options are available for all wrappers that work over sockets, like tcp, http and ftp.
      Options ¶

      bindto

      Used to specify the IP address (either IPv4 or IPv6) and/or the port number that PHP will use to access the network. The syntax is ip:port for IPv4 addresses, and [ip]:port for IPv6 addresses. Setting the IP or the port to 0 will let the system choose the IP and/or port.

      Note:

      As FTP creates two socket connections during normal operation, the port number cannot be specified using this option.

      backlog

      Used to limit the number of outstanding connections in the socket's listen queue.

      Note:

      This is only applicable to stream_socket_server().

      ipv6_v6only

      Overrides the OS default regarding mapping IPv4 into IPv6.

      Note:

      This is important in particular when trying to listen on IPv4 addresses separately while there exists a binding on [::].

      This is only applicable to stream_socket_server().

      so_reuseport

      Allows multiple bindings to a same ip:port pair, even from separate processes.

      Note:

      This is only applicable to stream_socket_server().

      so_broadcast

      Enables sending and receiving data to/from broadcast addresses.

      Note:

      This is only applicable to stream_socket_server().

      tcp_nodelay

      Setting this option to TRUE will set SOL_TCP,NO_DELAY=1 appropriately, thus disabling the TCP Nagle algorithm.




      Example #1 Basic bindto usage example
      <code>&lt;?php
      // connect to the internet using the '192.168.0.100' IP
      $opts = array(
      'socket' => array(
        'bindto' => '192.168.0.100:0',
      ),
      );


      // connect to the internet using the '192.168.0.100' IP and port '7000'
      $opts = array(
      'socket' => array(
        'bindto' => '192.168.0.100:7000',
      ),
      );


      // connect to the internet using the '2001:db8::1' IPv6 address
      // and port '7000'
      $opts = array(
      'socket' => array(
        'bindto' => '[2001:db8::1]:7000',
      ),
      );


      // connect to the internet using port '7000'
      $opts = array(
      'socket' => array(
        'bindto' => '0:7000',
      ),
      );


      // create the context...
      $context = stream_context_create($opts);

      // ...and use it to fetch the data
      echo file_get_contents('http://www.example.com', false, $context);

      ?&gt;</code>
    </section>


    <section class="main-section" id="HTTP_context_options_—_HTTP_context_option_listing">
      <header>HTTP context options — HTTP context option listing</header>

      HTTP context options — HTTP context option listing
      Description ¶

      Context options for http:// and https:// transports.
      Options ¶

      method string

      GET, POST, or any other HTTP method supported by the remote server.

      Defaults to GET.
      header array or string

      Additional headers to be sent during request. Values in this option will override other values (such as User-agent:, Host:, and Authentication:).
      user_agent string

      Value to send with User-Agent: header. This value will only be used if user-agent is not specified in the header context option above.

      By default the user_agent php.ini setting is used.
      content string

      Additional data to be sent after the headers. Typically used with POST or PUT requests.
      proxy string

      URI specifying address of proxy server. (e.g. tcp://proxy.example.com:5100).
      request_fulluri boolean

      When set to TRUE, the entire URI will be used when constructing the request. (i.e. GET http://www.example.com/path/to/file.html HTTP/1.0). While this is a non-standard request format, some proxy servers require it.

      Defaults to FALSE.
      follow_location integer

      Follow Location header redirects. Set to 0 to disable.

      Defaults to 1.
      max_redirects integer

      The max number of redirects to follow. Value 1 or less means that no redirects are followed.

      Defaults to 20.
      protocol_version float

      HTTP protocol version.

      Defaults to 1.0.

        Note:

        PHP prior to 5.3.0 does not implement chunked transfer decoding. If this value is set to 1.1 it is your responsibility to be 1.1 compliant.

      timeout float

      Read timeout in seconds, specified by a float (e.g. 10.5).

      By default the default_socket_timeout php.ini setting is used.
      ignore_errors boolean

      Fetch the content even on failure status codes.

      Defaults to FALSE.


    </section>


    <section class="main-section" id="FTP_context_options_—_FTP_context_option_listing">
      <header>FTP context options — FTP context option listing</header>

      FTP context options — FTP context option listing
      Description ¶

      Context options for ftp:// and ftps:// transports.
      Options ¶

      overwrite boolean

        Allow overwriting of already existing files on remote server. Applies to write mode (uploading) only.

        Defaults to FALSE.
      resume_pos integer

        File offset at which to begin transfer. Applies to read mode (downloading) only.

        Defaults to 0 (Beginning of File).
      proxy string

        Proxy FTP request via http proxy server. Applies to file read operations only. Ex: tcp://squid.example.com:8000.

    </section>


    <section class="main-section" id="SSL_context_options_—_SSL_context_option_listing">
      <header>SSL context options — SSL context option listing</header>


        SSL context options — SSL context option listing
        Description ¶

        Context options for ssl:// and tls:// transports.
        Options ¶

        peer_name string

            Peer name to be used. If this value is not set, then the name is guessed based on the hostname used when opening the stream.
        verify_peer boolean

            Require verification of SSL certificate used.

            Defaults to TRUE.
        verify_peer_name boolean

            Require verification of peer name.

            Defaults to TRUE.
        allow_self_signed boolean

            Allow self-signed certificates. Requires verify_peer.

            Defaults to FALSE
        cafile string

            Location of Certificate Authority file on local filesystem which should be used with the verify_peer context option to authenticate the identity of the remote peer.
        capath string

            If cafile is not specified or if the certificate is not found there, the directory pointed to by capath is searched for a suitable certificate. capath must be a correctly hashed certificate directory.
        local_cert string

            Path to local certificate file on filesystem. It must be a PEM encoded file which contains your certificate and private key. It can optionally contain the certificate chain of issuers. The private key also may be contained in a separate file specified by local_pk.
        local_pk string

            Path to local private key file on filesystem in case of separate files for certificate (local_cert) and private key.
        passphrase string

            Passphrase with which your local_cert file was encoded.
        CN_match string

            Common Name we are expecting. PHP will perform limited wildcard matching. If the Common Name does not match this, the connection attempt will fail.

                Note: This option is deprecated, in favour of peer_name, as of PHP 5.6.0.

        verify_depth integer

            Abort if the certificate chain is too deep.

            Defaults to no verification.
        ciphers string

            Sets the list of available ciphers. The format of the string is described in » ciphers(1).

            Defaults to DEFAULT.
        capture_peer_cert boolean

            If set to TRUE a peer_certificate context option will be created containing the peer certificate.
        capture_peer_cert_chain boolean

            If set to TRUE a peer_certificate_chain context option will be created containing the certificate chain.
        SNI_enabled boolean

            If set to TRUE server name indication will be enabled. Enabling SNI allows multiple certificates on the same IP address.
        SNI_server_name string

            If set, then this value will be used as server name for server name indication. If this value is not set, then the server name is guessed based on the hostname used when opening the stream.

                Note: This option is deprecated, in favour of peer_name, as of PHP 5.6.0.

        disable_compression boolean

            If set, disable TLS compression. This can help mitigate the CRIME attack vector.
        peer_fingerprint string | array

            Aborts when the remote certificate digest doesn't match the specified hash.

            When a string is used, the length will determine which hashing algorithm is applied, either "md5" (32) or "sha1" (40).

            When an array is used, the keys indicate the hashing algorithm name and each corresponding value is the expected digest.


    </section>


    <section class="main-section" id="CURL_context_options_—_CURL_context_option_listing">
      <header>CURL context options — CURL context option listing</header>



            CURL context options — CURL context option listing
            Description ¶

            CURL context options are available when the CURL extension was compiled using the --with-curlwrappers configure option.
            Options ¶

            method string

                GET, POST, or any other HTTP method supported by the remote server.

                Defaults to GET.
            header string

                Additional headers to be sent during request. Values in this option will override other values (such as User-agent:, Host:, and Authentication:).
            user_agent string

                Value to send with User-Agent: header.

                By default the user_agent php.ini setting is used.
            content string

                Additional data to be sent after the headers. This option is not used for GET or HEAD requests.
            proxy string

                URI specifying address of proxy server. (e.g. tcp://proxy.example.com:5100).
            max_redirects integer

                The max number of redirects to follow. Value 1 or less means that no redirects are followed.

                Defaults to 20.
            curl_verify_ssl_host boolean

                Verify the host.

                Defaults to FALSE

                    Note:

                    This option is available for both the http and ftp protocol wrappers.

            curl_verify_ssl_peer boolean

                Require verification of SSL certificate used.

                Defaults to FALSE

                    Note:

                    This option is available for both the http and ftp protocol wrappers.

            Examples ¶

            Example #1 Fetch a page and send POST data
            <code>&lt;?php

            $postdata = http_build_query(
                array(
                    'var1' => 'some content',
                    'var2' => 'doh'
                )
            );

            $opts = array('http' =>
                array(
                    'method'  => 'POST',
                    'header'  => 'Content-type: application/x-www-form-urlencoded',
                    'content' => $postdata
                )
            );

            $context = stream_context_create($opts);

            $result = file_get_contents('http://example.com/submit.php', false, $context);

            ?&gt;</code>


    </section>


    <section class="main-section" id="Phar_context_options_—_Phar_context_option_listing">
      <header>Phar context options — Phar context option listing</header>
      Phar context options — Phar context option listing
      Description ¶

      Context options for phar:// wrapper.
      Options ¶

      compress int

          One of Phar compression constants.
      metadata mixed

          Phar metadata. See Phar::setMetadata().

    </section>


    <section class="main-section" id="MongoDB_context_options_—_MongoDB_context_option_listing">
      <header>MongoDB context options — MongoDB context option listing</header>


                MongoDB context options — MongoDB context option listing
                Description ¶

                Context options for mongodb:// transports.
                Options ¶

                log_cmd_insert callable

                    A callback function called when inserting a document, see log_cmd_insert().
                log_cmd_delete callable

                    A callback function called when deleting a document, see log_cmd_delete().
                log_cmd_update callable

                    A callback function called when updating a document, see log_cmd_update().
                log_write_batch callable

                    A callback function called when executing a Write Batch, see log_write_batch().
                log_reply callable

                    A callback function called when reading a reply from MongoDB, see log_reply().
                log_getmore callable

                    A callback function called when retrieving more results from a MongoDB cursor, see log_getmore().
                log_killcursor callable

                    A callback function called executing a killcursor opcode, see log_killcursor().




    </section>


    <section class="main-section" id="Context_parameters_—_Context_parameter_listing">
      <header>Context parameters — Context parameter listing</header>

                    Context parameters — Context parameter listing
                    Description ¶

                    These parameters can be set on a context using the stream_context_set_params() function.
                    Parameters ¶

                    notification callable

                        A callable to be called when an event occurs on a stream.


    </section>


    <section class="main-section" id="Zip_context_options_—_Zip_context_option_listing">
      <header>Zip context options — Zip context option listing</header>
      Zip context options — Zip context option listing
      Description ¶

      Zip context options are available for zip wrappers.
      Options ¶

      password

          Used to specify password used for encrypted archive.


          Examples ¶

          Example #1 Basic password usage example
          <code>&lt;?php
          // Read encrypted archive
          $opts = array(
              'zip' => array(
                  'password' => 'secret',
              ),
          );
          // create the context...
          $context = stream_context_create($opts);

          // ...and use it to fetch the data
          echo file_get_contents('zip://test.zip#test.txt', false, $context);

          ?&gt;</code>

    </section>










    <h1 id="Supported_Protocols_and_Wrappers"> Supported Protocols and Wrappers </h1>
    <section class="main-section" id="file://_—_Accessing_local_filesystem">
      <header>file:// — Accessing local filesystem</header>
      file:// — Accessing local filesystem
      Description ¶

      Filesystem is the default wrapper used with PHP and represents the local filesystem. When a relative path is specified (a path which does not begin with /, \, \\, or a Windows drive letter) the path provided will be applied against the current working directory. In many cases this is the directory in which the script resides unless it has been changed. Using the CLI sapi, this defaults to the directory from which the script was called.

      With some functions, such as fopen() and file_get_contents(), include_path may be optionally searched for relative paths as well.
      Usage ¶

          /path/to/file.ext
          relative/path/to/file.ext
          fileInCwd.ext
          C:/path/to/winfile.ext
          C:\path\to\winfile.ext
          \\smbserver\share\path\to\winfile.ext
          file:///path/to/file.ext




    </section>


    <section class="main-section" id="http://_—_Accessing_HTTP(s)_URLs">
      <header>http:// — Accessing HTTP(s) URLs</header>



      http:// -- https:// — Accessing HTTP(s) URLs
      Description ¶

      Allows read-only access to files/resources via HTTP 1.0, using the HTTP GET method. A Host: header is sent with the request to handle name-based virtual hosts. If you have configured a user_agent string using your php.ini file or the stream context, it will also be included in the request.

      The stream allows access to the body of the resource; the headers are stored in the $http_response_header variable.

      If it's important to know the URL of the resource where your document came from (after all redirects have been processed), you'll need to process the series of response headers returned by the stream.

      The from directive will be used for the From: header if set and not overwritten by the Context options and parameters.
      Usage ¶

      http://example.com
      http://example.com/file.php?var1=val1&var2=val2
      http://user:password@example.com
      https://example.com
      https://example.com/file.php?var1=val1&var2=val2
      https://user:password@example.com


    </section>


    <section class="main-section" id="ftp://_—_Accessing_FTP(s)_URLs">
      <header>ftp:// — Accessing FTP(s) URLs</header>


      ftp:// -- ftps:// — Accessing FTP(s) URLs
      Description ¶

      Allows read access to existing files and creation of new files via FTP. If the server does not support passive mode ftp, the connection will fail.

      You can open files for either reading or writing, but not both simultaneously. If the remote file already exists on the ftp server and you attempt to open it for writing but have not specified the context option overwrite, the connection will fail. If you need to overwrite existing files over ftp, specify the overwrite option in the context and open the file for writing. Alternatively, you can use the FTP extension.

      If you have set the from directive in php.ini, then this value will be sent as the anonymous FTP password.
      Usage ¶

      ftp://example.com/pub/file.txt
      ftp://user:password@example.com/pub/file.txt
      ftps://example.com/pub/file.txt
      ftps://user:password@example.com/pub/file.txt

    </section>


    <section class="main-section" id="php://_—_Accessing_various_I/O_streams">
      <header>php:// — Accessing various I/O streams</header>

      php:// — Accessing various I/O streams
      Description ¶

      PHP provides a number of miscellaneous I/O streams that allow access to PHP's own input and output streams, the standard input, output and error file descriptors, in-memory and disk-backed temporary file streams, and filters that can manipulate other file resources as they are read from and written to.
      php://stdin, php://stdout and php://stderr ¶

      php://stdin, php://stdout and php://stderr allow direct access to the corresponding input or output stream of the PHP process. The stream references a duplicate file descriptor, so if you open php://stdin and later close it, you close only your copy of the descriptor-the actual stream referenced by STDIN is unaffected. Note that PHP exhibited buggy behavior in this regard until PHP 5.2.1. It is recommended that you simply use the constants STDIN, STDOUT and STDERR instead of manually opening streams using these wrappers.

      php://stdin is read-only, whereas php://stdout and php://stderr are write-only.
      php://input ¶

      php://input is a read-only stream that allows you to read raw data from the request body. In the case of POST requests, it is preferable to use php://input instead of $HTTP_RAW_POST_DATA as it does not depend on special php.ini directives. Moreover, for those cases where $HTTP_RAW_POST_DATA is not populated by default, it is a potentially less memory intensive alternative to activating always_populate_raw_post_data. php://input is not available with enctype="multipart/form-data".

      Note: Prior to PHP 5.6, a stream opened with php://input could only be read once; the stream did not support seek operations. However, depending on the SAPI implementation, it may be possible to open another php://input stream and restart reading. This is only possible if the request body data has been saved. Typically, this is the case for POST requests, but not other request methods, such as PUT or PROPFIND.

      php://output ¶

      php://output is a write-only stream that allows you to write to the output buffer mechanism in the same way as print and echo.
      php://fd ¶

      php://fd allows direct access to the given file descriptor. For example, php://fd/3 refers to file descriptor 3.
      php://memory and php://temp ¶

      php://memory and php://temp are read-write streams that allow temporary data to be stored in a file-like wrapper. The only difference between the two is that php://memory will always store its data in memory, whereas php://temp will use a temporary file once the amount of data stored hits a predefined limit (the default is 2 MB). The location of this temporary file is determined in the same way as the sys_get_temp_dir() function.

      The memory limit of php://temp can be controlled by appending /maxmemory:NN, where NN is the maximum amount of data to keep in memory before using a temporary file, in bytes.
      php://filter ¶

      php://filter is a kind of meta-wrapper designed to permit the application of filters to a stream at the time of opening. This is useful with all-in-one file functions such as readfile(), file(), and file_get_contents() where there is otherwise no opportunity to apply a filter to the stream prior the contents being read.

      The php://filter target takes the following parameters as part of its path. Multiple filter chains can be specified on one path. Please refer to the examples for specifics on using these parameters.

    </section>


    <section class="main-section" id="zlib://_—_Compression_Streams">
      <header>zlib:// — Compression Streams</header>

      zlib:// -- bzip2:// -- zip:// — Compression Streams
      Description ¶

      compress.zlib:// and compress.bzip2://

      zlib: works like gzopen(), except that the stream can be used with fread() and the other filesystem functions. This is deprecated as of PHP 4.3.0 due to ambiguities with filenames containing ':' characters; use compress.zlib:// instead.

      compress.zlib:// and compress.bzip2:// are equivalent to gzopen() and bzopen() respectively, and operate even on systems that do not support fopencookie.

      ZIP extension registers zip: wrapper. As of PHP 7.2.0 and libzip 1.2.0+, support for the passwords for encrypted achives were added, allowing passwords to be supplied by stream contexts. Passwords can be set using the 'password' stream context option.
      Usage ¶

      compress.zlib://file.gz
      compress.bzip2://file.bz2
      zip://archive.zip#dir/file.txt

    </section>



    <section class="main-section" id="data://_—_Data_(RFC_2397)">
      <header>data:// — Data (RFC 2397)</header>
      data:// — Data (RFC 2397)
      Description ¶

      The data: (» RFC 2397) stream wrapper is available since PHP 5.2.0.
      Usage ¶

      data://text/plain;base64,




      Examples ¶

      Example #1 Print data:// contents
      <code>&lt;?php
      // prints "I love PHP"
      echo file_get_contents('data://text/plain;base64,SSBsb3ZlIFBIUAo=');
      ?&gt;</code>

      Example #2 Fetch the media type
      <code>&lt;?php
      $fp   = fopen('data://text/plain;base64,', 'r');
      $meta = stream_get_meta_data($fp);

      // prints "text/plain"
      echo $meta['mediatype'];
      ?&gt;</code>
    </section>


    <section class="main-section" id="glob://_—_Find_pathnames_matching_pattern">
      <header>glob:// — Find pathnames matching pattern</header>

      glob:// — Find pathnames matching pattern
      Description ¶

      The glob: stream wrapper is available since PHP 5.3.0.
      Usage ¶

      glob://

    </section>


    <section class="main-section" id="phar://_—_PHP_Archive">
      <header>phar:// — PHP Archive</header>

      phar:// — PHP Archive
      Description ¶

      The phar:// stream wrapper is available since PHP 5.3.0. See Phar stream wrapper for detailed description.
      Usage ¶

      phar://

    </section>


    <section class="main-section" id="ssh2://_—_Secure_Shell_2">
      <header>ssh2:// — Secure Shell 2</header>


      sh2:// — Secure Shell 2
      Description ¶

      ssh2.shell:// ssh2.exec:// ssh2.tunnel:// ssh2.sftp:// ssh2.scp:// PHP 4.3.0 and up (PECL)

      Note: This wrapper is not enabled by default
      In order to use the ssh2.*:// wrappers you must install the » SSH2 extension available from » PECL.

      In addition to accepting traditional URI login details, the ssh2 wrappers will also reuse open connections by passing the connection resource in the host portion of the URL.
      Usage ¶

      ssh2.shell://user:pass@example.com:22/xterm
      ssh2.exec://user:pass@example.com:22/usr/local/bin/somecmd
      ssh2.tunnel://user:pass@example.com:22/192.168.0.1:14
      ssh2.sftp://user:pass@example.com:22/path/to/filename



      Examples ¶

      Example #1 Opening a stream from an active connection
      <code>&lt;?php
      $session = ssh2_connect('example.com', 22);
      ssh2_auth_pubkey_file($session, 'username', '/home/username/.ssh/id_rsa.pub',
                                                '/home/username/.ssh/id_rsa', 'secret');
      $stream = fopen("ssh2.tunnel://$session/remote.example.com:1234", 'r');
      ?&gt;</code>

      Example #2 This $session variable must be kept available!

      In order to use the ssh2.*://$session wrappers you must keep the $session resource variable. The code below will not have the desired effect:
      <code>&lt;?php
      $session = ssh2_connect('example.com', 22);
      ssh2_auth_pubkey_file($session, 'username', '/home/username/.ssh/id_rsa.pub',
                                                '/home/username/.ssh/id_rsa', 'secret');
      $connection_string = "ssh2.sftp://$session/";
      unset($session);
      $stream = fopen($connection_string . "path/to/file", 'r');
      ?&gt;</code>

      unset() closes the session, because $connection_string does not hold a reference to the $session variable, just a string cast derived from it. This also happens when the unset() is implicit because of leaving scope (like in a function).

    </section>


    <section class="main-section" id="rar://_—_RAR">
      <header>rar:// — RAR</header>
      rar:// — RAR
      Description ¶

      The wrapper takes the url encoded path to the RAR archive (relative or absolute), an optional asterik (*), an optional number sign (#) and an optional url encoded entry name, as stored in the archive. Specifying an entry name requires the number sign; a leading forward slash in the entry name is optional.

      This wrapper can open both files and directories. When opening directories, the asterisk sign forces the directory entries names to be returned unencoded. If it's not specified, they will be returned url encoded – the reason for this is to allow the wrapper to be correctly used with built-in functionality like the RecursiveDirectoryIterator in the presence of file names that seem like url encoded data.

      If the pound sign and the entry name part are not included, the root of the archive will be displayed. This differs from regular directories in that the resulting stream will not contain information such as the modification time, as the root directory is not stored in an individual entry in the archive. The usage of the wrapper with RecursiveDirectoryIterator requires the number sign to be included in the URL when accessing the root, so that the URLs of the children may be constructed correctly.

        Note: This wrapper is not enabled by default
        In order to use the rar:// wrapper, you must install the » rar extension available from » PECL.

      rar:// Available since PECL rar 3.0.0
      Usage ¶

        rar://<url encoded archive name>[*][#[<url encoded entry name>]]





        Examples ¶

        Example #1 Traversing a RAR archive
        <code>&lt;?php

        class MyRecDirIt extends RecursiveDirectoryIterator {
            function current() {
                return rawurldecode($this->getSubPathName()) .
                    (is_dir(parent::current())?" [DIR]":"");
            }
        }

        $f = "rar://" . rawurlencode(dirname(__FILE__)) .
            DIRECTORY_SEPARATOR . 'dirs_and_extra_headers.rar#';

        $it = new RecursiveTreeIterator(new MyRecDirIt($f));

        foreach ($it as $s) {
            echo $s, "\n";
        }
        ?&gt;</code>

        The above example will output something similar to:

        |-allow_everyone_ni [DIR]
        |-file1.txt
        |-file2_אּ.txt
        |-with_streams.txt
        \-אּ [DIR]
          |-אּ\%2Fempty%2E [DIR]
          | \-אּ\%2Fempty%2E\file7.txt
          |-אּ\empty [DIR]
          |-אּ\file3.txt
          |-אּ\file4_אּ.txt
          \-אּ\אּ_2 [DIR]
            |-אּ\אּ_2\file5.txt
            \-אּ\אּ_2\file6_אּ.txt

        Example #2 Opening an encrypted file (header encryption)
        <code>&lt;?php
        $stream = fopen("rar://" .
            rawurlencode(dirname(__FILE__)) . DIRECTORY_SEPARATOR .
            'encrypted_headers.rar' . '#encfile1.txt', "r", false,
            stream_context_create(
                array(
                    'rar' =>
                        array(
                            'open_password' => 'samplepassword'
                        )
                    )
                )
            );
        var_dump(stream_get_contents($stream));
        /* creation and last access date is opt-in in WinRAR, hence most
         * files don't have them */
        var_dump(fstat($stream));
        ?&gt;</code>

        The above example will output something similar to:

        string(26) "Encrypted file 1 contents."
        Array
        (
            [0] => 0
            [1] => 0
            [2] => 33206
            [3] => 1
            [4] => 0
            [5] => 0
            [6] => 0
            [7] => 26
            [8] => 0
            [9] => 1259550052
            [10] => 0
            [11] => -1
            [12] => -1
            [dev] => 0
            [ino] => 0
            [mode] => 33206
            [nlink] => 1
            [uid] => 0
            [gid] => 0
            [rdev] => 0
            [size] => 26
            [atime] => 0
            [mtime] => 1259550052
            [ctime] => 0
            [blksize] => -1
            [blocks] => -1
        )

    </section>


    <section class="main-section" id="ogg://_—_Audio_streams">
      <header>ogg:// — Audio streams</header>


        ogg:// — Audio streams
      Description ¶

      Files opened for reading via the ogg:// wrapper are treated as compressed audio encoded using the OGG/Vorbis codec. Similarly, files opened for writing or appending via the ogg:// wrapper are writen as compressed audio data. stream_get_meta_data(), when used on an OGG/Vorbis file opened for reading will return various details about the stream including the vendor tag, any included comments, the number of channels, the sampling rate, and the encoding rate range described by: bitrate_lower, bitrate_upper, bitrate_nominal, and bitrate_window.

      ogg:// PHP 4.3.0 and up (PECL)

      Note: This wrapper is not enabled by default
      In order to use the ogg:// wrapper you must install the » OGG/Vorbis extension available from » PECL.

      Usage ¶

      ogg://soundfile.ogg
      ogg:///path/to/soundfile.ogg
      ogg://http://www.example.com/path/to/soundstream.ogg

    </section>


    <section class="main-section" id="expect://_—_Process_Interaction_Streams">
      <header>expect:// — Process Interaction Streams</header>

      expect:// — Process Interaction Streams
      Description ¶

      Streams opened via the expect:// wrapper provide access to process'es stdio, stdout and stderr via PTY.

      Note: This wrapper is not enabled by default
      In order to use the expect:// wrapper you must install the » Expect extension available from » PECL.

      expect:// PHP 4.3.0 and up (PECL)
      Usage ¶

      expect://command

    </section>



  </main>
</body>

</html>
