<!DOCTYPE html>
<html lang="en">

<head>
  <title> technical documentation PHP </title>
  <meta charset="UTF-8">
  <meta name="author" content="Lukas Ptakauskas">
  <meta name="author_mail" content="lukas.ptakauskas@gmail.com">
  <meta http-equiv="refresh" content="100">

  <link rel="stylesheet" href="style.css">
</head>

<body>
  <nav id="navbar">
    <header>PHP Documentation</header>
    <a class="nav-link" rel="bookmark" href="#Basic_syntax"> Basic syntax </a>
    <a class="nav-link" rel="bookmark" href="#PHP_tags"> PHP tags </a>
    <a class="nav-link" rel="bookmark" href="#Escaping_from_HTML"> Escaping from HTML </a>
    <a class="nav-link" rel="bookmark" href="#Instruction_separation"> Instruction separation </a>
    <a class="nav-link" rel="bookmark" href="#Comments"> Comments </a>
    <a class="nav-link" rel="bookmark" href="#Types"> Types </a>
    <a class="nav-link" rel="bookmark" href="#Types_Introduction"> Types Introduction </a>
    <a class="nav-link" rel="bookmark" href="#Booleans"> Booleans </a>
    <a class="nav-link" rel="bookmark" href="#Integers"> Integers </a>
    <a class="nav-link" rel="bookmark" href="#Floating_point_numbers"> Floating point numbers </a>
    <a class="nav-link" rel="bookmark" href="#Strings"> Strings </a>
    <a class="nav-link" rel="bookmark" href="#Arrays"> Arrays </a>
    <a class="nav-link" rel="bookmark" href="#Iterables"> Iterables </a>
    <a class="nav-link" rel="bookmark" href="#Objects"> Objects </a>
    <a class="nav-link" rel="bookmark" href="#Resources"> Resources </a>
    <a class="nav-link" rel="bookmark" href="#NULL"> NULL </a>
    <a class="nav-link" rel="bookmark" href="#Callbacks_/_Callables"> Callbacks / Callables </a>
    <a class="nav-link" rel="bookmark" href="#Pseudo-types_and_variables_used_in_this_documentation"> Pseudo-types and variables used in this documentation </a>
    <a class="nav-link" rel="bookmark" href="#Type_Juggling"> Type Juggling </a>
    <a class="nav-link" rel="bookmark" href="#Variables"> Variables </a>
    <a class="nav-link" rel="bookmark" href="#Variable_Basics"> Variable Basics </a>
    <a class="nav-link" rel="bookmark" href="#Predefined_Variable"> Predefined Variable </a>
    <a class="nav-link" rel="bookmark" href="#Variable_scope"> Variable scope </a>
    <a class="nav-link" rel="bookmark" href="#Variable_variables"> Variable variables </a>
    <a class="nav-link" rel="bookmark" href="#Variables_From_External_Sources"> Variables From External Sources </a>

  </nav>





  <main id="main-doc">

    <h1 id="Basic_syntax"> Basic syntax </h1>
    <section class="main-section" id="PHP_tags">
      <header>PHP tags</header>
      <p>When PHP parses a file, it looks for opening and closing tags, which are
        &lt;?php and ?&gt; which tell PHP to start and stop interpreting the code
        between them. Parsing in this manner allows PHP to be embedded in all sorts
        of different documents, as everything outside of a pair of opening and closing
        tags is ignored by the PHP parser.
      </p>
      <p class="note-comment"> I would like to stress out that the opening tag is
        "&lt;?php[whitespace]", not just "&lt;?php".
      </p>
      <p>If a file is pure PHP code, it is preferable to omit the PHP closing tag
        at the end of the file. This prevents accidental whitespace or new lines
        being added after the PHP closing tag, which may cause unwanted effects because
        PHP will start output buffering when there is no intention from the programmer
        to send any output at that point in the script.
      </p>
      <code>

        &lt;?php<br>
        echo "Hello world";<br>

        // ... more code<br>

        echo "Last statement";<br>

        // the script ends here with no PHP closing tag<br>

      </code>
    </section>


    <section class="main-section" id="Escaping_from_HTML">
      <header>Escaping from HTML</header>
      <p>
        Everything outside of a pair of opening and closing tags is ignored by the PHP parser which allows PHP files to have mixed content. This allows PHP to be embedded in HTML documents, for example to create templates.
      </p>
      <code>
        &lt;p&gt;This is going to be ignored by PHP and displayed by the browser.&lt;/p&gt;
        &lt;?php echo 'While this is going to be parsed.'; ?&gt;
        &lt;p&gt;This will also be ignored by PHP and displayed by the browser.&lt;/p&gt;
      </code>
      <p>
        This works as expected, because when the PHP interpreter hits the ?&gt; closing tags, it simply starts outputting whatever it finds (except for an immediately following newline - see instruction separation) until it hits another opening tag
        unless in the middle of a conditional statement in which case the interpreter will determine the outcome of the conditional before making a decision of what to skip over. See the next example.
      </p>


      Using structures with conditions

      <h2>Example #1 Advanced escaping using conditions</h2>
      <code>
        &lt;?php if ($expression == true): ?&gt;<br>
        This will show if the expression is true.<br>
        &lt;?php else: ?&gt;<br>
        Otherwise this will show.<br>
        &lt;?php endif; ?&gt;<br>
      </code>
      <p>
        In this example PHP will skip the blocks where the condition is not met, even though they are outside of the PHP open/close tags; PHP skips them according to the condition since the PHP interpreter will jump over blocks contained within a
        condition that is not met.
      </p>
      <p>
        For outputting large blocks of text, dropping out of PHP parsing mode is generally more efficient than sending all of the text through echo or print.
      </p>
      <p>
        In PHP 5, there are up to five different pairs of opening and closing tags available in PHP, depending on how PHP is configured. Two of these, &lt;?php ?&gt; and &lt;script language="php"&gt; &lt;/script&gt;, are always available. There is
        also
        the short echo tag &lt;?= ?&gt;, which is always available in PHP 5.4.0 and later.
      </p>
      <p>
        The other two are short tags and ASP style tags. As such, while some people find short tags and ASP style tags convenient, they are less portable, and generally not recommended.
      </p>

      <ul class="note-comment">
        <li>
          Also note that if you are embedding PHP within XML or XHTML you will need to use the &lt;?php ?&gt; tags to remain compliant with standards.
        </li>
      </ul>
      <p>
        PHP 7 removes support for ASP tags and &lt;script language="php"&gt; tags. As such, we recommend only using &lt;?php ?&gt; and &lt;?= ?&gt; when writing PHP code to maximise compatibility.
      </p>
      <h2>Example #2 PHP Opening and Closing Tags</h2>

      <code>
        <li>
          &lt;?php echo 'if you want to serve PHP code in XHTML or XML documents,
          use these tags'; ?&gt;
        </li>
        <li>
          You can use the short echo tag to &lt;?= 'print this string' ?&gt;.
          It's always enabled in PHP 5.4.0 and later, and is equivalent to
          &lt; ?php echo 'print this string' ?&gt;.
        </li>
        <li>

          &lt;? echo 'this code is within short tags, but will only work '.
          'if short_open_tag is enabled'; ?&gt;
        </li>
        <li>

          &lt;script language="php"&gt;
          echo 'some editors (like FrontPage) don\'t
          like processing instructions within these tags';
          &lt;/script&gt;
          This syntax is removed in PHP 7.0.0.
        </li>
        <li>

          &lt;% echo 'You may optionally use ASP-style tags'; %&gt;
          Code within these tags &lt;%= $variable; %&gt; is a shortcut for this code
          &lt;% echo $variable; %&gt;
          Both of these syntaxes are removed in PHP 7.0.0.
        </li>
      </code>

      <p>
        Short tags (example three) are only available when they are enabled via the
        short_open_tag php.ini configuration file directive, or if PHP was configured
        with the --enable-short-tags option.
      </p>
      <p>
        ASP style tags (example five) are only available when they are enabled via
        the asp_tags php.ini configuration file directive, and have been removed in
        PHP 7.0.0.
      </p>
      <ul class="note-comment">
        <li>

          Using short tags should be avoided when developing applications or
          libraries that are meant for redistribution, or deployment on PHP servers
          which are not under your control, because short tags may not be supported
          on the target server. For portable, redistributable code, be sure not to use short tags.

        </li>
        <li>

          In PHP 5.2 and earlier, the parser does not allow the &lt;?php opening tag
          to be the only thing in a file. This is allowed as of PHP 5.3 provided there
          are one or more whitespace characters after the opening tag.
        </li>
        <li>


          Starting with PHP 5.4, short echo tag &lt;?= is always recognized and valid,
          regardless of the short_open_tag setting.
        </li>
      </ul>
    </section>


    <section class="main-section" id="Instruction_separation">
      <header>Instruction separation</header>
      <p>
        As in C or Perl, PHP requires instructions to be terminated with a semicolon
        at the end of each statement. The closing tag of a block of PHP code
        automatically implies a semicolon; you do not need to have a semicolon
        terminating the last line of a PHP block. The closing tag for the block
        will include the immediately trailing newline if one is present.
      </p>
      <code>
        &lt;?php<br>
        echo 'This is a test';<br>
        ?&gt;<br>

        &lt;?php echo 'This is a test' ?&gt;<br>

        &lt;?php echo 'We omitted the last closing tag';<br>
      </code>

      <p class="note-comment">
        The closing tag of a PHP block at the end of a file is optional, and in
        some cases omitting it is helpful when using include or require, so unwanted
        whitespace will not occur at the end of files, and you will still be able
        to add headers to the response later. It is also handy if you use output
        buffering, and would not like to see added unwanted whitespace at the end
        of the parts generated by the included files.
      </p>
    </section>


    <section class="main-section" id="Comments">
      <header>Comments</header>
      <p>PHP supports 'C', 'C++' and Unix shell-style (Perl style) comments. For example:
        <code>
          &lt;?php
          echo 'This is a test'; // This is a one-line c++ style comment
          /* This is a multi line comment
          yet another line of comment */
          echo 'This is yet another test';
          echo 'One Final Test'; # This is a one-line shell-style comment
          ?&gt;
        </code>
        <p>
          The "one-line" comment styles only comment to the end of the line or the current block of PHP code, whichever comes first. This means that HTML code after // ... ?&gt; or # ... ?&gt; WILL be printed: ?&gt; breaks out of PHP mode and
          returns
          to HTML mode, and // or # cannot influence that. If the asp_tags configuration directive is enabled, it behaves the same with // %&gt; and # %&gt;. However, the &lt;/script&gt; tag doesn't break out of PHP mode in a one-line comment.
        </p>
        <code>
          &lt;h1&gt;This is an &lt;?php # echo 'simple';?&gt; example&lt;/h1&gt;
          &lt;p&gt;The header above will say 'This is an example'.&lt;/p&gt;
        </code>
        <p>
          'C' style comments end at the first */ encountered. Make sure you don't nest 'C' style comments. It is easy to make this mistake if you are trying to comment out a large block of code.
        </p>
        <code>
          &lt;?php
          /*
          echo 'This is a test'; /* This comment will cause a problem */
          */
          ?&gt;
        </code>
    </section>


    <h1 id="Types"> Types </h1>
    <section class="main-section" id="Types_Introduction">
      <header>Types Introduction</header>
      <p>
        PHP supports ten primitive types.
      </p>
      <p>
        Four scalar types:
      </p>
      <ul>
        <li>
          boolean
        </li>
        <li>
          integer
        </li>
        <li>
          float (floating-point number, aka double)
        </li>
        <li>
          string
        </li>
      </ul>

      <p>
        Four compound types:
      </p>
      <ul>
        <li>
          array
        </li>
        <li>
          object
        </li>
        <li>
          callable
        </li>
        <li>
          iterable
        </li>

      </ul>
      <p>
        And finally two special types:
      </p>
      <ul>
        <li>
          resource
        </li>
        <li>
          NULL
        </li>
      </ul>
      <p>
        This manual also introduces some pseudo-types for readability reasons:
      </p>
      <ul>
        <li>
          mixed
        </li>
        <li>
          number
        </li>
        <li>
          callback (aka callable)
        </li>
        <li>
          array|object
        </li>
        <li>
          void
        </li>
      </ul>
      <p>
        And the pseudo-variable $....
      </p>
      <p>
        Some references to the type "double" may remain in the manual.
        Consider double the same as float; the two names exist only for historic reasons.
      </p>

      <p>
        The type of a variable is not usually set by the programmer; rather,
        it is decided at runtime by PHP depending on the context in which that variable is used.
      </p>

      <p class="note-comment">
        To check the type and value of an expression, use the var_dump() function.

        To get a human-readable representation of a type for debugging, use the
        gettype() function. To check for a certain type, do not use gettype(),
        but rather the is_type functions. Some examples:
        <code>
          &lt;?php<br>
          $a_bool = TRUE; // a boolean<br>
          $a_str = "foo"; // a string<br>
          $a_str2 = 'foo'; // a string<br>
          $an_int = 12; // an integer<br>
          <br>
          echo gettype($a_bool); // prints out: boolean<br>
          echo gettype($a_str); // prints out: string<br>
          <br>
          // If this is an integer, increment it by four<br>
          if (is_int($an_int)) {<br>
          $an_int += 4;<br>
          }<br>
          <br>
          // If $a_bool is a string, print it out<br>
          // (does not print out anything)<br>
          if (is_string($a_bool)) {<br>
          echo "String: $a_bool";<br>
          }<br>
          ?&gt;<br>
        </code>

      </p>
      <p>
        To forcibly convert a variable to a certain type, either cast the variable or use the settype() function on it.
      </p>

      <p>

        Note that a variable may be evaluated with different values in certain situations, depending on what type it is at the time. For more information, see the section on Type Juggling. The type comparison tables may also be useful, as they show
        examples of various type-related comparisons.
      </p>
    </section>


    <section class="main-section" id="Booleans">
      <header>Booleans</header>

      <p>
        To specify a boolean literal, use the constants TRUE or FALSE. Both are case-insensitive.
      </p>
      <code>
        &lt;?php
        $foo = True; // assign the value TRUE to $foo
        ?&gt;
      </code>
      <p>
        Typically, the result of an operator which returns a boolean value is passed on to a control structure.
      </p>
      <code>
        &lt;?php<br>
        // == is an operator which tests<br>
        // equality and returns a boolean<br>
        if ($action == "show_version") {<br>
        echo "The version is 1.23";<br>
        }<br>
        <br>
        // this is not necessary...<br>
        if ($show_separators == TRUE) {<br>
        echo "&lt;hr&gt;\n";<br>
        }<br>
        <br>
        // ...because this can be used with exactly the same meaning:<br>
        if ($show_separators) {<br>
        echo "&lt;hr&gt;\n";<br>
        }<br>
        ?&gt;<br>
      </code>

      <h2>
        Converting to boolean
      </h2>
      <p>
        To explicitly convert a value to boolean, use the (bool) or (boolean) casts. However, in most cases the cast is unnecessary, since a value will be automatically converted if an operator, function or control structure requires a boolean
        argument.
      </p>

      <p>
        When converting to boolean, the following values are considered FALSE:
      </p>
      <ul>
        <li>
          the boolean FALSE itself
        </li>
        <li>

          the integer 0 (zero)
        </li>
        <li>
          the float 0.0 (zero)
        </li>
        <li>
          the empty string, and the string "0"
        </li>

        <li>
          an array with zero elements
        </li>
        <li>
          the special type NULL (including unset variables)
        </li>
        <li>
          SimpleXML objects created from empty tags
        </li>
      </ul>

      <p>
        Every other value is considered TRUE (including any resource and NAN).
      </p>
      <div class="note-comment">

        <h3>
          Warning
        </h3>
        -1 is considered TRUE, like any other non-zero (whether negative or positive) number!
      </div>
      <code>
        &lt;?php<br>
        var_dump((bool) ""); // bool(false)<br>
        var_dump((bool) 1); // bool(true)<br>
        var_dump((bool) -2); // bool(true)<br>
        var_dump((bool) "foo"); // bool(true)<br>
        var_dump((bool) 2.3e5); // bool(true)<br>
        var_dump((bool) array(12)); // bool(true)<br>
        var_dump((bool) array()); // bool(false)<br>
        var_dump((bool) "false"); // bool(true)<br>
        ?&gt; <br>
      </code>
    </section>


    <section class="main-section" id="Integers">
      <header>Integers</header>
      <p>
        An integer is a number of the set ℤ = {..., -2, -1, 0, 1, 2, ...}.
      </p>
      <p>
        Integers can be specified in decimal (base 10), hexadecimal (base 16), octal (base 8) or binary (base 2) notation. The negation operator can be used to denote a negative integer.
      </p>
      <p>
        Binary integer literals are available since PHP 5.4.0.
      </p>
      <p>
        To use octal notation, precede the number with a 0 (zero). To use hexadecimal notation precede the number with 0x. To use binary notation precede the number with 0b.
      </p>
      <p>
        Example #1 Integer literals
      </p>
      <code>
        &lt;?php<br>
        $a = 1234; // decimal number<br>
        $a = -123; // a negative number<br>
        $a = 0123; // octal number (equivalent to 83 decimal)<br>
        $a = 0x1A; // hexadecimal number (equivalent to 26 decimal)<br>
        $a = 0b11111111; // binary number (equivalent to 255 decimal)<br>
        ?&gt;<br>
      </code>
      <p>
        Formally, the structure for integer literals is:
      </p>

      decimal : [1-9][0-9]*
      | 0

      hexadecimal : 0[xX][0-9a-fA-F]+

      octal : 0[0-7]+

      binary : 0[bB][01]+

      integer : decimal
      | hexadecimal
      | octal
      | binary
      <p>
        The size of an integer is platform-dependent, although a maximum value of about two billion is the usual value (that's 32 bits signed). 64-bit platforms usually have a maximum value of about 9E18, except on Windows prior to PHP 7, where it
        was always 32 bit. PHP does not support unsigned integers. Integer size can be determined using the constant PHP_INT_SIZE, maximum value using the constant PHP_INT_MAX since PHP 5.0.5, and minimum value using the constant PHP_INT_MIN since
        PHP 7.0.0.
      </p>
      <div>

        <h3>
          Warning
        </h3>

        Prior to PHP 7, if an invalid digit was given in an octal integer (i.e. 8 or 9), the rest of the number was ignored. Since PHP 7, a parse error is emitted.
      </div>
      <h2>
        Integer overflow ¶
      </h2>
      <p>
        If PHP encounters a number beyond the bounds of the integer type, it will be interpreted as a float instead. Also, an operation which results in a number beyond the bounds of the integer type will return a float instead.
      </p>
      <p>
        Example #2 Integer overflow on a 32-bit system
      </p>
      <code>
        &lt;?php<br>
        $large_number = 2147483647;<br>
        var_dump($large_number); // int(2147483647)<br>
        <br>
        $large_number = 2147483648;<br>
        var_dump($large_number); // float(2147483648)<br>
        <br>
        $million = 1000000;<br>
        $large_number = 50000 * $million;<br>
        var_dump($large_number); // float(50000000000)<br>
        ?&gt;<br>
      </code>
      <p>
        Example #3 Integer overflow on a 64-bit system
      </p>
      <code>
        &lt;?php<br>
        $large_number = 9223372036854775807;<br>
        var_dump($large_number); // int(9223372036854775807)<br>
        <br>
        $large_number = 9223372036854775808;<br>
        var_dump($large_number); // float(9.2233720368548E+18)<br>
        <br>
        $million = 1000000;<br>
        $large_number = 50000000000000 * $million;<br>
        var_dump($large_number); // float(5.0E+19)<br>
        ?&gt;<br>
      </code>
      <p>
        There is no integer division operator in PHP. 1/2 yields the float 0.5. The value can be casted to an integer to round it towards zero, or the round() function provides finer control over rounding.
      </p>
      <code>
        &lt;?php<br>
        var_dump(25/7); // float(3.5714285714286)<br>
        var_dump((int) (25/7)); // int(3)<br>
        var_dump(round(25/7)); // float(4)<br>
        ?&gt;<br>
      </code>
      <h2>
        Converting to integer ¶
      </h2>
      <p>
        To explicitly convert a value to integer, use either the (int) or (integer) casts. However, in most cases the cast is not needed, since a value will be automatically converted if an operator, function or control structure requires an integer
        argument. A value can also be converted to integer with the intval() function.
      </p>
      <p>
        If a resource is converted to an integer, then the result will be the unique resource number assigned to the resource by PHP at runtime.
      </p>
      <p>
        FALSE will yield 0 (zero), and TRUE will yield 1 (one).
      </p>
      <p>
        When converting from float to integer, the number will be rounded towards zero.
      </p>
      <p>
        If the float is beyond the boundaries of integer (usually +/- 2.15e+9 = 2^31 on 32-bit platforms and +/- 9.22e+18 = 2^63 on 64-bit platforms other than Windows), the result is undefined, since the float doesn't have enough precision to give
        an exact integer result. No warning, not even a notice will be issued when this happens!
      </p>
      <p>
        Note:As of PHP 7.0.0, instead of being undefined and platform-dependent, NaN and Infinity will always be zero when cast to integer.
      </p>
      <div>
        <h3>
          Warning
        </h3>
        Never cast an unknown fraction to integer, as this can sometimes lead to unexpected results.
      </div>
      <code>
        &lt;?php<br>
        echo (int) ( (0.1+0.7) * 10 ); // echoes 7!<br>
        ?&gt;<br>
      </code>
      <p>
        NULL is always converted to zero (0).
      </p>
    </section>


    <section class="main-section" id="Floating_point_numbers">
      <header>Floating point numbers</header>
      Floating point numbers (also known as "floats", "doubles", or "real numbers") can be specified using any of the following syntaxes:
      <code>
        &lt;?php<br>
        $a = 1.234;<br>
        $b = 1.2e3;<br>
        $c = 7E-10;<br>
        ?&gt;<br>
      </code>
      <p>
        Formally:<br>

        LNUM [0-9]+<br>
        DNUM ([0-9]*[\.]{LNUM}) | ({LNUM}[\.][0-9]*)<br>
        EXPONENT_DNUM [+-]?(({LNUM} | {DNUM}) [eE][+-]? {LNUM})<br>
      </p>
      <p>
        The size of a float is platform-dependent, although a maximum of approximately 1.8e308 with a precision of roughly 14 decimal digits is a common value (the 64 bit IEEE format).
      </p>
      <p>
        Floating point numbers have limited precision. Although it depends on the system, PHP typically uses the IEEE 754 double precision format, which will give a maximum relative error due to rounding in the order of 1.11e-16. Non elementary
        arithmetic operations may give larger errors, and, of course, error propagation must be considered when several operations are compounded.
      </p>
      <p>
        Additionally, rational numbers that are exactly representable as floating point numbers in base 10, like 0.1 or 0.7, do not have an exact representation as floating point numbers in base 2, which is used internally, no matter the size of the
        mantissa. Hence, they cannot be converted into their internal binary counterparts without a small loss of precision. This can lead to confusing results: for example, floor((0.1+0.7)*10) will usually return 7 instead of the expected 8, since
        the internal representation will be something like 7.9999999999999991118....
      </p>
      <p>
        So never trust floating number results to the last digit, and do not compare floating point numbers directly for equality. If higher precision is necessary, the arbitrary precision math functions and gmp functions are available.
      </p>
      <p>
        For a "simple" explanation, see the » floating point guide that's also titled "Why don’t my numbers add up?"
      </p>
      <h2>
        Converting to float ¶
      </h2>
      <p>
        For information on converting strings to float, see String conversion to numbers. For values of other types, the conversion is performed by converting the value to integer first and then to float. See Converting to integer for more
        information. As of PHP 5, a notice is thrown if an object is converted to float.
      </p>
      <h2>
        Comparing floats ¶
      </h2>
      <p>
        As noted in the warning above, testing floating point values for equality is problematic, due to the way that they are represented internally. However, there are ways to make comparisons of floating point values that work around these
        limitations.
      </p>
      <p>
        To test floating point values for equality, an upper bound on the relative error due to rounding is used. This value is known as the machine epsilon, or unit roundoff, and is the smallest acceptable difference in calculations.
      </p>
      <p>
        $a and $b are equal to 5 digits of precision.
      </p>
      <code>
        &lt;?php<br>
        $a = 1.23456789;<br>
        $b = 1.23456780;<br>
        $epsilon = 0.00001;<br>
        <br>
        if(abs($a-$b) $lt $epsilon) {<br>
        echo "true";<br>
        }<br>
        ?&gt;<br>
      </code>
      <p>
        Some numeric operations can result in a value represented by the constant NAN. This result represents an undefined or unrepresentable value in floating-point calculations. Any loose or strict comparisons of this value against any other
        value, including itself, but except TRUE, will have a result of FALSE.
      </p>
      <p>
        Because NAN represents any number of different values, NAN should not be compared to other values, including itself, and instead should be checked for using is_nan().
      </p>
    </section>


    <section class="main-section" id="Strings">
      <header>Strings</header>
      <p>
        A string is series of characters, where a character is the same as a byte. This means that PHP only supports a 256-character set, and hence does not offer native Unicode support. See details of the string type.
      </p>
      <p>
        Note: As of PHP 7.0.0, there are no particular restrictions regarding the length of a string on 64-bit builds. On 32-bit builds and in earlier versions, a string can be as large as up to 2GB (2147483647 bytes maximum)
      </p>
      <h2>
        Syntax ¶
      </h2>
      <p>
        A string literal can be specified in four different ways:
      </p>
      <h2>
        Single quoted ¶
      </h2>
      <p>
        The simplest way to specify a string is to enclose it in single quotes (the character ').
      </p>
      <p>
        To specify a literal single quote, escape it with a backslash (\). To specify a literal backslash, double it (\\). All other instances of backslash will be treated as a literal backslash: this means that the other escape sequences you might
        be
        used to, such as \r or \n, will be output literally as specified rather than having any special meaning.
      </p>
      <p>
        Note: Unlike the double-quoted and heredoc syntaxes, variables and escape sequences for special characters will not be expanded when they occur in single quoted strings.
      </p>

      <code>
        &lt;?php<br>
        echo 'this is a simple string';<br>

        echo 'You can also have embedded newlines in<br>
        strings this way as it is<br>
        okay to do';<br>

        // Outputs: Arnold once said: "I'll be back"<br>
        echo 'Arnold once said: "I\'ll be back"';<br>

        // Outputs: You deleted C:\*.*?<br>
        echo 'You deleted C:\\*.*?';<br>

        // Outputs: You deleted C:\*.*?<br>
        echo 'You deleted C:\*.*?';<br>

        // Outputs: This will not expand: \n a newline<br>
        echo 'This will not expand: \n a newline';<br>

        // Outputs: Variables do not $expand $either<br>
        echo 'Variables do not $expand $either';<br>
        ?&gt;<br>
      </code>
      <h2>
        Double quoted ¶
      </h2>
      <p>
        If the string is enclosed in double-quotes ("), PHP will interpret the following escape sequences for special characters:
        Escaped characters Sequence Meaning
      </p>
      <code>
        \n linefeed (LF or 0x0A (10) in ASCII)<br>
        \r carriage return (CR or 0x0D (13) in ASCII)<br>
        \t horizontal tab (HT or 0x09 (9) in ASCII)<br>
        \v vertical tab (VT or 0x0B (11) in ASCII) (since PHP 5.2.5)<br>
        \e escape (ESC or 0x1B (27) in ASCII) (since PHP 5.4.4)<br>
        \f form feed (FF or 0x0C (12) in ASCII) (since PHP 5.2.5)<br>
        \\ backslash<br>
        \$ dollar sign<br>
        \" double-quote<br>
        \[0-7]{1,3} the sequence of characters matching the regular expression is a character in octal notation, which silently overflows to fit in a byte (e.g. "\400" === "\000")<br>
        \x[0-9A-Fa-f]{1,2} the sequence of characters matching the regular expression is a character in hexadecimal notation<br>
        \u{[0-9A-Fa-f]+} the sequence of characters matching the regular expression is a Unicode codepoint, which will be output to the string as that codepoint's UTF-8 representation (added in PHP 7.0.0)<br>
      </code>
      <p>
        As in single quoted strings, escaping any other character will result in the backslash being printed too. Before PHP 5.1.1, the backslash in \{$var} had not been printed.
      </p>
      <p>
        The most important feature of double-quoted strings is the fact that variable names will be expanded. See string parsing for details.
      </p>
      <h2>
        Heredoc ¶
      </h2>
      <p>
        A third way to delimit strings is the heredoc syntax: &lt;&lt;&lt;. After this operator, an identifier is provided, then a newline. The string itself follows, and then the same identifier again to close the quotation. The closing identifier
        must
        begin in the first column of the line. Also, the identifier must follow the same naming rules as any other label in PHP: it must contain only alphanumeric characters and underscores, and must start with a non-digit character or underscore.
        Warning It is very important to note that the line with the closing identifier must contain no other characters, except a semicolon (;). That means especially that the identifier may not be indented, and there may not be any spaces or tabs
        before or after the semicolon. It's also important to realize that the first character before the closing identifier must be a newline as defined by the local operating system. This is \n on UNIX systems, including macOS. The closing
        delimiter must also be followed by a newline. If this rule is broken and the closing identifier is not "clean" , it will not be considered a closing identifier, and PHP will continue looking for one. If a proper closing identifier is not
        found before the end of the current file, a parse error will result at the last line. Example #1 Invalid example </p> <code>
        &lt;?<br>
        php<br>
        class foo {<br>
        public $bar = &lt;&lt;&lt;EOT<br>
        bar<br>
        EOT;<br>
        }<br>
        // Identifier must not be indented<br>
        ?&gt;<br>
      </code>

      Example #2 Valid example
      <code>
        &lt;?php<br>
        class foo {<br>
        public $bar = &lt;&lt;&lt;EOT<br>
        bar<br>
        EOT;<br>
        }<br>
        ?&gt;<br>
      </code>
      <p>
        Heredocs can not be used for initializing class properties. Since PHP 5.3, this limitation is valid only for heredocs containing variables.
      </p>
      <p>
        Heredoc text behaves just like a double-quoted string, without the double quotes. This means that quotes in a heredoc do not need to be escaped, but the escape codes listed above can still be used. Variables are expanded, but the same
        care
        must be taken when expressing complex variables inside a heredoc as with strings.
      </p>
      <h2>
        Example #3 Heredoc string quoting example
      </h2>
      <code>
        &lt;?php<br>
        $str = &lt;&lt;&lt;EOD<br>
        Example of string<br>
        spanning multiple lines<br>
        using heredoc syntax.<br>
        EOD;<br>

        /* More complex example, with variables. */<br>
        class foo<br>
        {<br>
        var $foo;<br>
        var $bar;<br>

        function __construct()<br>
        {<br>
        $this-&gt;foo = 'Foo';<br>
        $this-&gt;bar = array('Bar1', 'Bar2', 'Bar3');<br>
        }<br>
        }<br>

        $foo = new foo();<br>
        $name = 'MyName';<br>

        echo &lt;&lt;&lt;EOT<br>
        My name is "$name". I am printing some $foo-&gt;foo.<br>
        Now, I am printing some {$foo-&gt;bar[1]}.<br>
        This should print a capital 'A': \x41<br>
        EOT;<br>
        ?&gt;<br>
      </code>
      <p>
        The above example will output:
      </p>
      <code>
        My name is "MyName". I am printing some Foo.<br>
        Now, I am printing some Bar2.<br>
        This should print a capital 'A': A<br>
      </code>
      <p>
        It is also possible to use the Heredoc syntax to pass data to function arguments:
      </p>
      <p>
        Example #4 Heredoc in arguments example
      </p>
      <code>
        &lt;?php<br>
        var_dump(array(&lt;&lt;&lt;EOD<br>
        foobar!<br>
        EOD<br>
        ));<br>
        ?&gt;<br>
      </code>
      <p>
        As of PHP 5.3.0, it's possible to initialize static variables and class properties/constants using the Heredoc syntax:
      </p>

      <p>
        Example #5 Using Heredoc to initialize static values
      </p>
      <code>
        &lt;?php<br>
        // Static variables<br>
        function foo()<br>
        {<br>
        static $bar = &lt;&lt;&lt;LABEL<br>
        Nothing in here...<br>
        LABEL;<br>
        }<br>

        // Class properties/constants<br>
        class foo<br>
        {<br>
        const BAR = &lt;&lt;&lt;FOOBAR<br>
        Constant example<br>
        FOOBAR;<br>

        public $baz = &lt;&lt;&lt;FOOBAR<br>
        Property example<br>
        FOOBAR;<br>
        }<br>
        ?&gt;<br>
      </code>
      <p>
        Starting with PHP 5.3.0, the opening Heredoc identifier may optionally be enclosed in double quotes:
      </p>
      <p>
        Example #6 Using double quotes in Heredoc
      </p>
      <code>
        &lt;?php<br>
        echo &lt;&lt;&lt;"FOOBAR" Hello World! FOOBAR; <br>
        ?&gt;<br>
      </code>
      <h2>
        Nowdoc ¶
      </h2>
      <p>
        Nowdocs are to single-quoted strings what heredocs are to double-quoted strings. A nowdoc is specified similarly to a heredoc, but no parsing is done inside a nowdoc. The
        construct is ideal for embedding PHP code or other large blocks of text without the need for escaping. It shares some features in common with the SGML &lt;![CDATA[ ]]&gt; construct, in that it declares a block of text which is not for
        parsing.
      </p>
      <p>
        A nowdoc is identified with the same &lt;&lt;&lt; sequence used for heredocs, but the identifier which follows is enclosed in single quotes, e.g. &lt;&lt;&lt;'EOT'. All the rules for heredoc identifiers also apply to nowdoc identifiers,
        especially those regarding the appearance of the closing identifier. Example #7 Nowdoc string quoting example
      </p>
      <code>
        &lt;?php<br>
        $str = &lt;&lt;&lt;'EOD' Example of string spanning multiple lines using nowdoc syntax. EOD; /* More complex example, with variables. */ class foo { public $foo; public $bar; function __construct() { $this-&gt;foo = 'Foo';<br>
        $this-&gt;bar = array('Bar1', 'Bar2', 'Bar3');<br>
        }<br>
        }<br>

        $foo = new foo();<br>
        $name = 'MyName';<br>

        echo &lt;&lt;&lt;'EOT' My name is "$name" . I am printing some $foo-&gt;foo.<br>
        Now, I am printing some {$foo-&gt;bar[1]}.<br>
        This should not print a capital 'A': \x41<br>
        EOT;<br>
        ?&gt;<br>
      </code>
      <p>
        The above example will output:
      </p>
      <code>
        My name is "$name". I am printing some $foo-&gt;foo.
        Now, I am printing some {$foo-&gt;bar[1]}.
        This should not print a capital 'A': \x41
      </code>
      <p>
        Example #8 Static data example
      </p>
      <code>
        &lt;?php<br>
        class foo {<br>
        public $bar = &lt;&lt;&lt;'EOT' bar EOT; } <br>
        ?&gt; <br>
      </code>
      <p>
        Note: Nowdoc support was added in PHP 5.3.0. Variable parsing ¶ When a string is specified in double quotes or with heredoc, variables are parsed within it. There are two types of syntax: a
        simple one and a complex one. The simple syntax is the most common and convenient. It provides a way to embed a variable, an array value, or an object property in a string with a minimum of effort. The complex syntax can be recognised by
        the curly braces surrounding the expression. Simple syntax If a dollar sign ($) is encountered, the parser will greedily take as many tokens as possible to form a valid variable name. Enclose the variable name in curly braces to
        explicitly specify the end of the name.
      </p>
      <code>
        &lt;?php<br>
        $juice = "apple";<br>

        echo "He drank some $juice juice.".PHP_EOL;<br>
        // Invalid. "s" is a valid character for a variable name, but the variable is $juice.<br>
        echo "He drank some juice made of $juices.";<br>
        // Valid. Explicitly specify the end of the variable name by enclosing it in braces:<br>
        echo "He drank some juice made of ${juice}s.";<br>
        ?&gt;<br>
      </code>
      <p>
        The above example will output:
      </p>
      <code>
        He drank some apple juice.<br>
        He drank some juice made of .<br>
        He drank some juice made of apples.<br>
      </code>
      <p>
        Similarly, an array index or an object property can be parsed. With array indices, the closing square bracket (]) marks the end of the index. The same rules apply to object properties as to simple variables.
      </p>
      <p>
        Example #9 Simple syntax example
      </p>
      <code>
        &lt;?php<br>
        $juices = array("apple", "orange", "koolaid1" => "purple");<br>
        <br>
        echo "He drank some $juices[0] juice.".PHP_EOL;<br>
        echo "He drank some $juices[1] juice.".PHP_EOL;<br>
        echo "He drank some $juices[koolaid1] juice.".PHP_EOL;<br>
        <br>
        class people {<br>
        public $john = "John Smith";<br>
        public $jane = "Jane Smith";<br>
        public $robert = "Robert Paulsen";<br>
        <br>
        public $smith = "Smith";<br>
        }<br>
        <br>
        $people = new people();<br>
        <br>
        echo "$people-&gt;john drank some $juices[0] juice.".PHP_EOL;<br>
        echo "$people-&gt;john then said hello to $people-&gt;jane.".PHP_EOL;<br>
        echo "$people-&gt;john's wife greeted $people-&gt;robert.".PHP_EOL;<br>
        echo "$people-&gt;robert greeted the two $people-&gt;smiths."; // Won't work<br>
        ?&gt;<br>
      </code>
      <p>
        The above example will output:
      </p>
      <code>
        He drank some apple juice.
        He drank some orange juice.
        He drank some purple juice.
        John Smith drank some apple juice.
        John Smith then said hello to Jane Smith.
        John Smith's wife greeted Robert Paulsen.
        Robert Paulsen greeted the two .
      </code>
      <p>
        As of PHP 7.1.0 also negative numeric indices are supported.
      </p>
      <p>
        Example #10 Negative numeric indices
      </p>
      <code>
        &lt;?php<br>
        $string = 'string';<br>
        echo "The character at index -2 is $string[-2].", PHP_EOL;<br>
        $string[-3] = 'o';<br>
        echo "Changing the character at index -3 to o gives $string.", PHP_EOL;<br>
        ?&gt;<br>
      </code>
      <p>
        The above example will output:
      </p>
      <code>
        The character at index -2 is n.<br>
        Changing the character at index -3 to o gives strong.<br>
      </code>
      <p>
        For anything more complex, you should use the complex syntax.
        Complex (curly) syntax
      </p>
      <p>
        This isn't called complex because the syntax is complex, but because it allows for the use of complex expressions.
      </p>
      <p>
        Any scalar variable, array element or object property with a string representation can be included via this syntax. Simply write the expression the same way as it would appear outside the string, and then wrap it in { and }. Since { can
        not
        be escaped, this syntax will only be recognised when the $ immediately follows the {. Use {\$ to get a literal {$. Some examples to make it clear:
      </p>
      <code>
        &lt;?php<br>
        // Show all errors<br>
        error_reporting(E_ALL);<br>

        $great = 'fantastic';<br>

        // Won't work, outputs: This is { fantastic}<br>
        echo "This is { $great}";<br>

        // Works, outputs: This is fantastic<br>
        echo "This is {$great}";<br>

        // Works<br>
        echo "This square is {$square-&gt;width}00 centimeters broad.";<br>


        // Works, quoted keys only work using the curly brace syntax<br>
        echo "This works: {$arr['key']}";<br>


        // Works<br>
        echo "This works: {$arr[4][3]}";<br>

        // This is wrong for the same reason as $foo[bar] is wrong outside a string.<br>
        // In other words, it will still work, but only because PHP first looks for a<br>
        // constant named foo; an error of level E_NOTICE (undefined constant) will be<br>
        // thrown.<br>
        echo "This is wrong: {$arr[foo][3]}";<br>

        // Works. When using multi-dimensional arrays, always use braces around arrays<br>
        // when inside of strings<br>
        echo "This works: {$arr['foo'][3]}";<br>

        // Works.<br>
        echo "This works: " . $arr['foo'][3];<br>

        echo "This works too: {$obj-&gt;values[3]-&gt;name}";<br>

        echo "This is the value of the var named $name: {${$name}}";<br>

        echo "This is the value of the var named by the return value of getName(): {${getName()}}";<br>

        echo "This is the value of the var named by the return value of \$object-&gt;getName(): {${$object-&gt;getName()}}";<br>

        // Won't work, outputs: This is the return value of getName(): {getName()}<br>
        echo "This is the return value of getName(): {getName()}";<br>
        ?&gt;<br>
      </code>
      <p>
        It is also possible to access class properties using variables within strings using this syntax.
      </p>
      <code>
        &lt;?php<br>
        class foo {<br>
        var $bar = 'I am bar.';<br>
        }<br>

        $foo = new foo();<br>
        $bar = 'bar';<br>
        $baz = array('foo', 'bar', 'baz', 'quux');<br>
        echo "{$foo-&gt;$bar}\n";<br>
        echo "{$foo-&gt;{$baz[1]}}\n";<br>
        ?&gt;<br>
      </code>
      <p>
        The above example will output:
      </p>
      <code>
        I am bar.<br>
        I am bar.<br>
      </code>
      <p>
        Note:

        Functions, method calls, static class variables, and class constants inside {$} work since PHP 5. However, the value accessed will be interpreted as the name of a variable in the scope in which the string is defined. Using single curly
        braces ({}) will not work for accessing the return values of functions or methods or the values of class constants or static class variables.

      </p>
      <code>
        &lt;?php<br>
        // Show all errors.<br>
        error_reporting(E_ALL);<br>

        class beers {<br>
        const softdrink = 'rootbeer';<br>
        public static $ale = 'ipa';<br>
        }<br>

        $rootbeer = 'A & W';<br>
        $ipa = 'Alexander Keith\'s';<br>

        // This works; outputs: I'd like an A & W<br>
        echo "I'd like an {${beers::softdrink}}\n";<br>

        // This works too; outputs: I'd like an Alexander Keith's<br>
        echo "I'd like an {${beers::$ale}}\n";<br>
        ?&gt;<br>
      </code>
      <h2>
        String access and modification by character ¶
      </h2>
      <p>
        Characters within strings may be accessed and modified by specifying the zero-based offset of the desired character after the string using square array brackets, as in $str[42]. Think of a string as an array of characters for this purpose.
        The functions substr() and substr_replace() can be used when you want to extract or replace more than 1 character.
      </p>
      <p>
        Note: As of PHP 7.1.0, negative string offsets are also supported. These specify the offset from the end of the string. Formerly, negative offsets emitted E_NOTICE for reading (yielding an empty string) and E_WARNING for writing (leaving the
        string untouched).
      </p>
      <p>
        Note: Strings may also be accessed using braces, as in $str{42}, for the same purpose.
      </p>
      <div class="note-comment">
        <h3>
          Warning
        </h3>

        Writing to an out of range offset pads the string with spaces. Non-integer types are converted to integer. Illegal offset type emits E_NOTICE. Only the first character of an assigned string is used. As of PHP 7.1.0, assigning an empty
        string
        throws a fatal error. Formerly, it assigned a NULL byte.
      </div>
      <div class="note-comment">
        <h3>
          Warning
        </h3>

        Internally, PHP strings are byte arrays. As a result, accessing or modifying a string using array brackets is not multi-byte safe, and should only be done with strings that are in a single-byte encoding such as ISO-8859-1.
      </div>
      <p>
        Note: As of PHP 7.1.0, applying the empty index operator on an empty string throws a fatal error. Formerly, the empty string was silently converted to an array.
      </p>

      <p>
        Example #11 Some string examples
      </p>
      <code>
        &lt;?php<br>
        // Get the first character of a string<br>
        $str = 'This is a test.';<br>
        $first = $str[0];<br>

        // Get the third character of a string<br>
        $third = $str[2];<br>

        // Get the last character of a string.<br>
        $str = 'This is still a test.';<br>
        $last = $str[strlen($str)-1];<br>

        // Modify the last character of a string<br>
        $str = 'Look at the sea';<br>
        $str[strlen($str)-1] = 'e';<br>

        ?&gt;<br>
      </code>
      <p>
        As of PHP 5.4 string offsets have to either be integers or integer-like strings, otherwise a warning will be thrown. Previously an offset like "foo" was silently cast to 0.
      </p>
      <p>
        Example #12 Differences between PHP 5.3 and PHP 5.4
      </p>
      <code>
        &lt;?php<br>
        $str = 'abc';<br>

        var_dump($str['1']);<br>
        var_dump(isset($str['1']));<br>

        var_dump($str['1.0']);<br>
        var_dump(isset($str['1.0']));<br>

        var_dump($str['x']);<br>
        var_dump(isset($str['x']));<br>

        var_dump($str['1x']);<br>
        var_dump(isset($str['1x']));<br>
        ?&gt;<br>
      </code>
      <p>
        Output of the above example in PHP 5.3:
      </p>
      <code>
        string(1) "b"<br>
        bool(true)<br>
        string(1) "b"<br>
        bool(true)<br>
        string(1) "a"<br>
        bool(true)<br>
        string(1) "b"<br>
        bool(true)<br>
      </code>
      <p>
        Output of the above example in PHP 5.4:
      </p>

      <code>
        string(1) "b"<br>
        bool(true)<br>
      </code>


      <p>
        Note:

        Accessing variables of other types (not including arrays or objects implementing the appropriate interfaces) using [] or {} silently returns NULL.
      </p>
      <p>
        Note:

        PHP 5.5 added support for accessing characters within string literals using [] or {}.
      </p>
      <h2>
        Useful functions and operators ¶
      </h2>
      <p>
        Strings may be concatenated using the '.' (dot) operator. Note that the '+' (addition) operator will not work for this. See String operators for more information.
      </p>
      <p>
        There are a number of useful functions for string manipulation.
      </p>
      <p>
        There are also functions for URL strings, and functions to encrypt/decrypt strings (Sodium and Hash).
      </p>
      <p>
        Finally, see also the character type functions.
      </p>
      <h2>
        Converting to string ¶
      </h2>
      <p>
        A value can be converted to a string using the (string) cast or the strval() function. String conversion is automatically done in the scope of an expression where a string is needed. This happens when using the echo or print functions, or
        when a variable is compared to a string. The sections on Types and Type Juggling will make the following clearer. See also the settype() function.
      </p>
      <p>
        A boolean TRUE value is converted to the string "1". Boolean FALSE is converted to "" (the empty string). This allows conversion back and forth between boolean and string values.
      </p>
      <p>
        An integer or float is converted to a string representing the number textually (including the exponent part for floats). Floating point numbers can be converted using exponential notation (4.1E+6).
      </p>
      <p>
        Note:

        The decimal point character is defined in the script's locale (category LC_NUMERIC). See the setlocale() function.
      </p>
      <p>
        Arrays are always converted to the string "Array"; because of this, echo and print can not by themselves show the contents of an array. To view a single element, use a construction such as echo $arr['foo']. See below for tips on viewing the
        entire contents.
      </p>
      <p>
        In order to convert objects to string magic method __toString must be used.
      </p>
      <p>
        Resources are always converted to strings with the structure "Resource id #1", where 1 is the resource number assigned to the resource by PHP at runtime. While the exact structure of this string should not be relied on and is subject to
        change, it will always be unique for a given resource within the lifetime of a script being executed (ie a Web request or CLI process) and won't be reused. To get a resource's type, use the get_resource_type() function.
      </p>
      <p>
        NULL is always converted to an empty string.
      </p>
      <p>
        As stated above, directly converting an array, object, or resource to a string does not provide any useful information about the value beyond its type. See the functions print_r() and var_dump() for more effective means of inspecting the
        contents of these types.
      </p>
      <p>
        Most PHP values can also be converted to strings for permanent storage. This method is called serialization, and is performed by the serialize() function. If the PHP engine was built with WDDX support, PHP values can also be serialized as
        well-formed XML text.
      </p>

      <h2>
        String conversion to numbers ¶
      </h2>
      <p>
        When a string is evaluated in a numeric context, the resulting value and type are determined as follows.
      </p>
      <p>
        If the string does not contain any of the characters '.', 'e', or 'E' and the numeric value fits into integer type limits (as defined by PHP_INT_MAX), the string will be evaluated as an integer. In all other cases it will be evaluated as a
        float.
      </p>
      <p>
        The value is given by the initial portion of the string. If the string starts with valid numeric data, this will be the value used. Otherwise, the value will be 0 (zero). Valid numeric data is an optional sign, followed by one or more
        digits
        (optionally containing a decimal point), followed by an optional exponent. The exponent is an 'e' or 'E' followed by one or more digits.
      </p>
      <code>
        &lt;?php<br>
        $foo = 1 + "10.5"; // $foo is float (11.5)<br>
        $foo = 1 + "-1.3e3"; // $foo is float (-1299)<br>
        $foo = 1 + "bob-1.3e3"; // $foo is integer (1)<br>
        $foo = 1 + "bob3"; // $foo is integer (1)<br>
        $foo = 1 + "10 Small Pigs"; // $foo is integer (11)<br>
        $foo = 4 + "10.2 Little Piggies"; // $foo is float (14.2)<br>
        $foo = "10.0 pigs " + 1; // $foo is float (11)<br>
        $foo = "10.0 pigs " + 1.0; // $foo is float (11)<br>
        ?&gt;<br>
      </code>
      <p>
        For more information on this conversion, see the Unix manual page for strtod(3).
      </p>
      <p>
        To test any of the examples in this section, cut and paste the examples and insert the following line to see what's going on:
      </p>
      <code>
        &lt;?php<br>
        echo "\$foo==$foo; type is " . gettype ($foo) . "<br />\n";<br>
        ?&gt;<br>
      </code>
      <p>
        Do not expect to get the code of one character by converting it to integer, as is done in C. Use the ord() and chr() functions to convert between ASCII codes and characters.
        Details of the String Type ¶
      </p>
      <p>
        The string in PHP is implemented as an array of bytes and an integer indicating the length of the buffer. It has no information about how those bytes translate to characters, leaving that task to the programmer. There are no limitations on
        the values the string can be composed of; in particular, bytes with value 0 (“NUL bytes”) are allowed anywhere in the string (however, a few functions, said in this manual not to be “binary safe”, may hand off the strings to libraries that
        ignore data after a NUL byte.)
      </p>
      <p>
        This nature of the string type explains why there is no separate “byte” type in PHP – strings take this role. Functions that return no textual data – for instance, arbitrary data read from a network socket – will still return strings.
      </p>
      <p>
        Given that PHP does not dictate a specific encoding for strings, one might wonder how string literals are encoded. For instance, is the string "á" equivalent to "\xE1" (ISO-8859-1), "\xC3\xA1" (UTF-8, C form), "\x61\xCC\x81" (UTF-8, D
        form)
        or any other possible representation? The answer is that string will be encoded in whatever fashion it is encoded in the script file. Thus, if the script is written in ISO-8859-1, the string will be encoded in ISO-8859-1 and so on.
        However,
        this does not apply if Zend Multibyte is enabled; in that case, the script may be written in an arbitrary encoding (which is explicity declared or is detected) and then converted to a certain internal encoding, which is then the encoding
        that will be used for the string literals. Note that there are some constraints on the encoding of the script (or on the internal encoding, should Zend Multibyte be enabled) – this almost always means that this encoding should be a
        compatible superset of ASCII, such as UTF-8 or ISO-8859-1. Note, however, that state-dependent encodings where the same byte values can be used in initial and non-initial shift states may be problematic.
      </p>
      <p>
        Of course, in order to be useful, functions that operate on text may have to make some assumptions about how the string is encoded. Unfortunately, there is much variation on this matter throughout PHP’s functions:
      </p>
      <p>
        Some functions assume that the string is encoded in some (any) single-byte encoding, but they do not need to interpret those bytes as specific characters. This is case of, for instance, substr(), strpos(), strlen() or strcmp(). Another way
        to think of these functions is that operate on memory buffers, i.e., they work with bytes and byte offsets.
        Other functions are passed the encoding of the string, possibly they also assume a default if no such information is given. This is the case of htmlentities() and the majority of the functions in the mbstring extension.
        Others use the current locale (see setlocale()), but operate byte-by-byte. This is the case of strcasecmp(), strtoupper() and ucfirst(). This means they can be used only with single-byte encodings, as long as the encoding is matched by the
        locale. For instance strtoupper("á") may return "Á" if the locale is correctly set and á is encoded with a single byte. If it is encoded in UTF-8, the correct result will not be returned and the resulting string may or may not be returned
        corrupted, depending on the current locale.
        Finally, they may just assume the string is using a specific encoding, usually UTF-8. This is the case of most functions in the intl extension and in the PCRE extension (in the last case, only when the u modifier is used). Although this is
        due to their special purpose, the function utf8_decode() assumes a UTF-8 encoding and the function utf8_encode() assumes an ISO-8859-1 encoding.
      </p>
      <p>
        Ultimately, this means writing correct programs using Unicode depends on carefully avoiding functions that will not work and that most likely will corrupt the data and using instead the functions that do behave correctly, generally from
        the
        intl and mbstring extensions. However, using functions that can handle Unicode encodings is just the beginning. No matter the functions the language provides, it is essential to know the Unicode specification. For instance, a program that
        assumes there is only uppercase and lowercase is making a wrong assumption.
      </p>
    </section>


    <section class="main-section" id="Arrays">
      <header>Arrays</header>
      <p>
        An array in PHP is actually an ordered map. A map is a type that associates values to keys. This type is optimized for several different uses; it can be treated as an array, list (vector), hash table (an implementation of a map), dictionary,
        collection, stack, queue, and probably more. As array values can be other arrays, trees and multidimensional arrays are also possible.
      </p>
      <p>
        Explanation of those data structures is beyond the scope of this manual, but at least one example is provided for each of them. For more information, look towards the considerable literature that exists about this broad topic.
      </p>
      <h2>
        Specifying with array() ¶
      </h2>
      <p>
        An array can be created using the array() language construct. It takes any number of comma-separated key => value pairs as arguments.
      </p>
      <code>
        array(<br>
        key => value,<br>
        key2 => value2,<br>
        key3 => value3,<br>
        ...<br>
        )<br>
      </code>
      <p>
        The comma after the last array element is optional and can be omitted. This is usually done for single-line arrays, i.e. array(1, 2) is preferred over array(1, 2, ). For multi-line arrays on the other hand the trailing comma is commonly
        used, as it allows easier addition of new elements at the end.
      </p>

      <p class="note-comment">
        As of PHP 5.4 you can also use the short array syntax, which replaces array() with [].
      </p>
      <p>
        Example #1 A simple array
      </p>
      <code>
        &lt;?php<br>
        $array = array(<br>
        "foo" => "bar",<br>
        "bar" => "foo",<br>
        );<br>

        // as of PHP 5.4<br>
        $array = [<br>
        "foo" => "bar",<br>
        "bar" => "foo",<br>
        ];<br>
        ?&gt;<br>
      </code>
      <p>
        The key can either be an integer or a string. The value can be of any type.
      </p>
      <p>
        Additionally the following key casts will occur:
      </p>
      <p>
        Strings containing valid decimal integers, unless the number is preceded by a + sign, will be cast to the integer type. E.g. the key "8" will actually be stored under 8. On the other hand "08" will not be cast, as it isn't a valid decimal
        integer.
        Floats are also cast to integers, which means that the fractional part will be truncated. E.g. the key 8.7 will actually be stored under 8.
        Bools are cast to integers, too, i.e. the key true will actually be stored under 1 and the key false under 0.
        Null will be cast to the empty string, i.e. the key null will actually be stored under "".
        Arrays and objects can not be used as keys. Doing so will result in a warning: Illegal offset type.
      </p>
      <p>
        If multiple elements in the array declaration use the same key, only the last one will be used as all others are overwritten.
      </p>
      <p>
        Example #2 Type Casting and Overwriting example
      </p>
      <code>
        &lt;?php<br>
        $array = array(<br>
        1 => "a",<br>
        "1" => "b",<br>
        1.5 => "c",<br>
        true => "d",<br>
        );<br>
        var_dump($array);<br>
        ?&gt;<br>
      </code>
      <p>
        The above example will output:
      </p>

      <code>
        array(1) {<br>
        [1]=><br>
        string(1) "d"<br>
        }<br>
      </code>
      <p>
        As all the keys in the above example are cast to 1, the value will be overwritten on every new element and the last assigned value "d" is the only one left over.
      </p>
      <p>
        PHP arrays can contain integer and string keys at the same time as PHP does not distinguish between indexed and associative arrays.
      </p>
      <p>
        Example #3 Mixed integer and string keys
      </p>
      <code>
        &lt;?php<br>
        $array = array(<br>
        "foo" => "bar",<br>
        "bar" => "foo",<br>
        100 => -100,<br>
        -100 => 100,<br>
        );<br>
        var_dump($array);<br>
        ?&gt;<br>
      </code>
      <p>
        The above example will output:
      </p>

      <code>
        array(4) {<br>
        ["foo"]=><br>
        string(3) "bar"<br>
        ["bar"]=><br>
        string(3) "foo"<br>
        [100]=><br>
        int(-100)<br>
        [-100]=><br>
        int(100)<br>
        }<br>
      </code>
      <p>
        The key is optional. If it is not specified, PHP will use the increment of the largest previously used integer key.
      </p>
      <p>
        Example #4 Indexed arrays without key
      </p>
      <code>
        &lt;?php<br>
        $array = array("foo", "bar", "hello", "world");<br>
        var_dump($array);<br>
        ?&gt;<br>
      </code>
      <p>
        The above example will output:
      </p>

      <code>
        array(4) {<br>
        [0]=><br>
        string(3) "foo"<br>
        [1]=><br>
        string(3) "bar"<br>
        [2]=><br>
        string(5) "hello"<br>
        [3]=><br>
        string(5) "world"<br>
        }<br>
      </code>
      <p>
        It is possible to specify the key only for some elements and leave it out for others:
      </p>
      <p>
        Example #5 Keys not on all elements
      </p>
      <code>&lt;?php<br>
        $array = array(<br>
        "a",<br>
        "b",<br>
        6 => "c",<br>
        "d",<br>
        );<br>
        var_dump($array);<br>
        ?&gt;<br>
      </code>
      <p>
        The above example will output:
      </p>

      <code>
        array(4) {<br>
        [0]=><br>
        string(1) "a"<br>
        [1]=><br>
        string(1) "b"<br>
        [6]=><br>
        string(1) "c"<br>
        [7]=><br>
        string(1) "d"<br>
        }<br>
      </code>
      <p>
        As you can see the last value "d" was assigned the key 7. This is because the largest integer key before that was 6.
      </p>
      <h2>
        Accessing array elements with square bracket syntax ¶
      </h2>
      <p>
        Array elements can be accessed using the array[key] syntax.
      </p>
      <p>
        Example #6 Accessing array elements
      </p>
      <code>
        &lt;?php<br>
        $array = array(<br>
        "foo" => "bar",<br>
        42 => 24,<br>
        "multi" => array(<br>
        "dimensional" => array(<br>
        "array" => "foo"<br>
        )<br>
        )<br>
        );<br>

        var_dump($array["foo"]);<br>
        var_dump($array[42]);<br>
        var_dump($array["multi"]["dimensional"]["array"]);<br>
        ?&gt;<br>
      </code>
      <p>
        The above example will output:
      </p>
      <code>
        string(3) "bar"<br>
        int(24)<br>
        string(3) "foo"<br>
      </code>
      <p class="note-comment">
        Note:

        Both square brackets and curly braces can be used interchangeably for accessing array elements (e.g. $array[42] and $array{42} will both do the same thing in the example above).
      </p>
      <p class="note-comment">
        As of PHP 5.4 it is possible to array dereference the result of a function or method call directly. Before it was only possible using a temporary variable.
      </p>
      <p class="note-comment">
        As of PHP 5.5 it is possible to array dereference an array literal.
      </p>
      <p>
        Example #7 Array dereferencing
      </p>
      <code>
        &lt;?php<br>
        function getArray() {<br>
        return array(1, 2, 3);<br>
        }<br>

        // on PHP 5.4<br>
        $secondElement = getArray()[1];<br>

        // previously<br>
        $tmp = getArray();<br>
        $secondElement = $tmp[1];<br>

        // or<br>
        list(, $secondElement) = getArray();<br>
        ?&gt;<br>
      </code>
      <p class="note-comment">
        Note:

        Attempting to access an array key which has not been defined is the same as accessing any other undefined variable: an E_NOTICE-level error message will be issued, and the result will be NULL.
      </p>
      <p class="note-comment">
        Note:

        Array dereferencing a scalar value which is not a string silently yields NULL, i.e. without issuing an error message.
      </p>
      <h2>
        Creating/modifying with square bracket syntax ¶
      </h2>
      <p>
        An existing array can be modified by explicitly setting values in it.
      </p>
      <p>
        This is done by assigning values to the array, specifying the key in brackets. The key can also be omitted, resulting in an empty pair of brackets ([]).
      </p>
      <code>
        $arr[key] = value;<br>
        $arr[] = value;<br>
        // key may be an integer or string<br>
        // value may be any value of any type<br>
      </code>
      <p>
        If $arr doesn't exist yet, it will be created, so this is also an alternative way to create an array. This practice is however discouraged because if $arr already contains some value (e.g. string from request variable) then this value will
        stay in the place and [] may actually stand for string access operator. It is always better to initialize a variable by a direct assignment.
      </p>

      <p class="note-comment">
        Note: As of PHP 7.1.0, applying the empty index operator on a string throws a fatal error. Formerly, the string was silently converted to an array.
      </p>
      <p>
        To change a certain value, assign a new value to that element using its key. To remove a key/value pair, call the unset() function on it.
      </p>
      <code>
        &lt;?php<br>
        $arr = array(5 => 1, 12 => 2);<br>

        $arr[] = 56; // This is the same as $arr[13] = 56;<br>
        // at this point of the script<br>

        $arr["x"] = 42; // This adds a new element to<br>
        // the array with key "x"<br>

        unset($arr[5]); // This removes the element from the array<br>

        unset($arr); // This deletes the whole array<br>
        ?&gt;<br>
      </code>
      <p class="note-comment">
        Note:

        As mentioned above, if no key is specified, the maximum of the existing integer indices is taken, and the new key will be that maximum value plus 1 (but at least 0). If no integer indices exist yet, the key will be 0 (zero).
      </p>
      <p>
        Note that the maximum integer key used for this need not currently exist in the array. It need only have existed in the array at some time since the last time the array was re-indexed. The following example illustrates:
      </p>
      <code>
        &lt;?php<br>
        // Create a simple array.<br>
        $array = array(1, 2, 3, 4, 5);<br>
        print_r($array);<br>

        // Now delete every item, but leave the array itself intact:<br>
        foreach ($array as $i => $value) {<br>
        unset($array[$i]);<br>
        }<br>
        print_r($array);<br>

        // Append an item (note that the new key is 5, instead of 0).<br>
        $array[] = 6;<br>
        print_r($array);<br>

        // Re-index:<br>
        $array = array_values($array);<br>
        $array[] = 7;<br>
        print_r($array);<br>
        ?&gt;<br>
      </code>
      <p>
        The above example will output:
      </p>
      <code>
        Array<br>
        (<br>
        [0] => 1<br>
        [1] => 2<br>
        [2] => 3<br>
        [3] => 4<br>
        [4] => 5<br>
        )<br>
        Array<br>
        (<br>
        )<br>
        Array<br>
        (<br>
        [5] => 6<br>
        )<br>
        Array<br>
        (<br>
        [0] => 6<br>
        [1] => 7<br>
        )<br>
      </code>
      <h2>
        Useful functions ¶
      </h2>
      <p>
        There are quite a few useful functions for working with arrays. See the array functions section.
      </p>
      <p class="note-comment">
        Note:

        The unset() function allows removing keys from an array. Be aware that the array will not be reindexed. If a true "remove and shift" behavior is desired, the array can be reindexed using the array_values() function.
      </p>

      <code>&lt;?php<br>
        $a = array(1 => 'one', 2 => 'two', 3 => 'three');<br>
        unset($a[2]);<br>
        /* will produce an array that would have been defined as<br>
        $a = array(1 => 'one', 3 => 'three');<br>
        and NOT<br>
        $a = array(1 => 'one', 2 =>'three');<br>
        */<br>

        $b = array_values($a);<br>
        // Now $b is array(0 => 'one', 1 =>'three')<br>
        ?&gt;<br>
      </code>

      <p>
        The foreach control structure exists specifically for arrays. It provides an easy way to traverse an array.
      </p>
      <h2>
        Array do's and don'ts ¶
      </h2>


      <p>
        Always use quotes around a string literal array index. For example, $foo['bar'] is correct, while $foo[bar] is not. But why? It is common to encounter this kind of syntax in old scripts:
      </p>
      <code>
        &lt;?php<br>
        $foo[bar] = 'enemy';<br>
        echo $foo[bar];<br>
        // etc<br>
        ?&gt;<br>
      </code>


      <p>
        This is wrong, but it works. The reason is that this code has an undefined constant (bar) rather than a string ('bar' - notice the quotes). It works because PHP automatically converts a bare string (an unquoted string which does not
        correspond to any known symbol) into a string which contains the bare string. For instance, if there is no defined constant named bar, then PHP will substitute in the string 'bar' and use that.
      </p>

      <div class="note-comment">
        <h3>
          Warning
        </h3>

        The fallback to treat an undefined constant as bare string is deprecated as of PHP 7.2.0, and issues an error of level E_WARNING. Formerly, an error of level E_NOTICE has been issued.
      </div>

      <p class="note-comment">
        Note: This does not mean to always quote the key. Do not quote keys which are constants or variables, as this will prevent PHP from interpreting them.
      </p>
      <code>
        &lt;?php<br>
        error_reporting(E_ALL);<br>
        ini_set('display_errors', true);<br>
        ini_set('html_errors', false);<br>
        // Simple array:<br>
        $array = array(1, 2);<br>
        $count = count($array);<br>
        for ($i = 0; $i &lt;$count; $i++) {<br>
        echo "\nChecking $i: \n";<br>
        echo "Bad: " . $array['$i'] . "\n";<br>
        echo "Good: " . $array[$i] . "\n";<br>
        echo "Bad: {$array['$i']}\n";<br>
        echo "Good: {$array[$i]}\n";<br>
        }<br>
        ?&gt;<br>
      </code>

      <code>
        The above example will output:<br>

        Checking 0:<br>
        Notice: Undefined index: $i in /path/to/script.html on line 9<br>
        Bad:<br>
        Good: 1<br>
        Notice: Undefined index: $i in /path/to/script.html on line 11<br>
        Bad:<br>
        Good: 1<br>

        Checking 1:<br>
        Notice: Undefined index: $i in /path/to/script.html on line 9<br>
        Bad:<br>
        Good: 2<br>
        Notice: Undefined index: $i in /path/to/script.html on line 11<br>
        Bad:<br>
        Good: 2<br>
      </code>
      <p>
        More examples to demonstrate this behaviour:
      </p>
      <code>
        &lt;?php<br>
        // Show all errors<br>
        error_reporting(E_ALL);<br>

        $arr = array('fruit' => 'apple', 'veggie' => 'carrot');<br>

        // Correct<br>
        print $arr['fruit']; // apple<br>
        print $arr['veggie']; // carrot<br>

        // Incorrect. This works but also throws a PHP error of level E_NOTICE because<br>
        // of an undefined constant named fruit<br>
        //<br>
        // Notice: Use of undefined constant fruit - assumed 'fruit' in...<br>
        print $arr[fruit]; // apple<br>

        // This defines a constant to demonstrate what's going on. The value 'veggie'<br>
        // is assigned to a constant named fruit.<br>
        define('fruit', 'veggie');<br>

        // Notice the difference now<br>
        print $arr['fruit']; // apple<br>
        print $arr[fruit]; // carrot<br>

        // The following is okay, as it's inside a string. Constants are not looked for<br>
        // within strings, so no E_NOTICE occurs here<br>
        print "Hello $arr[fruit]"; // Hello apple<br>

        // With one exception: braces surrounding arrays within strings allows constants<br>
        // to be interpreted<br>
        print "Hello {$arr[fruit]}"; // Hello carrot<br>
        print "Hello {$arr['fruit']}"; // Hello apple<br>

        // This will not work, and will result in a parse error, such as:<br>
        // Parse error: parse error, expecting T_STRING' or T_VARIABLE' or T_NUM_STRING'<br>
        // This of course applies to using superglobals in strings as well<br>
        print "Hello $arr['fruit']";<br>
        print "Hello $_GET['foo']";<br>

        // Concatenation is another option<br>
        print "Hello " . $arr['fruit']; // Hello apple<br>
        ?&gt;<br>
      </code>
      <p>
        When error_reporting is set to show E_NOTICE level errors (by setting it to E_ALL, for example), such uses will become immediately visible. By default, error_reporting is set not to show notices.
      </p>
      <p>
        As stated in the syntax section, what's inside the square brackets ('[' and ']') must be an expression. This means that code like this works:
      </p>
      <code>
        &lt;?php<br>
        echo $arr[somefunc($bar)];<br>
        ?&gt;<br>
      </code>
      <p>
        This is an example of using a function return value as the array index. PHP also knows about constants:
      </p>
      <code>
        &lt;?php<br>
        $error_descriptions[E_ERROR] = "A fatal error has occurred";<br>
        $error_descriptions[E_WARNING] = "PHP issued a warning";<br>
        $error_descriptions[E_NOTICE] = "This is just an informal notice";<br>
        ?&gt;<br>
      </code>
      <p>
        Note that E_ERROR is also a valid identifier, just like bar in the first example. But the last example is in fact the same as writing:
      </p>
      <code>
        &lt;?php<br>
        $error_descriptions[1] = "A fatal error has occurred";<br>
        $error_descriptions[2] = "PHP issued a warning";<br>
        $error_descriptions[8] = "This is just an informal notice";<br>
        ?&gt;<br>
      </code>
      <p>
        because E_ERROR equals 1, etc.
        So why is it bad then?
      </p>
      <p>
        At some point in the future, the PHP team might want to add another constant or keyword, or a constant in other code may interfere. For example, it is already wrong to use the words empty and default this way, since they are reserved
        keywords.
      </p>
      <p class="note-comment">
        Note: To reiterate, inside a double-quoted string, it's valid to not surround array indexes with quotes so "$foo[bar]" is valid. See the above examples for details on why as well as the section on variable parsing in strings.
      </p>
      <h2>
        Converting to array ¶
      </h2>
      <p>
        For any of the types integer, float, string, boolean and resource, converting a value to an array results in an array with a single element with index zero and the value of the scalar which was converted. In other words, (array)$scalarValue
        is exactly the same as array($scalarValue).
      </p>
      <p>
        If an object is converted to an array, the result is an array whose elements are the object's properties. The keys are the member variable names, with a few notable exceptions: integer properties are unaccessible; private variables have the
        class name prepended to the variable name; protected variables have a '*' prepended to the variable name. These prepended values have null bytes on either side. This can result in some unexpected behaviour:
      </p>
      <code>
        &lt;?php<br>

        class A {<br>
        private $A; // This will become '\0A\0A'<br>
        }<br>

        class B extends A {<br>
        private $A; // This will become '\0B\0A'<br>
        public $AA; // This will become 'AA'<br>
        }<br>

        var_dump((array) new B());<br>
        ?&gt;<br>
      </code>
      <p>
        The above will appear to have two keys named 'AA', although one of them is actually named '\0A\0A'.
      </p>
      <p>
        Converting NULL to an array results in an empty array.
      </p>
      <h2>
        Comparing ¶
      </h2>

      <p>
        It is possible to compare arrays with the array_diff() function and with array operators.
      </p>
      <h2>
        Examples ¶
      </h2>
      <p>
        The array type in PHP is very versatile. Here are some examples:
      </p>
      <code>
        &lt;?php<br>
        // This:<br>
        $a = array( 'color' => 'red',<br>
        'taste' => 'sweet',<br>
        'shape' => 'round',<br>
        'name' => 'apple',<br>
        4 // key will be 0<br>
        );<br>

        $b = array('a', 'b', 'c');<br>

        // . . .is completely equivalent with this:<br>
        $a = array();<br>
        $a['color'] = 'red';<br>
        $a['taste'] = 'sweet';<br>
        $a['shape'] = 'round';<br>
        $a['name'] = 'apple';<br>
        $a[] = 4; // key will be 0<br>

        $b = array();<br>
        $b[] = 'a';<br>
        $b[] = 'b';<br>
        $b[] = 'c';<br>

        // After the above code is executed, $a will be the array<br>
        // array('color' => 'red', 'taste' => 'sweet', 'shape' => 'round',<br>
        // array(0 => 'a', 1 => 'b', 2 => 'c'), or simply array('a', 'b', 'c').<br>
        // 'name' => 'apple', 0 => 4), and $b will be the array<br>
        ?&gt;<br>
      </code>
      <p>
        Example #8 Using array()
      </p>
      <code>
        &lt;?php<br>
        // Array as (property-)map<br>
        $map = array( 'version' => 4,<br>
        'OS' => 'Linux',<br>
        'lang' => 'english',<br>
        'short_tags' => true<br>
        );<br>

        // strictly numerical keys<br>
        $array = array( 7,<br>
        8,<br>
        0,<br>
        156,<br>
        -10<br>
        );<br>
        // this is the same as array(0 => 7, 1 => 8, ...)<br>

        $switching = array( 10, // key = 0<br>
        5 => 6,<br>
        3 => 7,<br>
        'a' => 4,<br>
        11, // key = 6 (maximum of integer-indices was 5)<br>
        '8' => 2, // key = 8 (integer!)<br>
        '02' => 77, // key = '02'<br>
        0 => 12 // the value 10 will be overwritten by 12<br>
        );<br>

        $empty = array();<br>
        // empty array<br>
        ?&gt;<br>
      </code>
      <p>
        Example #9 Collection
      </p>
      <code>
        &lt;?php<br>
        $colors = array('red', 'blue', 'green', 'yellow');<br>

        foreach ($colors as $color) {<br>
        echo "Do you like $color?\n";<br>
        }<br>

        ?&gt;<br>
      </code>
      <p>
        The above example will output:
      </p>
      <code>
        Do you like red?<br>
        Do you like blue?<br>
        Do you like green?<br>
        Do you like yellow?<br>
      </code>
      <p>
        Changing the values of the array directly is possible by passing them by reference.
      </p>
      <p>
        Example #10 Changing element in the loop
      </p>
      <code>
        &lt;?php<br>
        foreach ($colors as &$color) {<br>
        $color = strtoupper($color);<br>
        }<br>
        unset($color); /* ensure that following writes to<br>
        $color will not modify the last array element */<br>

        print_r($colors);<br>
        ?&gt;<br>
      </code>
      <p>
        The above example will output:
      </p>

      <code>
        Array<br>
        (<br>
        [0] => RED<br>
        [1] => BLUE<br>
        [2] => GREEN<br>
        [3] => YELLOW<br>
        )<br>
      </code>
      <p>
        This example creates a one-based array.
      </p>
      <p>
        Example #11 One-based index
      </p>
      <code>
        &lt;?php<br>
        $firstquarter = array(1 => 'January', 'February', 'March');<br>
        print_r($firstquarter);<br>
        ?&gt;<br>
      </code>
      <p>
        The above example will output:
      </p>
      <code>
        Array<br>
        (<br>
        [1] => 'January'<br>
        [2] => 'February'<br>
        [3] => 'March'<br>
        )<br>
      </code>
      <p>
        Example #12 Filling an array
      </p>
      <code>
        &lt;?php<br>
        // fill an array with all items from a directory<br>
        $handle = opendir('.');<br>
        while (false !== ($file = readdir($handle))) {<br>
        $files[] = $file;<br>
        }<br>
        closedir($handle);<br>
        ?&gt;<br>
      </code>
      <p>
        Arrays are ordered. The order can be changed using various sorting functions. See the array functions section for more information. The count() function can be used to count the number of items in an array.
      </p>
      <p>
        Example #13 Sorting an array
      </p>
      <code>
        &lt;?php<br>
        sort($files);<br>
        print_r($files);<br>
        ?&gt;<br>
      </code>
      <p>
        Because the value of an array can be anything, it can also be another array. This enables the creation of recursive and multi-dimensional arrays.
      </p>
      <p>
        Example #14 Recursive and multi-dimensional arrays
      </p>
      <code>
        &lt;?php<br>
        $fruits = array ( "fruits" => array ( "a" => "orange",<br>
        "b" => "banana",<br>
        "c" => "apple"<br>
        ),<br>
        "numbers" => array ( 1,<br>
        2,<br>
        3,<br>
        4,<br>
        5,<br>
        6<br>
        ),<br>
        "holes" => array ( "first",<br>
        5 => "second",<br>
        "third"<br>
        )<br>
        );<br>

        // Some examples to address values in the array above<br>
        echo $fruits["holes"][5]; // prints "second"<br>
        echo $fruits["fruits"]["a"]; // prints "orange"<br>
        unset($fruits["holes"][0]); // remove "first"<br>

        // Create a new multi-dimensional array<br>
        $juices["apple"]["green"] = "good";<br>
        ?&gt;<br>
      </code>
      <p>
        Array assignment always involves value copying. Use the reference operator to copy an array by reference.
      </p>
      <code>
        &lt;?php<br>
        $arr1 = array(2, 3);<br>
        $arr2 = $arr1;<br>
        $arr2[] = 4; // $arr2 is changed,<br>
        // $arr1 is still array(2, 3)<br>

        $arr3 = &$arr1;<br>
        $arr3[] = 4; // now $arr1 and $arr3 are the same<br>
        ?&gt;<br>
      </code>
    </section>


    <section class="main-section" id="Iterables">
      <header>Iterables</header>
      <p>
        Iterable is a pseudo-type introduced in PHP 7.1. It accepts any array or object implementing the Traversable interface. Both of these types are iterable using foreach and can be used with yield from within a generator.
      </p>
      <h2>
        Using Iterables ¶
      </h2>
      <p>
        Iterable can be used as a parameter type to indicate that a function requires a set of values, but does not care about the form of the value set since it will be used with foreach. If a value is not an array or instance of Traversable, a
        TypeError will be thrown.
      </p>
      <p>
        Example #1 Iterable parameter type example
      </p>
      <code>&lt;?php<br>

        function foo(iterable $iterable) {<br>
        foreach ($iterable as $value) {<br>
        // ...<br>
        }<br>
        }<br>

        ?&gt;<br>
      </code>
      <p>
        Parameters declared as iterable may use NULL or an array as a default value.
      </p>
      <p>
        Example #2 Iterable parameter default value example
      </p>
      <code>
        &lt;?php<br>

        function foo(iterable $iterable = []) {<br>
        // ...<br>
        }<br>

        ?&gt;<br>
      </code>
      <p>
        Iterable can also be used as a return type to indicate a function will return an iterable value. If the returned value is not an array or instance of Traversable, a TypeError will be thrown.
      </p>
      <p>
        Example #3 Iterable return type example
      </p>
      <code>
        &lt;?php<br>

        function bar(): iterable {<br>
        return [1, 2, 3];<br>
        }<br>

        ?&gt;<br>
      </code>
      <p>
        Functions declaring iterable as a return type may also be generators.
      </p>
      <p>
        Example #4 Iterable generator return type example
      </p>
      <code>&lt;?php<br>

        function gen(): iterable {<br>
        yield 1;<br>
        yield 2;<br>
        yield 3;<br>
        }<br>

        ?&gt;<br>
      </code>
      <h2>
        Iterable Type Variance ¶
      </h2>
      <p>
        Classes extending/implementing may broaden methods using array or Traversable as parameter types to iterable or narrow return types from iterable to array or Traversable.
      </p>
      <p>
        Example #5 Iterable type variance example
      </p>
      <code>
        &lt;?php<br>
        interface Example {<br>
        public function method(array $array): iterable;<br>
        }<br>
        class ExampleImplementation implements Example {<br>
        public function method(iterable $iterable): array {<br>
        // Parameter broadened and return type narrowed.<br>
        }<br>
        }<br>
        ?&gt;<br>
      </code>
    </section>


    <section class="main-section" id="Objects">
      <header>Objects</header>
      <p>
        To create a new object, use the new statement to instantiate a class:
      </p>
      <code>
        &lt;?php<br>
        class foo<br>
        {<br>
        function do_foo()<br>
        {<br>
        echo "Doing foo.";<br>
        }<br>
        }<br>
        $bar = new foo;<br>
        $bar-&gt;do_foo();<br>
        ?&gt;<br>
      </code>
      <h2>
        Converting to object ¶
      </h2>
      <p>
        If an object is converted to an object, it is not modified. If a value of any other type is converted to an object, a new instance of the stdClass built-in class is created. If the value was NULL, the new instance will be empty. An array
        converts to an object with properties named by keys and corresponding values. Note that in this case before PHP 7.2.0 numeric keys have been inaccessible unless iterated.
      </p>
      <code>&lt;?php<br>
        $obj = (object) array('1' => 'foo');<br>
        var_dump(isset($obj-&gt;{'1'})); // outputs 'bool(true)' as of PHP 7.2.0; 'bool(false)' previously<br>
        var_dump(key($obj)); // outputs 'string(1) "1"' as of PHP 7.2.0; 'int(1)' previously<br>
        ?&gt;<br>
      </code>
      <p>
        For any other value, a member variable named scalar will contain the value.
      </p>
      <code>
        &lt;?php<br>
        $obj = (object) 'ciao';<br>
        echo $obj-&gt;scalar; // outputs 'ciao'<br>
        ?&gt;<br>
      </code>
    </section>


    <section class="main-section" id="Resources">
      <header>Resources</header>
      <p>
        A resource is a special variable, holding a reference to an external resource. Resources are created and used by special functions. See the appendix for a listing of all these functions and the corresponding resource types.
      </p>
      <h2>
        Converting to resource ¶
      </h2>
      <p>
        As resource variables hold special handles to opened files, database connections, image canvas areas and the like, converting to a resource makes no sense.
      </p>
      <h2>
        Freeing resources ¶
      </h2>
      <p>
        Thanks to the reference-counting system being part of Zend Engine, a resource with no more references to it is detected automatically, and it is freed by the garbage collector. For this reason, it is rarely necessary to free the memory
        manually.
      </p>
      <p class="note-comment">
        Note: Persistent database links are an exception to this rule. They are not destroyed by the garbage collector. See the persistent connections section for more information.
      </p>
    </section>


    <section class="main-section" id="NULL">
      <header>NULL</header>
      <p>
        The special NULL value represents a variable with no value. NULL is the only possible value of type null.
      </p>
      <p>
        A variable is considered to be null if:
      </p>
      <p>
        it has been assigned the constant NULL.
      </p>
      <p>
        it has not been set to any value yet.
      </p>
      <p>
        it has been unset().
      </p>
      <h2>
        Syntax ¶
      </h2>
      <p>
        There is only one value of type null, and that is the case-insensitive constant NULL.
      </p>
      <code>
        &lt;?php<br>
        $var = NULL;<br>
        ?&gt;<br>
      </code>
      <p>
        See also the functions is_null() and unset().
      </p>
      <h2>
        Casting to NULL ¶
      </h2>
      <div class="note-comment">
        <h3>
          Warning
        </h3>
        This feature has been DEPRECATED as of PHP 7.2.0. Relying on this feature is highly discouraged.
      </div>
      Casting a variable to null using (unset) $var will not remove the variable or unset its value. It will only return a NULL value.
    </section>


    <section class="main-section" id="Callbacks_/_Callables">
      <header>Callbacks / Callables</header>

      <p>
        Callbacks can be denoted by callable type hint as of PHP 5.4. This documentation used callback type information for the same purpose.
      </p>
      <p>
        Some functions like call_user_func() or usort() accept user-defined callback functions as a parameter. Callback functions can not only be simple functions, but also object methods, including static class methods.
      </p>
      <h2>
        Passing ¶
      </h2>
      <p>
        A PHP function is passed by its name as a string. Any built-in or user-defined function can be used, except language constructs such as: array(), echo, empty(), eval(), exit(), isset(), list(), print or unset().
      </p>
      <p>
        A method of an instantiated object is passed as an array containing an object at index 0 and the method name at index 1. Accessing protected and private methods from within a class is allowed.
      </p>
      <p>
        Static class methods can also be passed without instantiating an object of that class by passing the class name instead of an object at index 0. As of PHP 5.2.3, it is also possible to pass 'ClassName::methodName'.
      </p>
      <p>
        Apart from common user-defined function, anonymous functions can also be passed to a callback parameter.
      </p>
      <p>
        Example #1 Callback function examples
      </p>
      <code>
        &lt;?php<br>

        // An example callback function<br>
        function my_callback_function() {<br>
        echo 'hello world!';<br>
        }<br>

        // An example callback method<br>
        class MyClass {<br>
        static function myCallbackMethod() {<br>
        echo 'Hello World!';<br>
        }<br>
        }<br>

        // Type 1: Simple callback<br>
        call_user_func('my_callback_function');<br>

        // Type 2: Static class method call<br>
        call_user_func(array('MyClass', 'myCallbackMethod'));<br>

        // Type 3: Object method call<br>
        $obj = new MyClass();<br>
        call_user_func(array($obj, 'myCallbackMethod'));<br>

        // Type 4: Static class method call (As of PHP 5.2.3)<br>
        call_user_func('MyClass::myCallbackMethod');<br>

        // Type 5: Relative static class method call (As of PHP 5.3.0)<br>
        class A {<br>
        public static function who() {<br>
        echo "A\n";<br>
        }<br>
        }<br>

        class B extends A {<br>
        public static function who() {<br>
        echo "B\n";<br>
        }<br>
        }<br>

        call_user_func(array('B', 'parent::who')); // A<br>

        // Type 6: Objects implementing __invoke can be used as callables (since PHP 5.3)<br>
        class C {<br>
        public function __invoke($name) {<br>
        echo 'Hello ', $name, "\n";<br>
        }<br>
        }<br>

        $c = new C();<br>
        call_user_func($c, 'PHP!');<br>
        ?&gt;<br>
      </code>
      <p>
        Example #2 Callback example using a Closure
      </p>
      <code>&lt;?php<br>
        // Our closure<br>
        $double = function($a) {<br>
        return $a * 2;<br>
        };<br>

        // This is our range of numbers<br>
        $numbers = range(1, 5);<br>

        // Use the closure as a callback here to<br>
        // double the size of each element in our<br>
        // range<br>
        $new_numbers = array_map($double, $numbers);<br>

        print implode(' ', $new_numbers);<br>
        ?&gt;<br>
      </code>
      <p>
        The above example will output:
      </p>
      <code>
        2 4 6 8 10
      </code>

      <p class="note-comment">
        Note:

        Callbacks registered with functions such as call_user_func() and call_user_func_array() will not be called if there is an uncaught exception thrown in a previous callback.
      </p>

    </section>


    <section class="main-section" id="Pseudo-types_and_variables_used_in_this_documentation">
      <header>Pseudo-types and variables used in this documentation</header>

      <p>
        Pseudo-types are keywords used in the PHP documentation to specify the types or values an argument can have. Please note that they are not primitives of the PHP language. So you cannot use pseudo-types as typehints in your own custom
        functions.
        mixed
      </p>
      <p>
        mixed indicates that a parameter may accept multiple (but not necessarily all) types.
      </p>
      <p>
        gettype() for example will accept all PHP types, while str_replace() will accept strings and arrays.
        number
      </p>
      <p>
        number indicates that a parameter can be either integer or float.
        callback
      </p>
      <p>
        callback pseudo-types was used in this documentation before callable type hint was introduced by PHP 5.4. It means exactly the same.
        array|object
      </p>
      <p>
        array|object indicates that a parameter can be either array or object.
        void
      </p>
      <p>
        void as a return type means that the return value is useless. void in a parameter list means that the function doesn't accept any parameters. As of PHP 7.1 void is accepted as a function return type hint.
        ...
      </p>
      <p>
        $... in function prototypes means and so on. This variable name is used when a function can take an endless number of arguments.
      </p>
    </section>


    <section class="main-section" id="Type_Juggling">
      <header>Type Juggling</header>
      <p>
        PHP does not require (or support) explicit type definition in variable declaration; a variable's type is determined by the context in which the variable is used. That is to say, if a string value is assigned to variable $var, $var becomes a
        string. If an integer value is then assigned to $var, it becomes an integer.
      </p>
      <p>
        An example of PHP's automatic type conversion is the multiplication operator '*'. If either operand is a float, then both operands are evaluated as floats, and the result will be a float. Otherwise, the operands will be interpreted as
        integers, and the result will also be an integer. Note that this does not change the types of the operands themselves; the only change is in how the operands are evaluated and what the type of the expression itself is.
      </p>
      <code>
        &lt;?php<br>
        $foo = "1"; // $foo is string (ASCII 49)<br>
        $foo *= 2; // $foo is now an integer (2)<br>
        $foo = $foo * 1.3; // $foo is now a float (2.6)<br>
        $foo = 5 * "10 Little Piggies"; // $foo is integer (50)<br>
        $foo = 5 * "10 Small Pigs"; // $foo is integer (50)<br>
        ?&gt;<br>
      </code>
      <p>
        If the last two examples above seem odd, see String conversion to numbers.
      </p>
      <p>
        To force a variable to be evaluated as a certain type, see the section on Type casting. To change the type of a variable, see the settype() function.
      </p>
      <p>
        To test any of the examples in this section, use the var_dump() function.
      </p>
      <p class="note-comment">
        Note:

        The behaviour of an automatic conversion to array is currently undefined.
      </p>
      <p>
        Also, because PHP supports indexing into strings via offsets using the same syntax as array indexing, the following example holds true for all PHP versions:
      </p>
      <code>
        &lt;?php<br>
        $a = 'car'; // $a is a string<br>
        $a[0] = 'b'; // $a is still a string<br>
        echo $a; // bar<br>
        ?&gt;<br>
      </code>
      <h2>
        Type Casting ¶
      </h2>
      <p>
        Type casting in PHP works much as it does in C: the name of the desired type is written in parentheses before the variable which is to be cast.
      </p>
      <code>
        &lt;?php<br>
        $foo = 10; // $foo is an integer<br>
        $bar = (boolean) $foo; // $bar is a boolean<br>
        ?&gt;<br>
      </code>
      <p>
        The casts allowed are:
      </p>
      <ul>
        <li>
          (int), (integer) - cast to integer
        </li>
        <li>
          (bool), (boolean) - cast to boolean
        </li>
        <li>
          (float), (double), (real) - cast to float
        </li>
        <li>
          (string) - cast to string
        </li>
        <li>
          (array) - cast to array
        </li>
        <li>
          (object) - cast to object
        </li>
        <li>
          (unset) - cast to NULL
        </li>

        <li>
          (binary) casting and b prefix forward support was added in PHP 5.2.1. Note that the (binary) cast is essential the same as (string), but it should not be relied upon.
        </li>
      </ul>
      <p>
        The (unset) cast has been deprecated as of PHP 7.2.0. Note that the (unset) cast is the same as assigning the value NULL to the variable or call. The (unset) cast will be removed as of PHP 8.0.0.
      </p>
      <p class="note-comment">
        Note that tabs and spaces are allowed inside the parentheses, so the following are functionally equivalent:
      </p>
      <code>
        &lt;?php<br>
        $foo = (int) $bar;<br>
        $foo = ( int ) $bar;<br>
        ?&gt;<br>
      </code>
      <p>
        Casting literal strings and variables to binary strings:
      </p>
      <code>
        &lt;?php <br>
        $binary = (binary) $string; <br>
        $binary = b"binary string"; <br>
        ?&gt; <br>
      </code>
      <p class="note-comment">
        Note: Instead of casting a variable to a string, it is also possible to enclose the variable in double quotes.
      </p>
      <code>
        &lt;?php<br>
        $foo = 10; // $foo is an integer<br>
        $str = "$foo"; // $str is a string<br>
        $fst = (string) $foo; // $fst is also a string<br>

        // This prints out that "they are the same"<br>
        if ($fst === $str) {<br>
        echo "they are the same";<br>
        }<br>
        ?&gt;<br>
      </code>
    </section>




    <h1 id="Variables"> Variables </h1>
    <section class="main-section" id="Variable_Basics">
      <header>Variable Basics</header>
      <p>
        Variables in PHP are represented by a dollar sign followed by the name of the variable. The variable name is case-sensitive.
      </p>
      <p>
        Variable names follow the same rules as other labels in PHP. A valid variable name starts with a letter or underscore, followed by any number of letters, numbers, or underscores. As a regular expression, it would be expressed thus:
        [a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*
      </p>
      <p class="note-comment">
        Note: For our purposes here, a letter is a-z, A-Z, and the bytes from 127 through 255 (0x7f-0xff).
      </p>
      <p class="note-comment">
        Note: $this is a special variable that can't be assigned.
      </p>
      <p class="note-comment">
        Tip

        See also the Userland Naming Guide.
      </p>
      <p>
        For information on variable related functions, see the Variable Functions Reference.
      </p>
      <code>
        &lt;?php<br>
        $var = 'Bob';<br>
        $Var = 'Joe';<br>
        echo "$var, $Var"; // outputs "Bob, Joe"<br>

        $4site = 'not yet'; // invalid; starts with a number<br>
        $_4site = 'not yet'; // valid; starts with an underscore<br>
        $täyte = 'mansikka'; // valid; 'ä' is (Extended) ASCII 228.<br>
        ?&gt;<br>
      </code>
      <p>
        By default, variables are always assigned by value. That is to say, when you assign an expression to a variable, the entire value of the original expression is copied into the destination variable. This means, for instance, that after
        assigning one variable's value to another, changing one of those variables will have no effect on the other. For more information on this kind of assignment, see the chapter on Expressions.
      </p>
      <p>
        PHP also offers another way to assign values to variables: assign by reference. This means that the new variable simply references (in other words, "becomes an alias for" or "points to") the original variable. Changes to the new variable
        affect the original, and vice versa.
      </p>
      <p>
        To assign by reference, simply prepend an ampersand (&amp;) to the beginning of the variable which is being assigned (the source variable). For instance, the following code snippet outputs 'My name is Bob' twice:
      </p>
      <code>
        &lt;?php<br>
        $foo = 'Bob'; // Assign the value 'Bob' to $foo<br>
        $bar = &amp;$foo; // Reference $foo via $bar.<br>
        $bar = "My name is $bar"; // Alter $bar...<br>
        echo $bar;<br>
        echo $foo; // $foo is altered too.<br>
        ?&gt;<br>
      </code>
      <p>
        One important thing to note is that only named variables may be assigned by reference.
      </p>
      <code>
        &lt;?php<br>
        $foo = 25;<br>
        $bar = &amp;$foo; // This is a valid assignment.<br>
        $bar = &amp;(24 * 7); // Invalid; references an unnamed expression.<br>

        function test()<br>
        {<br>
        return 25;<br>
        }<br>

        $bar = &test(); // Invalid.<br>
        ?&gt;<br>
      </code>
      <p>
        It is not necessary to initialize variables in PHP however it is a very good practice. Uninitialized variables have a default value of their type depending on the context in which they are used - booleans default to FALSE, integers and
        floats default to zero, strings (e.g. used in echo) are set as an empty string and arrays become to an empty array.
      </p>
      <p>
        Example #1 Default values of uninitialized variables
      </p>
      <code>&lt;?php<br>
        // Unset AND unreferenced (no use context) variable; outputs NULL<br>
        var_dump($unset_var);<br>

        // Boolean usage; outputs 'false' (See ternary operators for more on this syntax)<br>
        echo($unset_bool ? "true\n" : "false\n");<br>

        // String usage; outputs 'string(3) "abc"'<br>
        $unset_str .= 'abc';<br>
        var_dump($unset_str);<br>

        // Integer usage; outputs 'int(25)'<br>
        $unset_int += 25; // 0 + 25 => 25<br>
        var_dump($unset_int);<br>

        // Float/double usage; outputs 'float(1.25)'<br>
        $unset_float += 1.25;<br>
        var_dump($unset_float);<br>

        // Array usage; outputs array(1) { [3]=> string(3) "def" }<br>
        $unset_arr[3] = "def"; // array() + array(3 => "def") => array(3 => "def")<br>
        var_dump($unset_arr);<br>

        // Object usage; creates new stdClass object (see http://www.php.net/manual/en/reserved.classes.php)<br>
        // Outputs: object(stdClass)#1 (1) { ["foo"]=> string(3) "bar" }<br>
        $unset_obj-&gt;foo = 'bar';<br>
        var_dump($unset_obj);<br>
        ?&gt;<br>
      </code>
      <p>
        Relying on the default value of an uninitialized variable is problematic in the case of including one file into another which uses the same variable name. It is also a major security risk with register_globals turned on. E_NOTICE level error
        is issued in case of working with uninitialized variables, however not in the case of appending elements to the uninitialized array. isset() language construct can be used to detect if a variable has been already initialized.
      </p>
    </section>


    <section class="main-section" id="Predefined_Variable">
      <header>Predefined Variable</header>
      <p>
        PHP provides a large number of predefined variables to any script which it runs. Many of these variables, however, cannot be fully documented as they are dependent upon which server is running, the version and setup of the server, and other
        factors. Some of these variables will not be available when PHP is run on the command line. For a listing of these variables, please see the section on Reserved Predefined Variables.
      </p>
      <div class="note-comment">
        <h3>
          Warning
        </h3>
        In PHP 4.2.0 and later, the default value for the PHP directive register_globals is off. This is a major change in PHP. Having register_globals off affects the set of predefined variables available in the global scope. For example, to get
        DOCUMENT_ROOT you'll use $_SERVER['DOCUMENT_ROOT'] instead of $DOCUMENT_ROOT, or $_GET['id'] from the URL http://www.example.com/test.php?id=3 instead of $id, or $_ENV['HOME'] instead of $HOME.
      </div>
      <p>
        For related information on this change, read the configuration entry for register_globals, the security chapter on Using Register Globals , as well as the PHP » 4.1.0 and » 4.2.0 Release Announcements.
      </p>
      <p>
        Using the available PHP Reserved Predefined Variables, like the superglobal arrays, is preferred.
      </p>
      <p>
        From version 4.1.0 onward, PHP provides an additional set of predefined arrays containing variables from the web server (if applicable), the environment, and user input. These new arrays are rather special in that they are automatically
        global--i.e., automatically available in every scope. For this reason, they are often known as "superglobals". (There is no mechanism in PHP for user-defined superglobals.) The superglobals are listed below; however, for a listing of their
        contents and further discussion on PHP predefined variables and their natures, please see the section Reserved Predefined Variables. Also, you'll notice how the older predefined variables ($HTTP_*_VARS) still exist. As of PHP 5.0.0, the long
        PHP predefined variable arrays may be disabled with the register_long_arrays directive.
      </p>
      <p class="note-comment">
        Note: Variable variables
        Superglobals cannot be used as variable variables inside functions or class methods.
      </p>
      <p class="note-comment">
        Note:
        Even though both the superglobal and HTTP_*_VARS can exist at the same time; they are not identical, so modifying one will not change the other.
      </p>
      <p>
        If certain variables in variables_order are not set, their appropriate PHP predefined arrays are also left empty.
      </p>
    </section>


    <section class="main-section" id="Variable_scope">
      <header>Variable scope</header>
      <p>
        The scope of a variable is the context within which it is defined. For the most part all PHP variables only have a single scope. This single scope spans included and required files as well. For example:
      </p>
      <code>
        &lt;?php<br>
        $a = 1;<br>
        include 'b.inc';<br>
        ?&gt;<br>
      </code>
      <p>
        Here the $a variable will be available within the included b.inc script. However, within user-defined functions a local function scope is introduced. Any variable used inside a function is by default limited to the local function scope. For
        example:
      </p>
      <code>
        &lt;?php<br>
        $a = 1; /* global scope */<br>

        function test()<br>
        {<br>
        echo $a; /* reference to local scope variable */<br>
        }<br>

        test();<br>
        ?&gt;<br>
      </code>
      <p>
        This script will not produce any output because the echo statement refers to a local version of the $a variable, and it has not been assigned a value within this scope. You may notice that this is a little bit different from the C language
        in that global variables in C are automatically available to functions unless specifically overridden by a local definition. This can cause some problems in that people may inadvertently change a global variable. In PHP global variables must
        be declared global inside a function if they are going to be used in that function.
      </p>
      <h2>
        The global keyword ¶
      </h2>
      <p>
        First, an example use of global:
      </p>
      <p>
        Example #1 Using global
      </p>
      <code>
        &lt;?php<br>
        $a = 1;<br>
        $b = 2;<br>

        function Sum()<br>
        {<br>
        global $a, $b;<br>

        $b = $a + $b;<br>
        }<br>

        Sum();<br>
        echo $b;<br>
        ?&gt;<br>
      </code>
      <p>
        The above script will output 3. By declaring $a and $b global within the function, all references to either variable will refer to the global version. There is no limit to the number of global variables that can be manipulated by a function.
      </p>
      <p>
        A second way to access variables from the global scope is to use the special PHP-defined $GLOBALS array. The previous example can be rewritten as:
      </p>
      <p>
        Example #2 Using $GLOBALS instead of global
      </p>
      <code>
        &lt;?php<br>
        $a = 1;<br>
        $b = 2;<br>

        function Sum()<br>
        {<br>
        $GLOBALS['b'] = $GLOBALS['a'] + $GLOBALS['b'];<br>
        }<br>

        Sum();<br>
        echo $b;<br>
        ?&gt;<br>
      </code>
      <p>
        The $GLOBALS array is an associative array with the name of the global variable being the key and the contents of that variable being the value of the array element. Notice how $GLOBALS exists in any scope, this is because $GLOBALS is a
        superglobal. Here's an example demonstrating the power of superglobals:
      </p>
      <p>
        Example #3 Example demonstrating superglobals and scope
      </p>
      <code>
        &lt;?php<br>
        function test_global()<br>
        {<br>
        // Most predefined variables aren't "super" and require<br>
        // 'global' to be available to the functions local scope.<br>
        global $HTTP_POST_VARS;<br>

        echo $HTTP_POST_VARS['name'];<br>

        // Superglobals are available in any scope and do<br>
        // not require 'global'. Superglobals are available<br>
        // as of PHP 4.1.0, and HTTP_POST_VARS is now<br>
        // deemed deprecated.<br>
        echo $_POST['name'];<br>
        }<br>
        ?&gt;<br>
      </code>
      <p class="note-comment">
        Note:
        Using global keyword outside a function is not an error. It can be used if the file is included from inside a function.
      </p>
      <h2>
        Using static variables ¶
      </h2>
      <p>
        Another important feature of variable scoping is the static variable. A static variable exists only in a local function scope, but it does not lose its value when program execution leaves this scope. Consider the following example:
      </p>
      <p>
        Example #4 Example demonstrating need for static variables
      </p>
      <code>&lt;?php<br>
        function test()<br>
        {<br>
        $a = 0;<br>
        echo $a;<br>
        $a++;<br>
        }<br>
        ?&gt;<br>
      </code>
      <p>
        This function is quite useless since every time it is called it sets $a to 0 and prints 0. The $a++ which increments the variable serves no purpose since as soon as the function exits the $a variable disappears. To make a useful counting
        function which will not lose track of the current count, the $a variable is declared static:
      </p>
      <p>
        Example #5 Example use of static variables
      </p>
      <code>
        &lt;?php<br>
        function test()<br>
        {<br>
        static $a = 0;<br>
        echo $a;<br>
        $a++;<br>
        }<br>
        ?&gt;<br>
      </code>
      <p>
        Now, $a is initialized only in first call of function and every time the test() function is called it will print the value of $a and increment it.
      </p>
      <p>
        Static variables also provide one way to deal with recursive functions. A recursive function is one which calls itself. Care must be taken when writing a recursive function because it is possible to make it recurse indefinitely. You must
        make sure you have an adequate way of terminating the recursion. The following simple function recursively counts to 10, using the static variable $count to know when to stop:
      </p>
      <p>
        Example #6 Static variables with recursive functions
      </p>
      <code>
        &lt;?php<br>
        function test()<br>
        {<br>
        static $count = 0;<br>

        $count++;<br>
        echo $count;<br>
        if ($count &lt; 10) {<br>
        test();<br>
        }<br>
        $count--;<br>
        }<br>
        ?&gt;<br>
      </code>
      <p class="note-comment">
        Note:
        Static variables may be declared as seen in the examples above. From PHP 5.6 you can assign values to these variables which are the result of expressions, but you can't use any function here, what will cause a parse error.
      </p>
      <p>
        Example #7 Declaring static variables
      </p>
      <code>
        &lt;?php <br>
        function foo(){ <br>
        static $int = 0; // correct <br>
        static $int = 1+2; // correct (as of PHP 5.6) <br>
        static $int = sqrt(121); // wrong (as it is a function) <br>

        $int++; <br>
        echo $int; <br>
        } <br>
        ?&gt; <br>
      </code>
      <p class="note-comment">
        Note:
        Static declarations are resolved in compile-time.
      </p>
      <h2>
        References with global and static variables ¶
      </h2>
      <p>
        The Zend Engine 1, driving PHP 4, implements the static and global modifier for variables in terms of references. For example, a true global variable imported inside a function scope with the global statement actually creates a reference to
        the global variable. This can lead to unexpected behaviour which the following example addresses:
      </p>
      <code>
        &lt;?php <br>
        function test_global_ref() { <br>
        global $obj; <br>
        $obj = &new stdclass; <br>
        } <br>

        function test_global_noref() { <br>
        global $obj; <br>
        $obj = new stdclass; <br>
        } <br>

        test_global_ref(); <br>
        var_dump($obj); <br>
        test_global_noref(); <br>
        var_dump($obj); <br>
        ?&gt; <br>
      </code>
      <p>
        The above example will output:
      </p>
      <code>
        NULL<br>
        object(stdClass)(0) {<br>
        }<br>
      </code>
      <p>
        A similar behaviour applies to the static statement. References are not stored statically:
      </p>
      <code>
        &lt;?php<br>
        function &get_instance_ref() {<br>
        static $obj;<br>

        echo 'Static object: ';<br>
        var_dump($obj);<br>
        if (!isset($obj)) {<br>
        // Assign a reference to the static variable<br>
        $obj = &new stdclass;<br>
        }<br>
        $obj-&gt;property++;<br>
        return $obj;<br>
        }<br>

        function &get_instance_noref() {<br>
        static $obj;<br>

        echo 'Static object: ';<br>
        var_dump($obj);<br>
        if (!isset($obj)) {<br>
        // Assign the object to the static variable<br>
        $obj = new stdclass;<br>
        }<br>
        $obj-&gt;property++;<br>
        return $obj;<br>
        }<br>

        $obj1 = get_instance_ref();<br>
        $still_obj1 = get_instance_ref();<br>
        echo "\n";<br>
        $obj2 = get_instance_noref();<br>
        $still_obj2 = get_instance_noref();<br>
        ?&gt;<br>
      </code>
      <p>
        The above example will output:
      </p>

      <code>
        Static object: NULL<br>
        Static object: NULL<br>

        Static object: NULL<br>
        Static object: object(stdClass)(1) {<br>
        ["property"]=><br>
        int(1)<br>
        }<br>
      </code>
      <p>
        This example demonstrates that when assigning a reference to a static variable, it's not remembered when you call the &get_instance_ref() function a second time.
      </p>
    </section>


    <section class="main-section" id="Variable_variables">
      <header>Variable variables</header>
      <p>
        Sometimes it is convenient to be able to have variable variable names. That is, a variable name which can be set and used dynamically. A normal variable is set with a statement such as:
      </p>
      <code>
        &lt;?php<br>
        $a = 'hello';<br>
        ?&gt;<br>
      </code>
      <p>
        A variable variable takes the value of a variable and treats that as the name of a variable. In the above example, hello, can be used as the name of a variable by using two dollar signs. i.e.
      </p>
      <code>
        &lt;?php<br>
        $$a = 'world';<br>
        ?&gt;<br>
      </code>
      <p>
        At this point two variables have been defined and stored in the PHP symbol tree: $a with contents "hello" and $hello with contents "world". Therefore, this statement:
      </p>
      <code>
        &lt;?php<br>
        echo "$a ${$a}";<br>
        ?&gt;<br>
      </code>
      <p>
        produces the exact same output as:
      </p>
      <code>
        &lt;?php<br>
        echo "$a $hello";<br>
        ?&gt;<br>
      </code>
      <p>
        i.e. they both produce: hello world.
      </p>
      <p>
        In order to use variable variables with arrays, you have to resolve an ambiguity problem. That is, if you write $$a[1] then the parser needs to know if you meant to use $a[1] as a variable, or if you wanted $$a as the variable and then the
        [1] index from that variable. The syntax for resolving this ambiguity is: ${$a[1]} for the first case and ${$a}[1] for the second.
      </p>
      <p>
        Class properties may also be accessed using variable property names. The variable property name will be resolved within the scope from which the call is made. For instance, if you have an expression such as $foo-&gt;$bar, then the local
        scope
        will be examined for $bar and its value will be used as the name of the property of $foo. This is also true if $bar is an array access.
      </p>
      <div class="note-comment">
        <h3>
          Caution
        </h3>
        Further dereferencing a variable property that is an array has different semantics between PHP 5 and PHP 7. The PHP 7.0 migration guide includes further details on the types of expressions that have changed, and how to place curly braces to
        avoid ambiguity.
      </div>
      <p>
        Curly braces may also be used, to clearly delimit the property name. They are most useful when accessing values within a property that contains an array, when the property name is made of mulitple parts, or when the property name contains
        characters that are not otherwise valid (e.g. from json_decode() or SimpleXML).
      </p>
      <p>
        Example #1 Variable property example
      </p>
      <code>
        &lt;?php<br>
        class foo {<br>
        var $bar = 'I am bar.';<br>
        var $arr = array('I am A.', 'I am B.', 'I am C.');<br>
        var $r = 'I am r.';<br>
        }<br>

        $foo = new foo();<br>
        $bar = 'bar';<br>
        $baz = array('foo', 'bar', 'baz', 'quux');<br>
        echo $foo-&gt;$bar . "\n";<br>
        echo $foo-&gt;{$baz[1]} . "\n";<br>

        $start = 'b';<br>
        $end = 'ar';<br>
        echo $foo-&gt;{$start . $end} . "\n";<br>

        $arr = 'arr';<br>
        echo $foo-&gt;{$arr[1]} . "\n";<br>

        ?&gt;<br>
      </code>
      <p>
        The above example will output:
      </p>
      <code>
        I am bar.
        I am bar.
        I am bar.
        I am r.
      </code>
    </section>


    <section class="main-section" id="Variables_From_External_Sources">
      <header>Variables From External Sources</header>
      <p>
        When a form is submitted to a PHP script, the information from that form is automatically made available to the script. There are few ways to access this information, for example:
      </p>
      <p>
        Example #1 A simple HTML form
      </p>
      <code>
        &lt;form action="foo.php" method="post"&gt;<br />
        Name: &lt;input type="text" name="username" /&gt;&lt;br /&gt;<br />
        Email: &lt;input type="text" name="email" /&gt;&lt;br /&gt;<br />
        &lt;input type="submit" name="submit" value="Submit me!" /&gt;<br />
        &lt;/form&gt;
      </code>
      <p>
        As of PHP 5.4.0, there are only two ways to access data from your HTML forms. Currently available methods are listed below:
      </p>
      <p>
        Example #2 Accessing data from a simple POST HTML form
      </p>
      <code>
        &lt;?php <br>
        echo $_POST['username']; <br>
        echo $_REQUEST['username']; <br>
        ?&gt; <br>
      </code>
      <p>
        There were some other ways of accessing user input in old PHP versions. These are listed below. See changelog at the bottom of the page for more details.
      </p>
      <p>
        Example #3 Old methods of accessing user input
      </p>
      <code>
        &lt;?php<br>
        // WATCH OUT: these methods ARE NOT supported anymore.<br>
        // Valid ones were described above.<br>

        // Using import_request_variables() - this function has been removed in PHP 5.4.0<br>
        import_request_variables('p', 'p_');<br>
        echo $p_username;<br>

        // These long predefined variables were removed in PHP 5.4.0<br>
        echo $HTTP_POST_VARS['username'];<br>

        // Using register_globals. This feature was removed in PHP 5.4.0<br>
        echo $username;<br>
        ?&gt;<br>
      </code>
      <p>
        Using a GET form is similar except you'll use the appropriate GET predefined variable instead. GET also applies to the QUERY_STRING (the information after the '?' in a URL). So, for example, http://www.example.com/test.php?id=3 contains GET
        data which is accessible with $_GET['id']. See also $_REQUEST.
      </p>
      <p class="note-comment">
        Note:
        Dots and spaces in variable names are converted to underscores. For example <input name="a.b" /> becomes $_REQUEST["a_b"].
      </p>
      <p>
        PHP also understands arrays in the context of form variables (see the related faq). You may, for example, group related variables together, or use this feature to retrieve values from a multiple select input. For example, let's post a form
        to
        itself and upon submission display the data:
      </p>
      <p>
        Example #4 More complex form variables
      </p>
      <code>
        &lt;?php<br>
        if ($_POST) {<br>
        echo '&lt;pre&gt;';<br>
        echo htmlspecialchars(print_r($_POST, true));<br>
        echo '&lt;/pre&gt;';<br>
        }<br>
        ?&gt;<br>
      </code>
      <code>
        &lt;form action="" method="post"&gt;<br />
        Name: &lt;input type="text" name="personal[name]" /&gt;&lt;br /&gt;<br />
        Email: &lt;input type="text" name="personal[email]" /&gt;&lt;br /&gt;<br />
        Beer: &lt;br /&gt;<br />&lt;select multiple name="beer[]"&gt;<br />
        &lt;option value="warthog"&gt;Warthog&lt;/option&gt;<br />
        &lt;option value="guinness"&gt;Guinness&lt;/option&gt;<br />
        &lt;option value="stuttgarter"&gt;Stuttgarter Schwabenbr&auml;u&lt;/option&gt;<br />
        &lt;/select&gt;&lt;br /&gt;<br />
        &lt;input type="submit" value="submit me!" /&gt;<br />
        &lt;/form&gt;
      </code>
      <p class="note-comment">
        Note: If an external variable name begins with a valid array syntax, trailing characters are silently ignored. For example, <input name="foo[bar]baz"> becomes $_REQUEST['foo']['bar'].
      </p>
      <h2>
        IMAGE SUBMIT variable names ¶
      </h2>
      <p>
        When submitting a form, it is possible to use an image instead of the standard submit button with a tag like:
      </p>
      <code>
        &lt; input type="image" src="image.gif" name="sub" /&gt;
      </code>
      <p>
        When the user clicks somewhere on the image, the accompanying form will be transmitted to the server with two additional variables, sub_x and sub_y. These contain the coordinates of the user click within the image. The experienced may note
        that the actual variable names sent by the browser contains a period rather than an underscore, but PHP converts the period to an underscore automatically.
      </p>
      <h2>
        HTTP Cookies ¶
      </h2>
      <p>
        PHP transparently supports HTTP cookies as defined by » RFC 6265. Cookies are a mechanism for storing data in the remote browser and thus tracking or identifying return users. You can set cookies using the setcookie() function. Cookies are
        part of the HTTP header, so the SetCookie function must be called before any output is sent to the browser. This is the same restriction as for the header() function. Cookie data is then available in the appropriate cookie data arrays, such
        as $_COOKIE as well as in $_REQUEST. See the setcookie() manual page for more details and examples.
      </p>
      <p>
        If you wish to assign multiple values to a single cookie variable, you may assign it as an array. For example:
      </p>
      <code>
        &lt;?php<br>
        setcookie("MyCookie[foo]", 'Testing 1', time()+3600);<br>
        setcookie("MyCookie[bar]", 'Testing 2', time()+3600);<br>
        ?&gt;<br>
      </code>
      <p>
        That will create two separate cookies although MyCookie will now be a single array in your script. If you want to set just one cookie with multiple values, consider using serialize() or explode() on the value first.
      </p>
      <p>
        Note that a cookie will replace a previous cookie by the same name in your browser unless the path or domain is different. So, for a shopping cart application you may want to keep a counter and pass this along. i.e.
      </p>
      <p>
        Example #5 A setcookie() example
      </p>
      <code>
        &lt;?php<br>
        if (isset($_COOKIE['count'])) {<br>
        $count = $_COOKIE['count'] + 1;<br>
        } else {<br>
        $count = 1;<br>
        }<br>
        setcookie('count', $count, time()+3600);<br>
        setcookie("Cart[$count]", $item, time()+3600);<br>
        ?&gt;<br>
      </code>
      <h2>
        Dots in incoming variable names ¶
      </h2>
      <p>
        Typically, PHP does not alter the names of variables when they are passed into a script. However, it should be noted that the dot (period, full stop) is not a valid character in a PHP variable name. For the reason, look at it:
      </p>
      <code>
        &lt;?php<br>
        $varname.ext; /* invalid variable name */<br>
        ?&gt;<br>
      </code>
      <p>
        Now, what the parser sees is a variable named $varname, followed by the string concatenation operator, followed by the barestring (i.e. unquoted string which doesn't match any known key or reserved words) 'ext'. Obviously, this doesn't have
        the intended result.
      </p>
      <p>
        For this reason, it is important to note that PHP will automatically replace any dots in incoming variable names with underscores.
      </p>
      <h2>
        Determining variable types ¶
      </h2>
      <p>
        Because PHP determines the types of variables and converts them (generally) as needed, it is not always obvious what type a given variable is at any one time. PHP includes several functions which find out what type a variable is, such as:
        gettype(), is_array(), is_float(), is_int(), is_object(), and is_string(). See also the chapter on Types.
      </p>
      <p>
        HTTP being a text protocol, most, if not all, content that comes in Superglobal arrays, like $_POST and $_GET will remain as strings. PHP will not try to convert values to a specific type. In the example below, $_GET["var1"] will contain the
        string "null" and $_GET["var2"], the string "123".
      </p>
      <p>
        /index.php?var1=null&var2=123
      </p>
    </section>

  </main>
</body>

</html>
